
// @generated
//  This file was automatically generated and should not be edited.

import Apollo
import Foundation

/// GraphQL namespace
public extension GraphQL {
  final class EmbarkStoryQuery: GraphQLQuery {
    /// The raw GraphQL definition of this operation.
    public let operationDefinition: String =
      """
      query EmbarkStory($name: String!, $locale: String!) {
        embarkStory(name: $name, locale: $locale) {
          __typename
          id
          startPassage
          name
          computedStoreValues {
            __typename
            key
            value
          }
          passages {
            __typename
            id
            name
            externalRedirect {
              __typename
              component
              data {
                __typename
                location
              }
            }
            offerRedirect {
              __typename
              component
              data {
                __typename
                keys
              }
            }
            variantedOfferRedirects {
              __typename
              component
              data {
                __typename
                expression {
                  __typename
                  ...ExpressionFragment
                }
                allKeys
                selectedKeys
              }
            }
            tooltips {
              __typename
              description
              title
            }
            allLinks {
              __typename
              ...EmbarkLinkFragment
            }
            response {
              __typename
              ...ResponseFragment
            }
            messages {
              __typename
              ...MessageFragment
            }
            api {
              __typename
              ...ApiFragment
            }
            redirects {
              __typename
              ...EmbarkRedirectFragment
            }
            tracks {
              __typename
              eventName
              eventKeys
              includeAllKeys
              customData
            }
            action {
              __typename
              ... on EmbarkMultiAction {
                multiActionData: data {
                  __typename
                  addLabel
                  key
                  maxAmount
                  link {
                    __typename
                    ...EmbarkLinkFragment
                  }
                  components {
                    __typename
                    ... on EmbarkMultiActionNumberAction {
                      numberActionData: data {
                        __typename
                        placeholder
                        key
                        label
                        unit
                      }
                    }
                    ... on EmbarkDropdownAction {
                      dropDownActionData: data {
                        __typename
                        label
                        key
                        options {
                          __typename
                          value
                          text
                        }
                      }
                    }
                    ... on EmbarkSwitchAction {
                      switchActionData: data {
                        __typename
                        label
                        key
                        defaultValue
                      }
                    }
                  }
                }
              }
              ... on EmbarkAudioRecorderAction {
                component
                audioRecorderData: data {
                  __typename
                  storeKey
                  label
                  next {
                    __typename
                    ...EmbarkLinkFragment
                  }
                }
              }
              ... on EmbarkActionCore {
                component
              }
              ... on EmbarkTextAction {
                component
                textActionData: data {
                  __typename
                  key
                  placeholder
                  mask
                  api {
                    __typename
                    ...ApiFragment
                  }
                  link {
                    __typename
                    ...EmbarkLinkFragment
                  }
                }
              }
              ... on EmbarkNumberAction {
                component
                numberActionData: data {
                  __typename
                  ...EmbarkNumberActionFragment
                }
              }
              ... on EmbarkAddressAutocompleteAction {
                component
                addressAutocompleteActionData: data {
                  __typename
                  placeholder
                  key
                  link {
                    __typename
                    ...EmbarkLinkFragment
                  }
                  api {
                    __typename
                    ...ApiFragment
                  }
                }
              }
              ... on EmbarkTextActionSet {
                textActionSetData: data {
                  __typename
                  link {
                    __typename
                    ...EmbarkLinkFragment
                  }
                  api {
                    __typename
                    ...ApiFragment
                  }
                  textActions {
                    __typename
                    data {
                      __typename
                      title
                      key
                      placeholder
                      mask
                    }
                  }
                }
              }
              ... on EmbarkSelectAction {
                component
                selectActionData: data {
                  __typename
                  options {
                    __typename
                    keys
                    values
                    link {
                      __typename
                      ...EmbarkLinkFragment
                    }
                    api {
                      __typename
                      ...ApiFragment
                    }
                    badge
                  }
                }
              }
              ... on EmbarkDatePickerAction {
                component
                next {
                  __typename
                  ...EmbarkLinkFragment
                }
                storeKey
                label
                tooltip {
                  __typename
                  title
                  description
                }
              }
              ... on EmbarkExternalInsuranceProviderAction {
                component
                externalInsuranceProviderData: data {
                  __typename
                  storeKey
                  next {
                    __typename
                    ...EmbarkLinkFragment
                  }
                  skip {
                    __typename
                    ...EmbarkLinkFragment
                  }
                }
              }
              ... on EmbarkPreviousInsuranceProviderAction {
                component
                previousInsuranceProviderData: data {
                  __typename
                  next {
                    __typename
                    ...EmbarkLinkFragment
                  }
                  skip {
                    __typename
                    ...EmbarkLinkFragment
                  }
                  providers
                  storeKey
                }
              }
              ... on EmbarkNumberActionSet {
                component
                data {
                  __typename
                  link {
                    __typename
                    ...EmbarkLinkFragment
                  }
                  numberActions {
                    __typename
                    data {
                      __typename
                      key
                      placeholder
                      unit
                      label
                      maxValue
                      minValue
                      title
                    }
                  }
                }
              }
            }
          }
        }
      }
      """

    public let operationName: String = "EmbarkStory"

    public var queryDocument: String {
      var document: String = operationDefinition
      document.append("\n" + ExpressionFragment.fragmentDefinition)
      document.append("\n" + BasicExpressionFragment.fragmentDefinition)
      document.append("\n" + EmbarkLinkFragment.fragmentDefinition)
      document.append("\n" + ResponseFragment.fragmentDefinition)
      document.append("\n" + MessageFragment.fragmentDefinition)
      document.append("\n" + ApiFragment.fragmentDefinition)
      document.append("\n" + ApiVariablesFragment.fragmentDefinition)
      document.append("\n" + ApiSingleVariableFragment.fragmentDefinition)
      document.append("\n" + ApiGeneratedVariableFragment.fragmentDefinition)
      document.append("\n" + ApiMultiActionVariableFragment.fragmentDefinition)
      document.append("\n" + EmbarkRedirectFragment.fragmentDefinition)
      document.append("\n" + EmbarkRedirectSingle.fragmentDefinition)
      document.append("\n" + EmbarkNumberActionFragment.fragmentDefinition)
      return document
    }

    public var name: String
    public var locale: String

    public init(name: String, locale: String) {
      self.name = name
      self.locale = locale
    }

    public var variables: GraphQLMap? {
      return ["name": name, "locale": locale]
    }

    public struct Data: GraphQLSelectionSet {
      public static let possibleTypes: [String] = ["Query"]

      public static var selections: [GraphQLSelection] {
        return [
          GraphQLField("embarkStory", arguments: ["name": GraphQLVariable("name"), "locale": GraphQLVariable("locale")], type: .object(EmbarkStory.selections)),
        ]
      }

      public private(set) var resultMap: ResultMap

      public init(unsafeResultMap: ResultMap) {
        self.resultMap = unsafeResultMap
      }

      public init(embarkStory: EmbarkStory? = nil) {
        self.init(unsafeResultMap: ["__typename": "Query", "embarkStory": embarkStory.flatMap { (value: EmbarkStory) -> ResultMap in value.resultMap }])
      }

      public var embarkStory: EmbarkStory? {
        get {
          return (resultMap["embarkStory"] as? ResultMap).flatMap { EmbarkStory(unsafeResultMap: $0) }
        }
        set {
          resultMap.updateValue(newValue?.resultMap, forKey: "embarkStory")
        }
      }

      public struct EmbarkStory: GraphQLSelectionSet {
        public static let possibleTypes: [String] = ["EmbarkStory"]

        public static var selections: [GraphQLSelection] {
          return [
            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
            GraphQLField("id", type: .nonNull(.scalar(String.self))),
            GraphQLField("startPassage", type: .nonNull(.scalar(String.self))),
            GraphQLField("name", type: .nonNull(.scalar(String.self))),
            GraphQLField("computedStoreValues", type: .list(.nonNull(.object(ComputedStoreValue.selections)))),
            GraphQLField("passages", type: .nonNull(.list(.nonNull(.object(Passage.selections))))),
          ]
        }

        public private(set) var resultMap: ResultMap

        public init(unsafeResultMap: ResultMap) {
          self.resultMap = unsafeResultMap
        }

        public init(id: String, startPassage: String, name: String, computedStoreValues: [ComputedStoreValue]? = nil, passages: [Passage]) {
          self.init(unsafeResultMap: ["__typename": "EmbarkStory", "id": id, "startPassage": startPassage, "name": name, "computedStoreValues": computedStoreValues.flatMap { (value: [ComputedStoreValue]) -> [ResultMap] in value.map { (value: ComputedStoreValue) -> ResultMap in value.resultMap } }, "passages": passages.map { (value: Passage) -> ResultMap in value.resultMap }])
        }

        public var __typename: String {
          get {
            return resultMap["__typename"]! as! String
          }
          set {
            resultMap.updateValue(newValue, forKey: "__typename")
          }
        }

        public var id: String {
          get {
            return resultMap["id"]! as! String
          }
          set {
            resultMap.updateValue(newValue, forKey: "id")
          }
        }

        public var startPassage: String {
          get {
            return resultMap["startPassage"]! as! String
          }
          set {
            resultMap.updateValue(newValue, forKey: "startPassage")
          }
        }

        public var name: String {
          get {
            return resultMap["name"]! as! String
          }
          set {
            resultMap.updateValue(newValue, forKey: "name")
          }
        }

        public var computedStoreValues: [ComputedStoreValue]? {
          get {
            return (resultMap["computedStoreValues"] as? [ResultMap]).flatMap { (value: [ResultMap]) -> [ComputedStoreValue] in value.map { (value: ResultMap) -> ComputedStoreValue in ComputedStoreValue(unsafeResultMap: value) } }
          }
          set {
            resultMap.updateValue(newValue.flatMap { (value: [ComputedStoreValue]) -> [ResultMap] in value.map { (value: ComputedStoreValue) -> ResultMap in value.resultMap } }, forKey: "computedStoreValues")
          }
        }

        public var passages: [Passage] {
          get {
            return (resultMap["passages"] as! [ResultMap]).map { (value: ResultMap) -> Passage in Passage(unsafeResultMap: value) }
          }
          set {
            resultMap.updateValue(newValue.map { (value: Passage) -> ResultMap in value.resultMap }, forKey: "passages")
          }
        }

        public struct ComputedStoreValue: GraphQLSelectionSet {
          public static let possibleTypes: [String] = ["EmbarkComputedStoreValue"]

          public static var selections: [GraphQLSelection] {
            return [
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("key", type: .nonNull(.scalar(String.self))),
              GraphQLField("value", type: .nonNull(.scalar(String.self))),
            ]
          }

          public private(set) var resultMap: ResultMap

          public init(unsafeResultMap: ResultMap) {
            self.resultMap = unsafeResultMap
          }

          public init(key: String, value: String) {
            self.init(unsafeResultMap: ["__typename": "EmbarkComputedStoreValue", "key": key, "value": value])
          }

          public var __typename: String {
            get {
              return resultMap["__typename"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "__typename")
            }
          }

          public var key: String {
            get {
              return resultMap["key"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "key")
            }
          }

          public var value: String {
            get {
              return resultMap["value"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "value")
            }
          }
        }

        public struct Passage: GraphQLSelectionSet {
          public static let possibleTypes: [String] = ["EmbarkPassage"]

          public static var selections: [GraphQLSelection] {
            return [
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("id", type: .nonNull(.scalar(String.self))),
              GraphQLField("name", type: .nonNull(.scalar(String.self))),
              GraphQLField("externalRedirect", type: .object(ExternalRedirect.selections)),
              GraphQLField("offerRedirect", type: .object(OfferRedirect.selections)),
              GraphQLField("variantedOfferRedirects", type: .nonNull(.list(.nonNull(.object(VariantedOfferRedirect.selections))))),
              GraphQLField("tooltips", type: .nonNull(.list(.nonNull(.object(Tooltip.selections))))),
              GraphQLField("allLinks", type: .nonNull(.list(.nonNull(.object(AllLink.selections))))),
              GraphQLField("response", type: .nonNull(.object(Response.selections))),
              GraphQLField("messages", type: .nonNull(.list(.nonNull(.object(Message.selections))))),
              GraphQLField("api", type: .object(Api.selections)),
              GraphQLField("redirects", type: .nonNull(.list(.nonNull(.object(Redirect.selections))))),
              GraphQLField("tracks", type: .nonNull(.list(.nonNull(.object(Track.selections))))),
              GraphQLField("action", type: .object(Action.selections)),
            ]
          }

          public private(set) var resultMap: ResultMap

          public init(unsafeResultMap: ResultMap) {
            self.resultMap = unsafeResultMap
          }

          public init(id: String, name: String, externalRedirect: ExternalRedirect? = nil, offerRedirect: OfferRedirect? = nil, variantedOfferRedirects: [VariantedOfferRedirect], tooltips: [Tooltip], allLinks: [AllLink], response: Response, messages: [Message], api: Api? = nil, redirects: [Redirect], tracks: [Track], action: Action? = nil) {
            self.init(unsafeResultMap: ["__typename": "EmbarkPassage", "id": id, "name": name, "externalRedirect": externalRedirect.flatMap { (value: ExternalRedirect) -> ResultMap in value.resultMap }, "offerRedirect": offerRedirect.flatMap { (value: OfferRedirect) -> ResultMap in value.resultMap }, "variantedOfferRedirects": variantedOfferRedirects.map { (value: VariantedOfferRedirect) -> ResultMap in value.resultMap }, "tooltips": tooltips.map { (value: Tooltip) -> ResultMap in value.resultMap }, "allLinks": allLinks.map { (value: AllLink) -> ResultMap in value.resultMap }, "response": response.resultMap, "messages": messages.map { (value: Message) -> ResultMap in value.resultMap }, "api": api.flatMap { (value: Api) -> ResultMap in value.resultMap }, "redirects": redirects.map { (value: Redirect) -> ResultMap in value.resultMap }, "tracks": tracks.map { (value: Track) -> ResultMap in value.resultMap }, "action": action.flatMap { (value: Action) -> ResultMap in value.resultMap }])
          }

          public var __typename: String {
            get {
              return resultMap["__typename"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "__typename")
            }
          }

          public var id: String {
            get {
              return resultMap["id"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "id")
            }
          }

          public var name: String {
            get {
              return resultMap["name"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "name")
            }
          }

          public var externalRedirect: ExternalRedirect? {
            get {
              return (resultMap["externalRedirect"] as? ResultMap).flatMap { ExternalRedirect(unsafeResultMap: $0) }
            }
            set {
              resultMap.updateValue(newValue?.resultMap, forKey: "externalRedirect")
            }
          }

          public var offerRedirect: OfferRedirect? {
            get {
              return (resultMap["offerRedirect"] as? ResultMap).flatMap { OfferRedirect(unsafeResultMap: $0) }
            }
            set {
              resultMap.updateValue(newValue?.resultMap, forKey: "offerRedirect")
            }
          }

          public var variantedOfferRedirects: [VariantedOfferRedirect] {
            get {
              return (resultMap["variantedOfferRedirects"] as! [ResultMap]).map { (value: ResultMap) -> VariantedOfferRedirect in VariantedOfferRedirect(unsafeResultMap: value) }
            }
            set {
              resultMap.updateValue(newValue.map { (value: VariantedOfferRedirect) -> ResultMap in value.resultMap }, forKey: "variantedOfferRedirects")
            }
          }

          public var tooltips: [Tooltip] {
            get {
              return (resultMap["tooltips"] as! [ResultMap]).map { (value: ResultMap) -> Tooltip in Tooltip(unsafeResultMap: value) }
            }
            set {
              resultMap.updateValue(newValue.map { (value: Tooltip) -> ResultMap in value.resultMap }, forKey: "tooltips")
            }
          }

          public var allLinks: [AllLink] {
            get {
              return (resultMap["allLinks"] as! [ResultMap]).map { (value: ResultMap) -> AllLink in AllLink(unsafeResultMap: value) }
            }
            set {
              resultMap.updateValue(newValue.map { (value: AllLink) -> ResultMap in value.resultMap }, forKey: "allLinks")
            }
          }

          public var response: Response {
            get {
              return Response(unsafeResultMap: resultMap["response"]! as! ResultMap)
            }
            set {
              resultMap.updateValue(newValue.resultMap, forKey: "response")
            }
          }

          public var messages: [Message] {
            get {
              return (resultMap["messages"] as! [ResultMap]).map { (value: ResultMap) -> Message in Message(unsafeResultMap: value) }
            }
            set {
              resultMap.updateValue(newValue.map { (value: Message) -> ResultMap in value.resultMap }, forKey: "messages")
            }
          }

          public var api: Api? {
            get {
              return (resultMap["api"] as? ResultMap).flatMap { Api(unsafeResultMap: $0) }
            }
            set {
              resultMap.updateValue(newValue?.resultMap, forKey: "api")
            }
          }

          public var redirects: [Redirect] {
            get {
              return (resultMap["redirects"] as! [ResultMap]).map { (value: ResultMap) -> Redirect in Redirect(unsafeResultMap: value) }
            }
            set {
              resultMap.updateValue(newValue.map { (value: Redirect) -> ResultMap in value.resultMap }, forKey: "redirects")
            }
          }

          public var tracks: [Track] {
            get {
              return (resultMap["tracks"] as! [ResultMap]).map { (value: ResultMap) -> Track in Track(unsafeResultMap: value) }
            }
            set {
              resultMap.updateValue(newValue.map { (value: Track) -> ResultMap in value.resultMap }, forKey: "tracks")
            }
          }

          public var action: Action? {
            get {
              return (resultMap["action"] as? ResultMap).flatMap { Action(unsafeResultMap: $0) }
            }
            set {
              resultMap.updateValue(newValue?.resultMap, forKey: "action")
            }
          }

          public struct ExternalRedirect: GraphQLSelectionSet {
            public static let possibleTypes: [String] = ["EmbarkExternalRedirect"]

            public static var selections: [GraphQLSelection] {
              return [
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("component", type: .nonNull(.scalar(String.self))),
                GraphQLField("data", type: .nonNull(.object(Datum.selections))),
              ]
            }

            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public init(component: String, data: Datum) {
              self.init(unsafeResultMap: ["__typename": "EmbarkExternalRedirect", "component": component, "data": data.resultMap])
            }

            public var __typename: String {
              get {
                return resultMap["__typename"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "__typename")
              }
            }

            public var component: String {
              get {
                return resultMap["component"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "component")
              }
            }

            public var data: Datum {
              get {
                return Datum(unsafeResultMap: resultMap["data"]! as! ResultMap)
              }
              set {
                resultMap.updateValue(newValue.resultMap, forKey: "data")
              }
            }

            public struct Datum: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkExternalRedirectData"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("location", type: .nonNull(.scalar(EmbarkExternalRedirectLocation.self))),
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public init(location: EmbarkExternalRedirectLocation) {
                self.init(unsafeResultMap: ["__typename": "EmbarkExternalRedirectData", "location": location])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var location: EmbarkExternalRedirectLocation {
                get {
                  return resultMap["location"]! as! EmbarkExternalRedirectLocation
                }
                set {
                  resultMap.updateValue(newValue, forKey: "location")
                }
              }
            }
          }

          public struct OfferRedirect: GraphQLSelectionSet {
            public static let possibleTypes: [String] = ["EmbarkOfferRedirect"]

            public static var selections: [GraphQLSelection] {
              return [
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("component", type: .nonNull(.scalar(String.self))),
                GraphQLField("data", type: .nonNull(.object(Datum.selections))),
              ]
            }

            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public init(component: String, data: Datum) {
              self.init(unsafeResultMap: ["__typename": "EmbarkOfferRedirect", "component": component, "data": data.resultMap])
            }

            public var __typename: String {
              get {
                return resultMap["__typename"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "__typename")
              }
            }

            public var component: String {
              get {
                return resultMap["component"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "component")
              }
            }

            public var data: Datum {
              get {
                return Datum(unsafeResultMap: resultMap["data"]! as! ResultMap)
              }
              set {
                resultMap.updateValue(newValue.resultMap, forKey: "data")
              }
            }

            public struct Datum: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkOfferRedirectData"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("keys", type: .nonNull(.list(.nonNull(.scalar(String.self))))),
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public init(keys: [String]) {
                self.init(unsafeResultMap: ["__typename": "EmbarkOfferRedirectData", "keys": keys])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var keys: [String] {
                get {
                  return resultMap["keys"]! as! [String]
                }
                set {
                  resultMap.updateValue(newValue, forKey: "keys")
                }
              }
            }
          }

          public struct VariantedOfferRedirect: GraphQLSelectionSet {
            public static let possibleTypes: [String] = ["EmbarkVariantedOfferRedirect"]

            public static var selections: [GraphQLSelection] {
              return [
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("component", type: .nonNull(.scalar(String.self))),
                GraphQLField("data", type: .nonNull(.object(Datum.selections))),
              ]
            }

            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public init(component: String, data: Datum) {
              self.init(unsafeResultMap: ["__typename": "EmbarkVariantedOfferRedirect", "component": component, "data": data.resultMap])
            }

            public var __typename: String {
              get {
                return resultMap["__typename"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "__typename")
              }
            }

            public var component: String {
              get {
                return resultMap["component"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "component")
              }
            }

            public var data: Datum {
              get {
                return Datum(unsafeResultMap: resultMap["data"]! as! ResultMap)
              }
              set {
                resultMap.updateValue(newValue.resultMap, forKey: "data")
              }
            }

            public struct Datum: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkVariantedOfferRedirectData"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("expression", type: .nonNull(.object(Expression.selections))),
                  GraphQLField("allKeys", type: .nonNull(.list(.nonNull(.scalar(String.self))))),
                  GraphQLField("selectedKeys", type: .nonNull(.list(.nonNull(.scalar(String.self))))),
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public init(expression: Expression, allKeys: [String], selectedKeys: [String]) {
                self.init(unsafeResultMap: ["__typename": "EmbarkVariantedOfferRedirectData", "expression": expression.resultMap, "allKeys": allKeys, "selectedKeys": selectedKeys])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var expression: Expression {
                get {
                  return Expression(unsafeResultMap: resultMap["expression"]! as! ResultMap)
                }
                set {
                  resultMap.updateValue(newValue.resultMap, forKey: "expression")
                }
              }

              public var allKeys: [String] {
                get {
                  return resultMap["allKeys"]! as! [String]
                }
                set {
                  resultMap.updateValue(newValue, forKey: "allKeys")
                }
              }

              public var selectedKeys: [String] {
                get {
                  return resultMap["selectedKeys"]! as! [String]
                }
                set {
                  resultMap.updateValue(newValue, forKey: "selectedKeys")
                }
              }

              public struct Expression: GraphQLSelectionSet {
                public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

                public static var selections: [GraphQLSelection] {
                  return [
                    GraphQLTypeCase(
                      variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
                      default: [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      ]
                    )
                  ]
                }

                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> Expression {
                  return Expression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                }

                public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> Expression {
                  return Expression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                }

                public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> Expression {
                  return Expression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
                }

                public var __typename: String {
                  get {
                    return resultMap["__typename"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "__typename")
                  }
                }

                public var fragments: Fragments {
                  get {
                    return Fragments(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }

                public struct Fragments {
                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public var expressionFragment: ExpressionFragment {
                    get {
                      return ExpressionFragment(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public var basicExpressionFragment: BasicExpressionFragment {
                    get {
                      return BasicExpressionFragment(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }
                }

                public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                  get {
                    if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                    return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                  }
                  set {
                    guard let newValue = newValue else { return }
                    resultMap = newValue.resultMap
                  }
                }

                public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                      GraphQLField("text", type: .scalar(String.self)),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var expressionUnaryType: EmbarkExpressionTypeUnary {
                    get {
                      return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                    }
                  }

                  public var text: String? {
                    get {
                      return resultMap["text"] as? String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "text")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var expressionFragment: ExpressionFragment {
                      get {
                        return ExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public var basicExpressionFragment: BasicExpressionFragment {
                      get {
                        return BasicExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }
                }

                public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                  get {
                    if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                    return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                  }
                  set {
                    guard let newValue = newValue else { return }
                    resultMap = newValue.resultMap
                  }
                }

                public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                      GraphQLField("key", type: .nonNull(.scalar(String.self))),
                      GraphQLField("value", type: .nonNull(.scalar(String.self))),
                      GraphQLField("text", type: .scalar(String.self)),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var expressionBinaryType: EmbarkExpressionTypeBinary {
                    get {
                      return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                    }
                  }

                  public var key: String {
                    get {
                      return resultMap["key"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "key")
                    }
                  }

                  public var value: String {
                    get {
                      return resultMap["value"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "value")
                    }
                  }

                  public var text: String? {
                    get {
                      return resultMap["text"] as? String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "text")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var expressionFragment: ExpressionFragment {
                      get {
                        return ExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public var basicExpressionFragment: BasicExpressionFragment {
                      get {
                        return BasicExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }
                }

                public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
                  get {
                    if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
                    return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
                  }
                  set {
                    guard let newValue = newValue else { return }
                    resultMap = newValue.resultMap
                  }
                }

                public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
                      GraphQLField("text", type: .scalar(String.self)),
                      GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var expressionMultipleType: EmbarkExpressionTypeMultiple {
                    get {
                      return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "expressionMultipleType")
                    }
                  }

                  public var text: String? {
                    get {
                      return resultMap["text"] as? String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "text")
                    }
                  }

                  public var subExpressions: [SubExpression] {
                    get {
                      return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
                    }
                    set {
                      resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var expressionFragment: ExpressionFragment {
                      get {
                        return ExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public var basicExpressionFragment: BasicExpressionFragment {
                      get {
                        return BasicExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }

                  public struct SubExpression: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLTypeCase(
                          variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
                          default: [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          ]
                        )
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
                      return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                    }

                    public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
                      return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                    }

                    public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> SubExpression {
                      return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var fragments: Fragments {
                      get {
                        return Fragments(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public struct Fragments {
                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public var basicExpressionFragment: BasicExpressionFragment {
                        get {
                          return BasicExpressionFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }
                    }

                    public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                      get {
                        if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                        return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                      }
                      set {
                        guard let newValue = newValue else { return }
                        resultMap = newValue.resultMap
                      }
                    }

                    public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                      public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                      public static var selections: [GraphQLSelection] {
                        return [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                          GraphQLField("text", type: .scalar(String.self)),
                        ]
                      }

                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                        self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                      }

                      public var __typename: String {
                        get {
                          return resultMap["__typename"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "__typename")
                        }
                      }

                      public var expressionUnaryType: EmbarkExpressionTypeUnary {
                        get {
                          return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                        }
                      }

                      public var text: String? {
                        get {
                          return resultMap["text"] as? String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "text")
                        }
                      }

                      public var fragments: Fragments {
                        get {
                          return Fragments(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public struct Fragments {
                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public var basicExpressionFragment: BasicExpressionFragment {
                          get {
                            return BasicExpressionFragment(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }
                      }
                    }

                    public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                      get {
                        if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                        return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                      }
                      set {
                        guard let newValue = newValue else { return }
                        resultMap = newValue.resultMap
                      }
                    }

                    public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                      public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                      public static var selections: [GraphQLSelection] {
                        return [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                          GraphQLField("key", type: .nonNull(.scalar(String.self))),
                          GraphQLField("value", type: .nonNull(.scalar(String.self))),
                          GraphQLField("text", type: .scalar(String.self)),
                        ]
                      }

                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                        self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                      }

                      public var __typename: String {
                        get {
                          return resultMap["__typename"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "__typename")
                        }
                      }

                      public var expressionBinaryType: EmbarkExpressionTypeBinary {
                        get {
                          return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                        }
                      }

                      public var key: String {
                        get {
                          return resultMap["key"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "key")
                        }
                      }

                      public var value: String {
                        get {
                          return resultMap["value"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "value")
                        }
                      }

                      public var text: String? {
                        get {
                          return resultMap["text"] as? String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "text")
                        }
                      }

                      public var fragments: Fragments {
                        get {
                          return Fragments(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public struct Fragments {
                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public var basicExpressionFragment: BasicExpressionFragment {
                          get {
                            return BasicExpressionFragment(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }
                      }
                    }

                    public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
                      get {
                        if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
                        return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
                      }
                      set {
                        guard let newValue = newValue else { return }
                        resultMap = newValue.resultMap
                      }
                    }

                    public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
                      public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

                      public static var selections: [GraphQLSelection] {
                        return [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
                          GraphQLField("text", type: .scalar(String.self)),
                          GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
                        ]
                      }

                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
                        self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
                      }

                      public var __typename: String {
                        get {
                          return resultMap["__typename"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "__typename")
                        }
                      }

                      public var expressionMultipleType: EmbarkExpressionTypeMultiple {
                        get {
                          return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "expressionMultipleType")
                        }
                      }

                      public var text: String? {
                        get {
                          return resultMap["text"] as? String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "text")
                        }
                      }

                      public var subExpressions: [SubExpression] {
                        get {
                          return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
                        }
                        set {
                          resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
                        }
                      }

                      public var fragments: Fragments {
                        get {
                          return Fragments(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public struct Fragments {
                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public var basicExpressionFragment: BasicExpressionFragment {
                          get {
                            return BasicExpressionFragment(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }
                      }

                      public struct SubExpression: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLTypeCase(
                              variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
                              default: [
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              ]
                            )
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
                          return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                        }

                        public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
                          return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                        }

                        public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> SubExpression {
                          return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var fragments: Fragments {
                          get {
                            return Fragments(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }

                        public struct Fragments {
                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public var basicExpressionFragment: BasicExpressionFragment {
                            get {
                              return BasicExpressionFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }
                        }

                        public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                          get {
                            if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                            return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                          }
                          set {
                            guard let newValue = newValue else { return }
                            resultMap = newValue.resultMap
                          }
                        }

                        public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                              GraphQLField("text", type: .scalar(String.self)),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var expressionUnaryType: EmbarkExpressionTypeUnary {
                            get {
                              return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                            }
                          }

                          public var text: String? {
                            get {
                              return resultMap["text"] as? String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "text")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var basicExpressionFragment: BasicExpressionFragment {
                              get {
                                return BasicExpressionFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }
                          }
                        }

                        public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                          get {
                            if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                            return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                          }
                          set {
                            guard let newValue = newValue else { return }
                            resultMap = newValue.resultMap
                          }
                        }

                        public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                              GraphQLField("key", type: .nonNull(.scalar(String.self))),
                              GraphQLField("value", type: .nonNull(.scalar(String.self))),
                              GraphQLField("text", type: .scalar(String.self)),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var expressionBinaryType: EmbarkExpressionTypeBinary {
                            get {
                              return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                            }
                          }

                          public var key: String {
                            get {
                              return resultMap["key"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "key")
                            }
                          }

                          public var value: String {
                            get {
                              return resultMap["value"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "value")
                            }
                          }

                          public var text: String? {
                            get {
                              return resultMap["text"] as? String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "text")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var basicExpressionFragment: BasicExpressionFragment {
                              get {
                                return BasicExpressionFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }
                          }
                        }

                        public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
                          get {
                            if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
                            return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
                          }
                          set {
                            guard let newValue = newValue else { return }
                            resultMap = newValue.resultMap
                          }
                        }

                        public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
                              GraphQLField("text", type: .scalar(String.self)),
                              GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var expressionMultipleType: EmbarkExpressionTypeMultiple {
                            get {
                              return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "expressionMultipleType")
                            }
                          }

                          public var text: String? {
                            get {
                              return resultMap["text"] as? String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "text")
                            }
                          }

                          public var subExpressions: [SubExpression] {
                            get {
                              return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
                            }
                            set {
                              resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var basicExpressionFragment: BasicExpressionFragment {
                              get {
                                return BasicExpressionFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }
                          }

                          public struct SubExpression: GraphQLSelectionSet {
                            public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

                            public static var selections: [GraphQLSelection] {
                              return [
                                GraphQLTypeCase(
                                  variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections],
                                  default: [
                                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  ]
                                )
                              ]
                            }

                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public static func makeEmbarkExpressionMultiple() -> SubExpression {
                              return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple"])
                            }

                            public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
                              return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                            }

                            public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
                              return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                            }

                            public var __typename: String {
                              get {
                                return resultMap["__typename"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "__typename")
                              }
                            }

                            public var fragments: Fragments {
                              get {
                                return Fragments(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public struct Fragments {
                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public var basicExpressionFragment: BasicExpressionFragment {
                                get {
                                  return BasicExpressionFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }
                            }

                            public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                              get {
                                if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                                return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap = newValue.resultMap
                              }
                            }

                            public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                              public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                              public static var selections: [GraphQLSelection] {
                                return [
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                                  GraphQLField("text", type: .scalar(String.self)),
                                ]
                              }

                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                                self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                              }

                              public var __typename: String {
                                get {
                                  return resultMap["__typename"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "__typename")
                                }
                              }

                              public var expressionUnaryType: EmbarkExpressionTypeUnary {
                                get {
                                  return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                                }
                              }

                              public var text: String? {
                                get {
                                  return resultMap["text"] as? String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "text")
                                }
                              }

                              public var fragments: Fragments {
                                get {
                                  return Fragments(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public struct Fragments {
                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public var basicExpressionFragment: BasicExpressionFragment {
                                  get {
                                    return BasicExpressionFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    resultMap += newValue.resultMap
                                  }
                                }
                              }
                            }

                            public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                              get {
                                if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                                return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap = newValue.resultMap
                              }
                            }

                            public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                              public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                              public static var selections: [GraphQLSelection] {
                                return [
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                                  GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("value", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("text", type: .scalar(String.self)),
                                ]
                              }

                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                                self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                              }

                              public var __typename: String {
                                get {
                                  return resultMap["__typename"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "__typename")
                                }
                              }

                              public var expressionBinaryType: EmbarkExpressionTypeBinary {
                                get {
                                  return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                                }
                              }

                              public var key: String {
                                get {
                                  return resultMap["key"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "key")
                                }
                              }

                              public var value: String {
                                get {
                                  return resultMap["value"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "value")
                                }
                              }

                              public var text: String? {
                                get {
                                  return resultMap["text"] as? String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "text")
                                }
                              }

                              public var fragments: Fragments {
                                get {
                                  return Fragments(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public struct Fragments {
                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public var basicExpressionFragment: BasicExpressionFragment {
                                  get {
                                    return BasicExpressionFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    resultMap += newValue.resultMap
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }

          public struct Tooltip: GraphQLSelectionSet {
            public static let possibleTypes: [String] = ["EmbarkTooltip"]

            public static var selections: [GraphQLSelection] {
              return [
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("description", type: .nonNull(.scalar(String.self))),
                GraphQLField("title", type: .nonNull(.scalar(String.self))),
              ]
            }

            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public init(description: String, title: String) {
              self.init(unsafeResultMap: ["__typename": "EmbarkTooltip", "description": description, "title": title])
            }

            public var __typename: String {
              get {
                return resultMap["__typename"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "__typename")
              }
            }

            public var description: String {
              get {
                return resultMap["description"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "description")
              }
            }

            public var title: String {
              get {
                return resultMap["title"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "title")
              }
            }
          }

          public struct AllLink: GraphQLSelectionSet {
            public static let possibleTypes: [String] = ["EmbarkLink"]

            public static var selections: [GraphQLSelection] {
              return [
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("name", type: .nonNull(.scalar(String.self))),
                GraphQLField("label", type: .nonNull(.scalar(String.self))),
              ]
            }

            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public init(name: String, label: String) {
              self.init(unsafeResultMap: ["__typename": "EmbarkLink", "name": name, "label": label])
            }

            public var __typename: String {
              get {
                return resultMap["__typename"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "__typename")
              }
            }

            public var name: String {
              get {
                return resultMap["name"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "name")
              }
            }

            public var label: String {
              get {
                return resultMap["label"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "label")
              }
            }

            public var fragments: Fragments {
              get {
                return Fragments(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }

            public struct Fragments {
              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public var embarkLinkFragment: EmbarkLinkFragment {
                get {
                  return EmbarkLinkFragment(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }
            }
          }

          public struct Response: GraphQLSelectionSet {
            public static let possibleTypes: [String] = ["EmbarkGroupedResponse", "EmbarkResponseExpression", "EmbarkMessage"]

            public static var selections: [GraphQLSelection] {
              return [
                GraphQLTypeCase(
                  variants: ["EmbarkMessage": AsEmbarkMessage.selections, "EmbarkGroupedResponse": AsEmbarkGroupedResponse.selections, "EmbarkResponseExpression": AsEmbarkResponseExpression.selections],
                  default: [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  ]
                )
              ]
            }

            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public static func makeEmbarkMessage(text: String, expressions: [AsEmbarkMessage.Expression]) -> Response {
              return Response(unsafeResultMap: ["__typename": "EmbarkMessage", "text": text, "expressions": expressions.map { (value: AsEmbarkMessage.Expression) -> ResultMap in value.resultMap }])
            }

            public static func makeEmbarkGroupedResponse(component: String, items: [AsEmbarkGroupedResponse.Item], each: AsEmbarkGroupedResponse.Each? = nil, title: AsEmbarkGroupedResponse.Title) -> Response {
              return Response(unsafeResultMap: ["__typename": "EmbarkGroupedResponse", "component": component, "items": items.map { (value: AsEmbarkGroupedResponse.Item) -> ResultMap in value.resultMap }, "each": each.flatMap { (value: AsEmbarkGroupedResponse.Each) -> ResultMap in value.resultMap }, "title": title.resultMap])
            }

            public static func makeEmbarkResponseExpression(text: String, expressions: [AsEmbarkResponseExpression.Expression]) -> Response {
              return Response(unsafeResultMap: ["__typename": "EmbarkResponseExpression", "text": text, "expressions": expressions.map { (value: AsEmbarkResponseExpression.Expression) -> ResultMap in value.resultMap }])
            }

            public var __typename: String {
              get {
                return resultMap["__typename"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "__typename")
              }
            }

            public var fragments: Fragments {
              get {
                return Fragments(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }

            public struct Fragments {
              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public var responseFragment: ResponseFragment {
                get {
                  return ResponseFragment(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }
            }

            public var asEmbarkMessage: AsEmbarkMessage? {
              get {
                if !AsEmbarkMessage.possibleTypes.contains(__typename) { return nil }
                return AsEmbarkMessage(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap = newValue.resultMap
              }
            }

            public struct AsEmbarkMessage: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkMessage"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("text", type: .nonNull(.scalar(String.self))),
                  GraphQLField("expressions", type: .nonNull(.list(.nonNull(.object(Expression.selections))))),
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public init(text: String, expressions: [Expression]) {
                self.init(unsafeResultMap: ["__typename": "EmbarkMessage", "text": text, "expressions": expressions.map { (value: Expression) -> ResultMap in value.resultMap }])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var text: String {
                get {
                  return resultMap["text"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "text")
                }
              }

              public var expressions: [Expression] {
                get {
                  return (resultMap["expressions"] as! [ResultMap]).map { (value: ResultMap) -> Expression in Expression(unsafeResultMap: value) }
                }
                set {
                  resultMap.updateValue(newValue.map { (value: Expression) -> ResultMap in value.resultMap }, forKey: "expressions")
                }
              }

              public var fragments: Fragments {
                get {
                  return Fragments(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public struct Fragments {
                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public var responseFragment: ResponseFragment {
                  get {
                    return ResponseFragment(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }

                public var messageFragment: MessageFragment {
                  get {
                    return MessageFragment(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }
              }

              public struct Expression: GraphQLSelectionSet {
                public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

                public static var selections: [GraphQLSelection] {
                  return [
                    GraphQLTypeCase(
                      variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
                      default: [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      ]
                    )
                  ]
                }

                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> Expression {
                  return Expression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                }

                public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> Expression {
                  return Expression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                }

                public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> Expression {
                  return Expression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
                }

                public var __typename: String {
                  get {
                    return resultMap["__typename"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "__typename")
                  }
                }

                public var fragments: Fragments {
                  get {
                    return Fragments(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }

                public struct Fragments {
                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public var expressionFragment: ExpressionFragment {
                    get {
                      return ExpressionFragment(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public var basicExpressionFragment: BasicExpressionFragment {
                    get {
                      return BasicExpressionFragment(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }
                }

                public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                  get {
                    if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                    return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                  }
                  set {
                    guard let newValue = newValue else { return }
                    resultMap = newValue.resultMap
                  }
                }

                public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                      GraphQLField("text", type: .scalar(String.self)),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var expressionUnaryType: EmbarkExpressionTypeUnary {
                    get {
                      return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                    }
                  }

                  public var text: String? {
                    get {
                      return resultMap["text"] as? String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "text")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var expressionFragment: ExpressionFragment {
                      get {
                        return ExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public var basicExpressionFragment: BasicExpressionFragment {
                      get {
                        return BasicExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }
                }

                public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                  get {
                    if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                    return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                  }
                  set {
                    guard let newValue = newValue else { return }
                    resultMap = newValue.resultMap
                  }
                }

                public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                      GraphQLField("key", type: .nonNull(.scalar(String.self))),
                      GraphQLField("value", type: .nonNull(.scalar(String.self))),
                      GraphQLField("text", type: .scalar(String.self)),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var expressionBinaryType: EmbarkExpressionTypeBinary {
                    get {
                      return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                    }
                  }

                  public var key: String {
                    get {
                      return resultMap["key"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "key")
                    }
                  }

                  public var value: String {
                    get {
                      return resultMap["value"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "value")
                    }
                  }

                  public var text: String? {
                    get {
                      return resultMap["text"] as? String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "text")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var expressionFragment: ExpressionFragment {
                      get {
                        return ExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public var basicExpressionFragment: BasicExpressionFragment {
                      get {
                        return BasicExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }
                }

                public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
                  get {
                    if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
                    return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
                  }
                  set {
                    guard let newValue = newValue else { return }
                    resultMap = newValue.resultMap
                  }
                }

                public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
                      GraphQLField("text", type: .scalar(String.self)),
                      GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var expressionMultipleType: EmbarkExpressionTypeMultiple {
                    get {
                      return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "expressionMultipleType")
                    }
                  }

                  public var text: String? {
                    get {
                      return resultMap["text"] as? String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "text")
                    }
                  }

                  public var subExpressions: [SubExpression] {
                    get {
                      return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
                    }
                    set {
                      resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var expressionFragment: ExpressionFragment {
                      get {
                        return ExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public var basicExpressionFragment: BasicExpressionFragment {
                      get {
                        return BasicExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }

                  public struct SubExpression: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLTypeCase(
                          variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
                          default: [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          ]
                        )
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
                      return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                    }

                    public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
                      return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                    }

                    public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> SubExpression {
                      return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var fragments: Fragments {
                      get {
                        return Fragments(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public struct Fragments {
                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public var basicExpressionFragment: BasicExpressionFragment {
                        get {
                          return BasicExpressionFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }
                    }

                    public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                      get {
                        if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                        return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                      }
                      set {
                        guard let newValue = newValue else { return }
                        resultMap = newValue.resultMap
                      }
                    }

                    public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                      public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                      public static var selections: [GraphQLSelection] {
                        return [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                          GraphQLField("text", type: .scalar(String.self)),
                        ]
                      }

                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                        self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                      }

                      public var __typename: String {
                        get {
                          return resultMap["__typename"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "__typename")
                        }
                      }

                      public var expressionUnaryType: EmbarkExpressionTypeUnary {
                        get {
                          return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                        }
                      }

                      public var text: String? {
                        get {
                          return resultMap["text"] as? String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "text")
                        }
                      }

                      public var fragments: Fragments {
                        get {
                          return Fragments(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public struct Fragments {
                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public var basicExpressionFragment: BasicExpressionFragment {
                          get {
                            return BasicExpressionFragment(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }
                      }
                    }

                    public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                      get {
                        if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                        return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                      }
                      set {
                        guard let newValue = newValue else { return }
                        resultMap = newValue.resultMap
                      }
                    }

                    public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                      public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                      public static var selections: [GraphQLSelection] {
                        return [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                          GraphQLField("key", type: .nonNull(.scalar(String.self))),
                          GraphQLField("value", type: .nonNull(.scalar(String.self))),
                          GraphQLField("text", type: .scalar(String.self)),
                        ]
                      }

                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                        self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                      }

                      public var __typename: String {
                        get {
                          return resultMap["__typename"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "__typename")
                        }
                      }

                      public var expressionBinaryType: EmbarkExpressionTypeBinary {
                        get {
                          return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                        }
                      }

                      public var key: String {
                        get {
                          return resultMap["key"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "key")
                        }
                      }

                      public var value: String {
                        get {
                          return resultMap["value"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "value")
                        }
                      }

                      public var text: String? {
                        get {
                          return resultMap["text"] as? String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "text")
                        }
                      }

                      public var fragments: Fragments {
                        get {
                          return Fragments(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public struct Fragments {
                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public var basicExpressionFragment: BasicExpressionFragment {
                          get {
                            return BasicExpressionFragment(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }
                      }
                    }

                    public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
                      get {
                        if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
                        return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
                      }
                      set {
                        guard let newValue = newValue else { return }
                        resultMap = newValue.resultMap
                      }
                    }

                    public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
                      public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

                      public static var selections: [GraphQLSelection] {
                        return [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
                          GraphQLField("text", type: .scalar(String.self)),
                          GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
                        ]
                      }

                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
                        self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
                      }

                      public var __typename: String {
                        get {
                          return resultMap["__typename"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "__typename")
                        }
                      }

                      public var expressionMultipleType: EmbarkExpressionTypeMultiple {
                        get {
                          return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "expressionMultipleType")
                        }
                      }

                      public var text: String? {
                        get {
                          return resultMap["text"] as? String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "text")
                        }
                      }

                      public var subExpressions: [SubExpression] {
                        get {
                          return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
                        }
                        set {
                          resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
                        }
                      }

                      public var fragments: Fragments {
                        get {
                          return Fragments(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public struct Fragments {
                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public var basicExpressionFragment: BasicExpressionFragment {
                          get {
                            return BasicExpressionFragment(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }
                      }

                      public struct SubExpression: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLTypeCase(
                              variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
                              default: [
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              ]
                            )
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
                          return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                        }

                        public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
                          return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                        }

                        public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> SubExpression {
                          return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var fragments: Fragments {
                          get {
                            return Fragments(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }

                        public struct Fragments {
                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public var basicExpressionFragment: BasicExpressionFragment {
                            get {
                              return BasicExpressionFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }
                        }

                        public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                          get {
                            if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                            return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                          }
                          set {
                            guard let newValue = newValue else { return }
                            resultMap = newValue.resultMap
                          }
                        }

                        public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                              GraphQLField("text", type: .scalar(String.self)),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var expressionUnaryType: EmbarkExpressionTypeUnary {
                            get {
                              return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                            }
                          }

                          public var text: String? {
                            get {
                              return resultMap["text"] as? String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "text")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var basicExpressionFragment: BasicExpressionFragment {
                              get {
                                return BasicExpressionFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }
                          }
                        }

                        public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                          get {
                            if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                            return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                          }
                          set {
                            guard let newValue = newValue else { return }
                            resultMap = newValue.resultMap
                          }
                        }

                        public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                              GraphQLField("key", type: .nonNull(.scalar(String.self))),
                              GraphQLField("value", type: .nonNull(.scalar(String.self))),
                              GraphQLField("text", type: .scalar(String.self)),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var expressionBinaryType: EmbarkExpressionTypeBinary {
                            get {
                              return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                            }
                          }

                          public var key: String {
                            get {
                              return resultMap["key"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "key")
                            }
                          }

                          public var value: String {
                            get {
                              return resultMap["value"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "value")
                            }
                          }

                          public var text: String? {
                            get {
                              return resultMap["text"] as? String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "text")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var basicExpressionFragment: BasicExpressionFragment {
                              get {
                                return BasicExpressionFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }
                          }
                        }

                        public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
                          get {
                            if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
                            return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
                          }
                          set {
                            guard let newValue = newValue else { return }
                            resultMap = newValue.resultMap
                          }
                        }

                        public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
                              GraphQLField("text", type: .scalar(String.self)),
                              GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var expressionMultipleType: EmbarkExpressionTypeMultiple {
                            get {
                              return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "expressionMultipleType")
                            }
                          }

                          public var text: String? {
                            get {
                              return resultMap["text"] as? String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "text")
                            }
                          }

                          public var subExpressions: [SubExpression] {
                            get {
                              return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
                            }
                            set {
                              resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var basicExpressionFragment: BasicExpressionFragment {
                              get {
                                return BasicExpressionFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }
                          }

                          public struct SubExpression: GraphQLSelectionSet {
                            public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

                            public static var selections: [GraphQLSelection] {
                              return [
                                GraphQLTypeCase(
                                  variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections],
                                  default: [
                                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  ]
                                )
                              ]
                            }

                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public static func makeEmbarkExpressionMultiple() -> SubExpression {
                              return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple"])
                            }

                            public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
                              return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                            }

                            public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
                              return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                            }

                            public var __typename: String {
                              get {
                                return resultMap["__typename"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "__typename")
                              }
                            }

                            public var fragments: Fragments {
                              get {
                                return Fragments(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public struct Fragments {
                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public var basicExpressionFragment: BasicExpressionFragment {
                                get {
                                  return BasicExpressionFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }
                            }

                            public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                              get {
                                if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                                return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap = newValue.resultMap
                              }
                            }

                            public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                              public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                              public static var selections: [GraphQLSelection] {
                                return [
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                                  GraphQLField("text", type: .scalar(String.self)),
                                ]
                              }

                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                                self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                              }

                              public var __typename: String {
                                get {
                                  return resultMap["__typename"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "__typename")
                                }
                              }

                              public var expressionUnaryType: EmbarkExpressionTypeUnary {
                                get {
                                  return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                                }
                              }

                              public var text: String? {
                                get {
                                  return resultMap["text"] as? String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "text")
                                }
                              }

                              public var fragments: Fragments {
                                get {
                                  return Fragments(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public struct Fragments {
                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public var basicExpressionFragment: BasicExpressionFragment {
                                  get {
                                    return BasicExpressionFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    resultMap += newValue.resultMap
                                  }
                                }
                              }
                            }

                            public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                              get {
                                if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                                return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap = newValue.resultMap
                              }
                            }

                            public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                              public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                              public static var selections: [GraphQLSelection] {
                                return [
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                                  GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("value", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("text", type: .scalar(String.self)),
                                ]
                              }

                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                                self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                              }

                              public var __typename: String {
                                get {
                                  return resultMap["__typename"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "__typename")
                                }
                              }

                              public var expressionBinaryType: EmbarkExpressionTypeBinary {
                                get {
                                  return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                                }
                              }

                              public var key: String {
                                get {
                                  return resultMap["key"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "key")
                                }
                              }

                              public var value: String {
                                get {
                                  return resultMap["value"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "value")
                                }
                              }

                              public var text: String? {
                                get {
                                  return resultMap["text"] as? String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "text")
                                }
                              }

                              public var fragments: Fragments {
                                get {
                                  return Fragments(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public struct Fragments {
                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public var basicExpressionFragment: BasicExpressionFragment {
                                  get {
                                    return BasicExpressionFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    resultMap += newValue.resultMap
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }

            public var asEmbarkGroupedResponse: AsEmbarkGroupedResponse? {
              get {
                if !AsEmbarkGroupedResponse.possibleTypes.contains(__typename) { return nil }
                return AsEmbarkGroupedResponse(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap = newValue.resultMap
              }
            }

            public struct AsEmbarkGroupedResponse: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkGroupedResponse"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("component", type: .nonNull(.scalar(String.self))),
                  GraphQLField("items", type: .nonNull(.list(.nonNull(.object(Item.selections))))),
                  GraphQLField("each", type: .object(Each.selections)),
                  GraphQLField("title", type: .nonNull(.object(Title.selections))),
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public init(component: String, items: [Item], each: Each? = nil, title: Title) {
                self.init(unsafeResultMap: ["__typename": "EmbarkGroupedResponse", "component": component, "items": items.map { (value: Item) -> ResultMap in value.resultMap }, "each": each.flatMap { (value: Each) -> ResultMap in value.resultMap }, "title": title.resultMap])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var component: String {
                get {
                  return resultMap["component"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "component")
                }
              }

              public var items: [Item] {
                get {
                  return (resultMap["items"] as! [ResultMap]).map { (value: ResultMap) -> Item in Item(unsafeResultMap: value) }
                }
                set {
                  resultMap.updateValue(newValue.map { (value: Item) -> ResultMap in value.resultMap }, forKey: "items")
                }
              }

              public var each: Each? {
                get {
                  return (resultMap["each"] as? ResultMap).flatMap { Each(unsafeResultMap: $0) }
                }
                set {
                  resultMap.updateValue(newValue?.resultMap, forKey: "each")
                }
              }

              public var title: Title {
                get {
                  return Title(unsafeResultMap: resultMap["title"]! as! ResultMap)
                }
                set {
                  resultMap.updateValue(newValue.resultMap, forKey: "title")
                }
              }

              public var fragments: Fragments {
                get {
                  return Fragments(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public struct Fragments {
                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public var responseFragment: ResponseFragment {
                  get {
                    return ResponseFragment(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }
              }

              public struct Item: GraphQLSelectionSet {
                public static let possibleTypes: [String] = ["EmbarkMessage"]

                public static var selections: [GraphQLSelection] {
                  return [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("text", type: .nonNull(.scalar(String.self))),
                    GraphQLField("expressions", type: .nonNull(.list(.nonNull(.object(Expression.selections))))),
                  ]
                }

                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public init(text: String, expressions: [Expression]) {
                  self.init(unsafeResultMap: ["__typename": "EmbarkMessage", "text": text, "expressions": expressions.map { (value: Expression) -> ResultMap in value.resultMap }])
                }

                public var __typename: String {
                  get {
                    return resultMap["__typename"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "__typename")
                  }
                }

                public var text: String {
                  get {
                    return resultMap["text"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "text")
                  }
                }

                public var expressions: [Expression] {
                  get {
                    return (resultMap["expressions"] as! [ResultMap]).map { (value: ResultMap) -> Expression in Expression(unsafeResultMap: value) }
                  }
                  set {
                    resultMap.updateValue(newValue.map { (value: Expression) -> ResultMap in value.resultMap }, forKey: "expressions")
                  }
                }

                public var fragments: Fragments {
                  get {
                    return Fragments(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }

                public struct Fragments {
                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public var messageFragment: MessageFragment {
                    get {
                      return MessageFragment(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }
                }

                public struct Expression: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLTypeCase(
                        variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
                        default: [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        ]
                      )
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> Expression {
                    return Expression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                  }

                  public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> Expression {
                    return Expression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                  }

                  public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> Expression {
                    return Expression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var expressionFragment: ExpressionFragment {
                      get {
                        return ExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public var basicExpressionFragment: BasicExpressionFragment {
                      get {
                        return BasicExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }

                  public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                    get {
                      if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                      return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                    }
                    set {
                      guard let newValue = newValue else { return }
                      resultMap = newValue.resultMap
                    }
                  }

                  public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                        GraphQLField("text", type: .scalar(String.self)),
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                      self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var expressionUnaryType: EmbarkExpressionTypeUnary {
                      get {
                        return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                      }
                    }

                    public var text: String? {
                      get {
                        return resultMap["text"] as? String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "text")
                      }
                    }

                    public var fragments: Fragments {
                      get {
                        return Fragments(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public struct Fragments {
                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public var expressionFragment: ExpressionFragment {
                        get {
                          return ExpressionFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public var basicExpressionFragment: BasicExpressionFragment {
                        get {
                          return BasicExpressionFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }
                    }
                  }

                  public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                    get {
                      if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                      return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                    }
                    set {
                      guard let newValue = newValue else { return }
                      resultMap = newValue.resultMap
                    }
                  }

                  public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                        GraphQLField("key", type: .nonNull(.scalar(String.self))),
                        GraphQLField("value", type: .nonNull(.scalar(String.self))),
                        GraphQLField("text", type: .scalar(String.self)),
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                      self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var expressionBinaryType: EmbarkExpressionTypeBinary {
                      get {
                        return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                      }
                    }

                    public var key: String {
                      get {
                        return resultMap["key"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "key")
                      }
                    }

                    public var value: String {
                      get {
                        return resultMap["value"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "value")
                      }
                    }

                    public var text: String? {
                      get {
                        return resultMap["text"] as? String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "text")
                      }
                    }

                    public var fragments: Fragments {
                      get {
                        return Fragments(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public struct Fragments {
                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public var expressionFragment: ExpressionFragment {
                        get {
                          return ExpressionFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public var basicExpressionFragment: BasicExpressionFragment {
                        get {
                          return BasicExpressionFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }
                    }
                  }

                  public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
                    get {
                      if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
                      return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
                    }
                    set {
                      guard let newValue = newValue else { return }
                      resultMap = newValue.resultMap
                    }
                  }

                  public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
                        GraphQLField("text", type: .scalar(String.self)),
                        GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
                      self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var expressionMultipleType: EmbarkExpressionTypeMultiple {
                      get {
                        return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "expressionMultipleType")
                      }
                    }

                    public var text: String? {
                      get {
                        return resultMap["text"] as? String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "text")
                      }
                    }

                    public var subExpressions: [SubExpression] {
                      get {
                        return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
                      }
                      set {
                        resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
                      }
                    }

                    public var fragments: Fragments {
                      get {
                        return Fragments(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public struct Fragments {
                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public var expressionFragment: ExpressionFragment {
                        get {
                          return ExpressionFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public var basicExpressionFragment: BasicExpressionFragment {
                        get {
                          return BasicExpressionFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }
                    }

                    public struct SubExpression: GraphQLSelectionSet {
                      public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

                      public static var selections: [GraphQLSelection] {
                        return [
                          GraphQLTypeCase(
                            variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
                            default: [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            ]
                          )
                        ]
                      }

                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
                        return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                      }

                      public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
                        return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                      }

                      public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> SubExpression {
                        return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
                      }

                      public var __typename: String {
                        get {
                          return resultMap["__typename"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "__typename")
                        }
                      }

                      public var fragments: Fragments {
                        get {
                          return Fragments(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public struct Fragments {
                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public var basicExpressionFragment: BasicExpressionFragment {
                          get {
                            return BasicExpressionFragment(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }
                      }

                      public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                        get {
                          if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                          return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                        }
                        set {
                          guard let newValue = newValue else { return }
                          resultMap = newValue.resultMap
                        }
                      }

                      public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                            GraphQLField("text", type: .scalar(String.self)),
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                          self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var expressionUnaryType: EmbarkExpressionTypeUnary {
                          get {
                            return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                          }
                        }

                        public var text: String? {
                          get {
                            return resultMap["text"] as? String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "text")
                          }
                        }

                        public var fragments: Fragments {
                          get {
                            return Fragments(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }

                        public struct Fragments {
                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public var basicExpressionFragment: BasicExpressionFragment {
                            get {
                              return BasicExpressionFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }
                        }
                      }

                      public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                        get {
                          if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                          return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                        }
                        set {
                          guard let newValue = newValue else { return }
                          resultMap = newValue.resultMap
                        }
                      }

                      public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                            GraphQLField("key", type: .nonNull(.scalar(String.self))),
                            GraphQLField("value", type: .nonNull(.scalar(String.self))),
                            GraphQLField("text", type: .scalar(String.self)),
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                          self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var expressionBinaryType: EmbarkExpressionTypeBinary {
                          get {
                            return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                          }
                        }

                        public var key: String {
                          get {
                            return resultMap["key"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "key")
                          }
                        }

                        public var value: String {
                          get {
                            return resultMap["value"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "value")
                          }
                        }

                        public var text: String? {
                          get {
                            return resultMap["text"] as? String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "text")
                          }
                        }

                        public var fragments: Fragments {
                          get {
                            return Fragments(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }

                        public struct Fragments {
                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public var basicExpressionFragment: BasicExpressionFragment {
                            get {
                              return BasicExpressionFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }
                        }
                      }

                      public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
                        get {
                          if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
                          return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
                        }
                        set {
                          guard let newValue = newValue else { return }
                          resultMap = newValue.resultMap
                        }
                      }

                      public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
                            GraphQLField("text", type: .scalar(String.self)),
                            GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
                          self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var expressionMultipleType: EmbarkExpressionTypeMultiple {
                          get {
                            return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "expressionMultipleType")
                          }
                        }

                        public var text: String? {
                          get {
                            return resultMap["text"] as? String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "text")
                          }
                        }

                        public var subExpressions: [SubExpression] {
                          get {
                            return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
                          }
                          set {
                            resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
                          }
                        }

                        public var fragments: Fragments {
                          get {
                            return Fragments(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }

                        public struct Fragments {
                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public var basicExpressionFragment: BasicExpressionFragment {
                            get {
                              return BasicExpressionFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }
                        }

                        public struct SubExpression: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLTypeCase(
                                variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
                                default: [
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                ]
                              )
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
                            return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                          }

                          public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
                            return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                          }

                          public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> SubExpression {
                            return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var basicExpressionFragment: BasicExpressionFragment {
                              get {
                                return BasicExpressionFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }
                          }

                          public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                            get {
                              if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                              return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                            }
                            set {
                              guard let newValue = newValue else { return }
                              resultMap = newValue.resultMap
                            }
                          }

                          public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                            public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                            public static var selections: [GraphQLSelection] {
                              return [
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                                GraphQLField("text", type: .scalar(String.self)),
                              ]
                            }

                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                              self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                            }

                            public var __typename: String {
                              get {
                                return resultMap["__typename"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "__typename")
                              }
                            }

                            public var expressionUnaryType: EmbarkExpressionTypeUnary {
                              get {
                                return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                              }
                            }

                            public var text: String? {
                              get {
                                return resultMap["text"] as? String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "text")
                              }
                            }

                            public var fragments: Fragments {
                              get {
                                return Fragments(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public struct Fragments {
                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public var basicExpressionFragment: BasicExpressionFragment {
                                get {
                                  return BasicExpressionFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }
                            }
                          }

                          public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                            get {
                              if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                              return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                            }
                            set {
                              guard let newValue = newValue else { return }
                              resultMap = newValue.resultMap
                            }
                          }

                          public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                            public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                            public static var selections: [GraphQLSelection] {
                              return [
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                                GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                GraphQLField("value", type: .nonNull(.scalar(String.self))),
                                GraphQLField("text", type: .scalar(String.self)),
                              ]
                            }

                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                              self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                            }

                            public var __typename: String {
                              get {
                                return resultMap["__typename"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "__typename")
                              }
                            }

                            public var expressionBinaryType: EmbarkExpressionTypeBinary {
                              get {
                                return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                              }
                            }

                            public var key: String {
                              get {
                                return resultMap["key"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "key")
                              }
                            }

                            public var value: String {
                              get {
                                return resultMap["value"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "value")
                              }
                            }

                            public var text: String? {
                              get {
                                return resultMap["text"] as? String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "text")
                              }
                            }

                            public var fragments: Fragments {
                              get {
                                return Fragments(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public struct Fragments {
                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public var basicExpressionFragment: BasicExpressionFragment {
                                get {
                                  return BasicExpressionFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }
                            }
                          }

                          public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
                            get {
                              if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
                              return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
                            }
                            set {
                              guard let newValue = newValue else { return }
                              resultMap = newValue.resultMap
                            }
                          }

                          public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
                            public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

                            public static var selections: [GraphQLSelection] {
                              return [
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
                                GraphQLField("text", type: .scalar(String.self)),
                                GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
                              ]
                            }

                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
                              self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
                            }

                            public var __typename: String {
                              get {
                                return resultMap["__typename"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "__typename")
                              }
                            }

                            public var expressionMultipleType: EmbarkExpressionTypeMultiple {
                              get {
                                return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "expressionMultipleType")
                              }
                            }

                            public var text: String? {
                              get {
                                return resultMap["text"] as? String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "text")
                              }
                            }

                            public var subExpressions: [SubExpression] {
                              get {
                                return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
                              }
                              set {
                                resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
                              }
                            }

                            public var fragments: Fragments {
                              get {
                                return Fragments(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public struct Fragments {
                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public var basicExpressionFragment: BasicExpressionFragment {
                                get {
                                  return BasicExpressionFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }
                            }

                            public struct SubExpression: GraphQLSelectionSet {
                              public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

                              public static var selections: [GraphQLSelection] {
                                return [
                                  GraphQLTypeCase(
                                    variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections],
                                    default: [
                                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                    ]
                                  )
                                ]
                              }

                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public static func makeEmbarkExpressionMultiple() -> SubExpression {
                                return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple"])
                              }

                              public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
                                return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                              }

                              public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
                                return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                              }

                              public var __typename: String {
                                get {
                                  return resultMap["__typename"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "__typename")
                                }
                              }

                              public var fragments: Fragments {
                                get {
                                  return Fragments(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public struct Fragments {
                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public var basicExpressionFragment: BasicExpressionFragment {
                                  get {
                                    return BasicExpressionFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    resultMap += newValue.resultMap
                                  }
                                }
                              }

                              public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                                get {
                                  if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                                  return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                                }
                                set {
                                  guard let newValue = newValue else { return }
                                  resultMap = newValue.resultMap
                                }
                              }

                              public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                                public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                                public static var selections: [GraphQLSelection] {
                                  return [
                                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                    GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                                    GraphQLField("text", type: .scalar(String.self)),
                                  ]
                                }

                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                                  self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                                }

                                public var __typename: String {
                                  get {
                                    return resultMap["__typename"]! as! String
                                  }
                                  set {
                                    resultMap.updateValue(newValue, forKey: "__typename")
                                  }
                                }

                                public var expressionUnaryType: EmbarkExpressionTypeUnary {
                                  get {
                                    return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                                  }
                                  set {
                                    resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                                  }
                                }

                                public var text: String? {
                                  get {
                                    return resultMap["text"] as? String
                                  }
                                  set {
                                    resultMap.updateValue(newValue, forKey: "text")
                                  }
                                }

                                public var fragments: Fragments {
                                  get {
                                    return Fragments(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    resultMap += newValue.resultMap
                                  }
                                }

                                public struct Fragments {
                                  public private(set) var resultMap: ResultMap

                                  public init(unsafeResultMap: ResultMap) {
                                    self.resultMap = unsafeResultMap
                                  }

                                  public var basicExpressionFragment: BasicExpressionFragment {
                                    get {
                                      return BasicExpressionFragment(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      resultMap += newValue.resultMap
                                    }
                                  }
                                }
                              }

                              public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                                get {
                                  if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                                  return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                                }
                                set {
                                  guard let newValue = newValue else { return }
                                  resultMap = newValue.resultMap
                                }
                              }

                              public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                                public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                                public static var selections: [GraphQLSelection] {
                                  return [
                                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                    GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                                    GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                    GraphQLField("value", type: .nonNull(.scalar(String.self))),
                                    GraphQLField("text", type: .scalar(String.self)),
                                  ]
                                }

                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                                  self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                                }

                                public var __typename: String {
                                  get {
                                    return resultMap["__typename"]! as! String
                                  }
                                  set {
                                    resultMap.updateValue(newValue, forKey: "__typename")
                                  }
                                }

                                public var expressionBinaryType: EmbarkExpressionTypeBinary {
                                  get {
                                    return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                                  }
                                  set {
                                    resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                                  }
                                }

                                public var key: String {
                                  get {
                                    return resultMap["key"]! as! String
                                  }
                                  set {
                                    resultMap.updateValue(newValue, forKey: "key")
                                  }
                                }

                                public var value: String {
                                  get {
                                    return resultMap["value"]! as! String
                                  }
                                  set {
                                    resultMap.updateValue(newValue, forKey: "value")
                                  }
                                }

                                public var text: String? {
                                  get {
                                    return resultMap["text"] as? String
                                  }
                                  set {
                                    resultMap.updateValue(newValue, forKey: "text")
                                  }
                                }

                                public var fragments: Fragments {
                                  get {
                                    return Fragments(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    resultMap += newValue.resultMap
                                  }
                                }

                                public struct Fragments {
                                  public private(set) var resultMap: ResultMap

                                  public init(unsafeResultMap: ResultMap) {
                                    self.resultMap = unsafeResultMap
                                  }

                                  public var basicExpressionFragment: BasicExpressionFragment {
                                    get {
                                      return BasicExpressionFragment(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      resultMap += newValue.resultMap
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }

              public struct Each: GraphQLSelectionSet {
                public static let possibleTypes: [String] = ["EmbarkGroupedResponseEach"]

                public static var selections: [GraphQLSelection] {
                  return [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("key", type: .nonNull(.scalar(String.self))),
                    GraphQLField("content", type: .nonNull(.object(Content.selections))),
                  ]
                }

                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public init(key: String, content: Content) {
                  self.init(unsafeResultMap: ["__typename": "EmbarkGroupedResponseEach", "key": key, "content": content.resultMap])
                }

                public var __typename: String {
                  get {
                    return resultMap["__typename"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "__typename")
                  }
                }

                public var key: String {
                  get {
                    return resultMap["key"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "key")
                  }
                }

                public var content: Content {
                  get {
                    return Content(unsafeResultMap: resultMap["content"]! as! ResultMap)
                  }
                  set {
                    resultMap.updateValue(newValue.resultMap, forKey: "content")
                  }
                }

                public struct Content: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkMessage"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("text", type: .nonNull(.scalar(String.self))),
                      GraphQLField("expressions", type: .nonNull(.list(.nonNull(.object(Expression.selections))))),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(text: String, expressions: [Expression]) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkMessage", "text": text, "expressions": expressions.map { (value: Expression) -> ResultMap in value.resultMap }])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var text: String {
                    get {
                      return resultMap["text"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "text")
                    }
                  }

                  public var expressions: [Expression] {
                    get {
                      return (resultMap["expressions"] as! [ResultMap]).map { (value: ResultMap) -> Expression in Expression(unsafeResultMap: value) }
                    }
                    set {
                      resultMap.updateValue(newValue.map { (value: Expression) -> ResultMap in value.resultMap }, forKey: "expressions")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var messageFragment: MessageFragment {
                      get {
                        return MessageFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }

                  public struct Expression: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLTypeCase(
                          variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
                          default: [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          ]
                        )
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> Expression {
                      return Expression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                    }

                    public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> Expression {
                      return Expression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                    }

                    public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> Expression {
                      return Expression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var fragments: Fragments {
                      get {
                        return Fragments(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public struct Fragments {
                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public var expressionFragment: ExpressionFragment {
                        get {
                          return ExpressionFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public var basicExpressionFragment: BasicExpressionFragment {
                        get {
                          return BasicExpressionFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }
                    }

                    public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                      get {
                        if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                        return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                      }
                      set {
                        guard let newValue = newValue else { return }
                        resultMap = newValue.resultMap
                      }
                    }

                    public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                      public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                      public static var selections: [GraphQLSelection] {
                        return [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                          GraphQLField("text", type: .scalar(String.self)),
                        ]
                      }

                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                        self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                      }

                      public var __typename: String {
                        get {
                          return resultMap["__typename"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "__typename")
                        }
                      }

                      public var expressionUnaryType: EmbarkExpressionTypeUnary {
                        get {
                          return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                        }
                      }

                      public var text: String? {
                        get {
                          return resultMap["text"] as? String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "text")
                        }
                      }

                      public var fragments: Fragments {
                        get {
                          return Fragments(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public struct Fragments {
                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public var expressionFragment: ExpressionFragment {
                          get {
                            return ExpressionFragment(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }

                        public var basicExpressionFragment: BasicExpressionFragment {
                          get {
                            return BasicExpressionFragment(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }
                      }
                    }

                    public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                      get {
                        if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                        return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                      }
                      set {
                        guard let newValue = newValue else { return }
                        resultMap = newValue.resultMap
                      }
                    }

                    public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                      public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                      public static var selections: [GraphQLSelection] {
                        return [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                          GraphQLField("key", type: .nonNull(.scalar(String.self))),
                          GraphQLField("value", type: .nonNull(.scalar(String.self))),
                          GraphQLField("text", type: .scalar(String.self)),
                        ]
                      }

                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                        self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                      }

                      public var __typename: String {
                        get {
                          return resultMap["__typename"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "__typename")
                        }
                      }

                      public var expressionBinaryType: EmbarkExpressionTypeBinary {
                        get {
                          return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                        }
                      }

                      public var key: String {
                        get {
                          return resultMap["key"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "key")
                        }
                      }

                      public var value: String {
                        get {
                          return resultMap["value"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "value")
                        }
                      }

                      public var text: String? {
                        get {
                          return resultMap["text"] as? String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "text")
                        }
                      }

                      public var fragments: Fragments {
                        get {
                          return Fragments(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public struct Fragments {
                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public var expressionFragment: ExpressionFragment {
                          get {
                            return ExpressionFragment(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }

                        public var basicExpressionFragment: BasicExpressionFragment {
                          get {
                            return BasicExpressionFragment(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }
                      }
                    }

                    public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
                      get {
                        if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
                        return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
                      }
                      set {
                        guard let newValue = newValue else { return }
                        resultMap = newValue.resultMap
                      }
                    }

                    public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
                      public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

                      public static var selections: [GraphQLSelection] {
                        return [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
                          GraphQLField("text", type: .scalar(String.self)),
                          GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
                        ]
                      }

                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
                        self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
                      }

                      public var __typename: String {
                        get {
                          return resultMap["__typename"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "__typename")
                        }
                      }

                      public var expressionMultipleType: EmbarkExpressionTypeMultiple {
                        get {
                          return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "expressionMultipleType")
                        }
                      }

                      public var text: String? {
                        get {
                          return resultMap["text"] as? String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "text")
                        }
                      }

                      public var subExpressions: [SubExpression] {
                        get {
                          return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
                        }
                        set {
                          resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
                        }
                      }

                      public var fragments: Fragments {
                        get {
                          return Fragments(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public struct Fragments {
                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public var expressionFragment: ExpressionFragment {
                          get {
                            return ExpressionFragment(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }

                        public var basicExpressionFragment: BasicExpressionFragment {
                          get {
                            return BasicExpressionFragment(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }
                      }

                      public struct SubExpression: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLTypeCase(
                              variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
                              default: [
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              ]
                            )
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
                          return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                        }

                        public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
                          return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                        }

                        public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> SubExpression {
                          return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var fragments: Fragments {
                          get {
                            return Fragments(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }

                        public struct Fragments {
                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public var basicExpressionFragment: BasicExpressionFragment {
                            get {
                              return BasicExpressionFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }
                        }

                        public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                          get {
                            if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                            return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                          }
                          set {
                            guard let newValue = newValue else { return }
                            resultMap = newValue.resultMap
                          }
                        }

                        public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                              GraphQLField("text", type: .scalar(String.self)),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var expressionUnaryType: EmbarkExpressionTypeUnary {
                            get {
                              return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                            }
                          }

                          public var text: String? {
                            get {
                              return resultMap["text"] as? String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "text")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var basicExpressionFragment: BasicExpressionFragment {
                              get {
                                return BasicExpressionFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }
                          }
                        }

                        public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                          get {
                            if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                            return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                          }
                          set {
                            guard let newValue = newValue else { return }
                            resultMap = newValue.resultMap
                          }
                        }

                        public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                              GraphQLField("key", type: .nonNull(.scalar(String.self))),
                              GraphQLField("value", type: .nonNull(.scalar(String.self))),
                              GraphQLField("text", type: .scalar(String.self)),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var expressionBinaryType: EmbarkExpressionTypeBinary {
                            get {
                              return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                            }
                          }

                          public var key: String {
                            get {
                              return resultMap["key"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "key")
                            }
                          }

                          public var value: String {
                            get {
                              return resultMap["value"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "value")
                            }
                          }

                          public var text: String? {
                            get {
                              return resultMap["text"] as? String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "text")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var basicExpressionFragment: BasicExpressionFragment {
                              get {
                                return BasicExpressionFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }
                          }
                        }

                        public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
                          get {
                            if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
                            return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
                          }
                          set {
                            guard let newValue = newValue else { return }
                            resultMap = newValue.resultMap
                          }
                        }

                        public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
                              GraphQLField("text", type: .scalar(String.self)),
                              GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var expressionMultipleType: EmbarkExpressionTypeMultiple {
                            get {
                              return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "expressionMultipleType")
                            }
                          }

                          public var text: String? {
                            get {
                              return resultMap["text"] as? String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "text")
                            }
                          }

                          public var subExpressions: [SubExpression] {
                            get {
                              return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
                            }
                            set {
                              resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var basicExpressionFragment: BasicExpressionFragment {
                              get {
                                return BasicExpressionFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }
                          }

                          public struct SubExpression: GraphQLSelectionSet {
                            public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

                            public static var selections: [GraphQLSelection] {
                              return [
                                GraphQLTypeCase(
                                  variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
                                  default: [
                                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  ]
                                )
                              ]
                            }

                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
                              return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                            }

                            public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
                              return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                            }

                            public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> SubExpression {
                              return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
                            }

                            public var __typename: String {
                              get {
                                return resultMap["__typename"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "__typename")
                              }
                            }

                            public var fragments: Fragments {
                              get {
                                return Fragments(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public struct Fragments {
                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public var basicExpressionFragment: BasicExpressionFragment {
                                get {
                                  return BasicExpressionFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }
                            }

                            public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                              get {
                                if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                                return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap = newValue.resultMap
                              }
                            }

                            public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                              public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                              public static var selections: [GraphQLSelection] {
                                return [
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                                  GraphQLField("text", type: .scalar(String.self)),
                                ]
                              }

                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                                self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                              }

                              public var __typename: String {
                                get {
                                  return resultMap["__typename"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "__typename")
                                }
                              }

                              public var expressionUnaryType: EmbarkExpressionTypeUnary {
                                get {
                                  return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                                }
                              }

                              public var text: String? {
                                get {
                                  return resultMap["text"] as? String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "text")
                                }
                              }

                              public var fragments: Fragments {
                                get {
                                  return Fragments(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public struct Fragments {
                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public var basicExpressionFragment: BasicExpressionFragment {
                                  get {
                                    return BasicExpressionFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    resultMap += newValue.resultMap
                                  }
                                }
                              }
                            }

                            public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                              get {
                                if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                                return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap = newValue.resultMap
                              }
                            }

                            public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                              public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                              public static var selections: [GraphQLSelection] {
                                return [
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                                  GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("value", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("text", type: .scalar(String.self)),
                                ]
                              }

                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                                self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                              }

                              public var __typename: String {
                                get {
                                  return resultMap["__typename"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "__typename")
                                }
                              }

                              public var expressionBinaryType: EmbarkExpressionTypeBinary {
                                get {
                                  return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                                }
                              }

                              public var key: String {
                                get {
                                  return resultMap["key"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "key")
                                }
                              }

                              public var value: String {
                                get {
                                  return resultMap["value"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "value")
                                }
                              }

                              public var text: String? {
                                get {
                                  return resultMap["text"] as? String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "text")
                                }
                              }

                              public var fragments: Fragments {
                                get {
                                  return Fragments(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public struct Fragments {
                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public var basicExpressionFragment: BasicExpressionFragment {
                                  get {
                                    return BasicExpressionFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    resultMap += newValue.resultMap
                                  }
                                }
                              }
                            }

                            public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
                              get {
                                if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
                                return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap = newValue.resultMap
                              }
                            }

                            public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
                              public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

                              public static var selections: [GraphQLSelection] {
                                return [
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
                                  GraphQLField("text", type: .scalar(String.self)),
                                  GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
                                ]
                              }

                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
                                self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
                              }

                              public var __typename: String {
                                get {
                                  return resultMap["__typename"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "__typename")
                                }
                              }

                              public var expressionMultipleType: EmbarkExpressionTypeMultiple {
                                get {
                                  return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "expressionMultipleType")
                                }
                              }

                              public var text: String? {
                                get {
                                  return resultMap["text"] as? String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "text")
                                }
                              }

                              public var subExpressions: [SubExpression] {
                                get {
                                  return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
                                }
                                set {
                                  resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
                                }
                              }

                              public var fragments: Fragments {
                                get {
                                  return Fragments(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public struct Fragments {
                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public var basicExpressionFragment: BasicExpressionFragment {
                                  get {
                                    return BasicExpressionFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    resultMap += newValue.resultMap
                                  }
                                }
                              }

                              public struct SubExpression: GraphQLSelectionSet {
                                public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

                                public static var selections: [GraphQLSelection] {
                                  return [
                                    GraphQLTypeCase(
                                      variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections],
                                      default: [
                                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                      ]
                                    )
                                  ]
                                }

                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public static func makeEmbarkExpressionMultiple() -> SubExpression {
                                  return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple"])
                                }

                                public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
                                  return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                                }

                                public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
                                  return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                                }

                                public var __typename: String {
                                  get {
                                    return resultMap["__typename"]! as! String
                                  }
                                  set {
                                    resultMap.updateValue(newValue, forKey: "__typename")
                                  }
                                }

                                public var fragments: Fragments {
                                  get {
                                    return Fragments(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    resultMap += newValue.resultMap
                                  }
                                }

                                public struct Fragments {
                                  public private(set) var resultMap: ResultMap

                                  public init(unsafeResultMap: ResultMap) {
                                    self.resultMap = unsafeResultMap
                                  }

                                  public var basicExpressionFragment: BasicExpressionFragment {
                                    get {
                                      return BasicExpressionFragment(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      resultMap += newValue.resultMap
                                    }
                                  }
                                }

                                public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                                  get {
                                    if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                                    return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap = newValue.resultMap
                                  }
                                }

                                public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                                  public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                                  public static var selections: [GraphQLSelection] {
                                    return [
                                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                                      GraphQLField("text", type: .scalar(String.self)),
                                    ]
                                  }

                                  public private(set) var resultMap: ResultMap

                                  public init(unsafeResultMap: ResultMap) {
                                    self.resultMap = unsafeResultMap
                                  }

                                  public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                                    self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                                  }

                                  public var __typename: String {
                                    get {
                                      return resultMap["__typename"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "__typename")
                                    }
                                  }

                                  public var expressionUnaryType: EmbarkExpressionTypeUnary {
                                    get {
                                      return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                                    }
                                  }

                                  public var text: String? {
                                    get {
                                      return resultMap["text"] as? String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "text")
                                    }
                                  }

                                  public var fragments: Fragments {
                                    get {
                                      return Fragments(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      resultMap += newValue.resultMap
                                    }
                                  }

                                  public struct Fragments {
                                    public private(set) var resultMap: ResultMap

                                    public init(unsafeResultMap: ResultMap) {
                                      self.resultMap = unsafeResultMap
                                    }

                                    public var basicExpressionFragment: BasicExpressionFragment {
                                      get {
                                        return BasicExpressionFragment(unsafeResultMap: resultMap)
                                      }
                                      set {
                                        resultMap += newValue.resultMap
                                      }
                                    }
                                  }
                                }

                                public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                                  get {
                                    if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                                    return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap = newValue.resultMap
                                  }
                                }

                                public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                                  public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                                  public static var selections: [GraphQLSelection] {
                                    return [
                                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                                      GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("value", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("text", type: .scalar(String.self)),
                                    ]
                                  }

                                  public private(set) var resultMap: ResultMap

                                  public init(unsafeResultMap: ResultMap) {
                                    self.resultMap = unsafeResultMap
                                  }

                                  public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                                    self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                                  }

                                  public var __typename: String {
                                    get {
                                      return resultMap["__typename"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "__typename")
                                    }
                                  }

                                  public var expressionBinaryType: EmbarkExpressionTypeBinary {
                                    get {
                                      return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                                    }
                                  }

                                  public var key: String {
                                    get {
                                      return resultMap["key"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "key")
                                    }
                                  }

                                  public var value: String {
                                    get {
                                      return resultMap["value"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "value")
                                    }
                                  }

                                  public var text: String? {
                                    get {
                                      return resultMap["text"] as? String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "text")
                                    }
                                  }

                                  public var fragments: Fragments {
                                    get {
                                      return Fragments(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      resultMap += newValue.resultMap
                                    }
                                  }

                                  public struct Fragments {
                                    public private(set) var resultMap: ResultMap

                                    public init(unsafeResultMap: ResultMap) {
                                      self.resultMap = unsafeResultMap
                                    }

                                    public var basicExpressionFragment: BasicExpressionFragment {
                                      get {
                                        return BasicExpressionFragment(unsafeResultMap: resultMap)
                                      }
                                      set {
                                        resultMap += newValue.resultMap
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }

              public struct Title: GraphQLSelectionSet {
                public static let possibleTypes: [String] = ["EmbarkResponseExpression"]

                public static var selections: [GraphQLSelection] {
                  return [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("text", type: .nonNull(.scalar(String.self))),
                  ]
                }

                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public init(text: String) {
                  self.init(unsafeResultMap: ["__typename": "EmbarkResponseExpression", "text": text])
                }

                public var __typename: String {
                  get {
                    return resultMap["__typename"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "__typename")
                  }
                }

                public var text: String {
                  get {
                    return resultMap["text"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "text")
                  }
                }
              }
            }

            public var asEmbarkResponseExpression: AsEmbarkResponseExpression? {
              get {
                if !AsEmbarkResponseExpression.possibleTypes.contains(__typename) { return nil }
                return AsEmbarkResponseExpression(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap = newValue.resultMap
              }
            }

            public struct AsEmbarkResponseExpression: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkResponseExpression"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("text", type: .nonNull(.scalar(String.self))),
                  GraphQLField("expressions", type: .nonNull(.list(.nonNull(.object(Expression.selections))))),
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public init(text: String, expressions: [Expression]) {
                self.init(unsafeResultMap: ["__typename": "EmbarkResponseExpression", "text": text, "expressions": expressions.map { (value: Expression) -> ResultMap in value.resultMap }])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var text: String {
                get {
                  return resultMap["text"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "text")
                }
              }

              public var expressions: [Expression] {
                get {
                  return (resultMap["expressions"] as! [ResultMap]).map { (value: ResultMap) -> Expression in Expression(unsafeResultMap: value) }
                }
                set {
                  resultMap.updateValue(newValue.map { (value: Expression) -> ResultMap in value.resultMap }, forKey: "expressions")
                }
              }

              public var fragments: Fragments {
                get {
                  return Fragments(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public struct Fragments {
                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public var responseFragment: ResponseFragment {
                  get {
                    return ResponseFragment(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }
              }

              public struct Expression: GraphQLSelectionSet {
                public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

                public static var selections: [GraphQLSelection] {
                  return [
                    GraphQLTypeCase(
                      variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
                      default: [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      ]
                    )
                  ]
                }

                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> Expression {
                  return Expression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                }

                public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> Expression {
                  return Expression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                }

                public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> Expression {
                  return Expression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
                }

                public var __typename: String {
                  get {
                    return resultMap["__typename"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "__typename")
                  }
                }

                public var fragments: Fragments {
                  get {
                    return Fragments(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }

                public struct Fragments {
                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public var expressionFragment: ExpressionFragment {
                    get {
                      return ExpressionFragment(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public var basicExpressionFragment: BasicExpressionFragment {
                    get {
                      return BasicExpressionFragment(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }
                }

                public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                  get {
                    if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                    return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                  }
                  set {
                    guard let newValue = newValue else { return }
                    resultMap = newValue.resultMap
                  }
                }

                public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                      GraphQLField("text", type: .scalar(String.self)),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var expressionUnaryType: EmbarkExpressionTypeUnary {
                    get {
                      return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                    }
                  }

                  public var text: String? {
                    get {
                      return resultMap["text"] as? String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "text")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var expressionFragment: ExpressionFragment {
                      get {
                        return ExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public var basicExpressionFragment: BasicExpressionFragment {
                      get {
                        return BasicExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }
                }

                public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                  get {
                    if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                    return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                  }
                  set {
                    guard let newValue = newValue else { return }
                    resultMap = newValue.resultMap
                  }
                }

                public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                      GraphQLField("key", type: .nonNull(.scalar(String.self))),
                      GraphQLField("value", type: .nonNull(.scalar(String.self))),
                      GraphQLField("text", type: .scalar(String.self)),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var expressionBinaryType: EmbarkExpressionTypeBinary {
                    get {
                      return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                    }
                  }

                  public var key: String {
                    get {
                      return resultMap["key"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "key")
                    }
                  }

                  public var value: String {
                    get {
                      return resultMap["value"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "value")
                    }
                  }

                  public var text: String? {
                    get {
                      return resultMap["text"] as? String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "text")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var expressionFragment: ExpressionFragment {
                      get {
                        return ExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public var basicExpressionFragment: BasicExpressionFragment {
                      get {
                        return BasicExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }
                }

                public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
                  get {
                    if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
                    return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
                  }
                  set {
                    guard let newValue = newValue else { return }
                    resultMap = newValue.resultMap
                  }
                }

                public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
                      GraphQLField("text", type: .scalar(String.self)),
                      GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var expressionMultipleType: EmbarkExpressionTypeMultiple {
                    get {
                      return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "expressionMultipleType")
                    }
                  }

                  public var text: String? {
                    get {
                      return resultMap["text"] as? String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "text")
                    }
                  }

                  public var subExpressions: [SubExpression] {
                    get {
                      return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
                    }
                    set {
                      resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var expressionFragment: ExpressionFragment {
                      get {
                        return ExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public var basicExpressionFragment: BasicExpressionFragment {
                      get {
                        return BasicExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }

                  public struct SubExpression: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLTypeCase(
                          variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
                          default: [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          ]
                        )
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
                      return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                    }

                    public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
                      return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                    }

                    public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> SubExpression {
                      return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var fragments: Fragments {
                      get {
                        return Fragments(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public struct Fragments {
                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public var basicExpressionFragment: BasicExpressionFragment {
                        get {
                          return BasicExpressionFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }
                    }

                    public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                      get {
                        if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                        return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                      }
                      set {
                        guard let newValue = newValue else { return }
                        resultMap = newValue.resultMap
                      }
                    }

                    public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                      public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                      public static var selections: [GraphQLSelection] {
                        return [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                          GraphQLField("text", type: .scalar(String.self)),
                        ]
                      }

                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                        self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                      }

                      public var __typename: String {
                        get {
                          return resultMap["__typename"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "__typename")
                        }
                      }

                      public var expressionUnaryType: EmbarkExpressionTypeUnary {
                        get {
                          return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                        }
                      }

                      public var text: String? {
                        get {
                          return resultMap["text"] as? String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "text")
                        }
                      }

                      public var fragments: Fragments {
                        get {
                          return Fragments(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public struct Fragments {
                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public var basicExpressionFragment: BasicExpressionFragment {
                          get {
                            return BasicExpressionFragment(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }
                      }
                    }

                    public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                      get {
                        if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                        return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                      }
                      set {
                        guard let newValue = newValue else { return }
                        resultMap = newValue.resultMap
                      }
                    }

                    public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                      public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                      public static var selections: [GraphQLSelection] {
                        return [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                          GraphQLField("key", type: .nonNull(.scalar(String.self))),
                          GraphQLField("value", type: .nonNull(.scalar(String.self))),
                          GraphQLField("text", type: .scalar(String.self)),
                        ]
                      }

                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                        self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                      }

                      public var __typename: String {
                        get {
                          return resultMap["__typename"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "__typename")
                        }
                      }

                      public var expressionBinaryType: EmbarkExpressionTypeBinary {
                        get {
                          return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                        }
                      }

                      public var key: String {
                        get {
                          return resultMap["key"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "key")
                        }
                      }

                      public var value: String {
                        get {
                          return resultMap["value"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "value")
                        }
                      }

                      public var text: String? {
                        get {
                          return resultMap["text"] as? String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "text")
                        }
                      }

                      public var fragments: Fragments {
                        get {
                          return Fragments(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public struct Fragments {
                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public var basicExpressionFragment: BasicExpressionFragment {
                          get {
                            return BasicExpressionFragment(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }
                      }
                    }

                    public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
                      get {
                        if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
                        return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
                      }
                      set {
                        guard let newValue = newValue else { return }
                        resultMap = newValue.resultMap
                      }
                    }

                    public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
                      public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

                      public static var selections: [GraphQLSelection] {
                        return [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
                          GraphQLField("text", type: .scalar(String.self)),
                          GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
                        ]
                      }

                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
                        self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
                      }

                      public var __typename: String {
                        get {
                          return resultMap["__typename"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "__typename")
                        }
                      }

                      public var expressionMultipleType: EmbarkExpressionTypeMultiple {
                        get {
                          return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "expressionMultipleType")
                        }
                      }

                      public var text: String? {
                        get {
                          return resultMap["text"] as? String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "text")
                        }
                      }

                      public var subExpressions: [SubExpression] {
                        get {
                          return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
                        }
                        set {
                          resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
                        }
                      }

                      public var fragments: Fragments {
                        get {
                          return Fragments(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public struct Fragments {
                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public var basicExpressionFragment: BasicExpressionFragment {
                          get {
                            return BasicExpressionFragment(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }
                      }

                      public struct SubExpression: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLTypeCase(
                              variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
                              default: [
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              ]
                            )
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
                          return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                        }

                        public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
                          return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                        }

                        public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> SubExpression {
                          return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var fragments: Fragments {
                          get {
                            return Fragments(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }

                        public struct Fragments {
                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public var basicExpressionFragment: BasicExpressionFragment {
                            get {
                              return BasicExpressionFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }
                        }

                        public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                          get {
                            if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                            return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                          }
                          set {
                            guard let newValue = newValue else { return }
                            resultMap = newValue.resultMap
                          }
                        }

                        public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                              GraphQLField("text", type: .scalar(String.self)),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var expressionUnaryType: EmbarkExpressionTypeUnary {
                            get {
                              return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                            }
                          }

                          public var text: String? {
                            get {
                              return resultMap["text"] as? String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "text")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var basicExpressionFragment: BasicExpressionFragment {
                              get {
                                return BasicExpressionFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }
                          }
                        }

                        public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                          get {
                            if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                            return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                          }
                          set {
                            guard let newValue = newValue else { return }
                            resultMap = newValue.resultMap
                          }
                        }

                        public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                              GraphQLField("key", type: .nonNull(.scalar(String.self))),
                              GraphQLField("value", type: .nonNull(.scalar(String.self))),
                              GraphQLField("text", type: .scalar(String.self)),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var expressionBinaryType: EmbarkExpressionTypeBinary {
                            get {
                              return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                            }
                          }

                          public var key: String {
                            get {
                              return resultMap["key"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "key")
                            }
                          }

                          public var value: String {
                            get {
                              return resultMap["value"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "value")
                            }
                          }

                          public var text: String? {
                            get {
                              return resultMap["text"] as? String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "text")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var basicExpressionFragment: BasicExpressionFragment {
                              get {
                                return BasicExpressionFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }
                          }
                        }

                        public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
                          get {
                            if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
                            return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
                          }
                          set {
                            guard let newValue = newValue else { return }
                            resultMap = newValue.resultMap
                          }
                        }

                        public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
                              GraphQLField("text", type: .scalar(String.self)),
                              GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var expressionMultipleType: EmbarkExpressionTypeMultiple {
                            get {
                              return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "expressionMultipleType")
                            }
                          }

                          public var text: String? {
                            get {
                              return resultMap["text"] as? String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "text")
                            }
                          }

                          public var subExpressions: [SubExpression] {
                            get {
                              return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
                            }
                            set {
                              resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var basicExpressionFragment: BasicExpressionFragment {
                              get {
                                return BasicExpressionFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }
                          }

                          public struct SubExpression: GraphQLSelectionSet {
                            public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

                            public static var selections: [GraphQLSelection] {
                              return [
                                GraphQLTypeCase(
                                  variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections],
                                  default: [
                                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  ]
                                )
                              ]
                            }

                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public static func makeEmbarkExpressionMultiple() -> SubExpression {
                              return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple"])
                            }

                            public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
                              return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                            }

                            public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
                              return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                            }

                            public var __typename: String {
                              get {
                                return resultMap["__typename"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "__typename")
                              }
                            }

                            public var fragments: Fragments {
                              get {
                                return Fragments(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public struct Fragments {
                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public var basicExpressionFragment: BasicExpressionFragment {
                                get {
                                  return BasicExpressionFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }
                            }

                            public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                              get {
                                if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                                return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap = newValue.resultMap
                              }
                            }

                            public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                              public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                              public static var selections: [GraphQLSelection] {
                                return [
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                                  GraphQLField("text", type: .scalar(String.self)),
                                ]
                              }

                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                                self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                              }

                              public var __typename: String {
                                get {
                                  return resultMap["__typename"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "__typename")
                                }
                              }

                              public var expressionUnaryType: EmbarkExpressionTypeUnary {
                                get {
                                  return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                                }
                              }

                              public var text: String? {
                                get {
                                  return resultMap["text"] as? String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "text")
                                }
                              }

                              public var fragments: Fragments {
                                get {
                                  return Fragments(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public struct Fragments {
                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public var basicExpressionFragment: BasicExpressionFragment {
                                  get {
                                    return BasicExpressionFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    resultMap += newValue.resultMap
                                  }
                                }
                              }
                            }

                            public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                              get {
                                if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                                return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap = newValue.resultMap
                              }
                            }

                            public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                              public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                              public static var selections: [GraphQLSelection] {
                                return [
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                                  GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("value", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("text", type: .scalar(String.self)),
                                ]
                              }

                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                                self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                              }

                              public var __typename: String {
                                get {
                                  return resultMap["__typename"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "__typename")
                                }
                              }

                              public var expressionBinaryType: EmbarkExpressionTypeBinary {
                                get {
                                  return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                                }
                              }

                              public var key: String {
                                get {
                                  return resultMap["key"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "key")
                                }
                              }

                              public var value: String {
                                get {
                                  return resultMap["value"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "value")
                                }
                              }

                              public var text: String? {
                                get {
                                  return resultMap["text"] as? String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "text")
                                }
                              }

                              public var fragments: Fragments {
                                get {
                                  return Fragments(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public struct Fragments {
                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public var basicExpressionFragment: BasicExpressionFragment {
                                  get {
                                    return BasicExpressionFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    resultMap += newValue.resultMap
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }

          public struct Message: GraphQLSelectionSet {
            public static let possibleTypes: [String] = ["EmbarkMessage"]

            public static var selections: [GraphQLSelection] {
              return [
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("text", type: .nonNull(.scalar(String.self))),
                GraphQLField("expressions", type: .nonNull(.list(.nonNull(.object(Expression.selections))))),
              ]
            }

            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public init(text: String, expressions: [Expression]) {
              self.init(unsafeResultMap: ["__typename": "EmbarkMessage", "text": text, "expressions": expressions.map { (value: Expression) -> ResultMap in value.resultMap }])
            }

            public var __typename: String {
              get {
                return resultMap["__typename"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "__typename")
              }
            }

            public var text: String {
              get {
                return resultMap["text"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "text")
              }
            }

            public var expressions: [Expression] {
              get {
                return (resultMap["expressions"] as! [ResultMap]).map { (value: ResultMap) -> Expression in Expression(unsafeResultMap: value) }
              }
              set {
                resultMap.updateValue(newValue.map { (value: Expression) -> ResultMap in value.resultMap }, forKey: "expressions")
              }
            }

            public var fragments: Fragments {
              get {
                return Fragments(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }

            public struct Fragments {
              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public var messageFragment: MessageFragment {
                get {
                  return MessageFragment(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }
            }

            public struct Expression: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLTypeCase(
                    variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
                    default: [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    ]
                  )
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> Expression {
                return Expression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
              }

              public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> Expression {
                return Expression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
              }

              public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> Expression {
                return Expression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var fragments: Fragments {
                get {
                  return Fragments(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public struct Fragments {
                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public var expressionFragment: ExpressionFragment {
                  get {
                    return ExpressionFragment(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }

                public var basicExpressionFragment: BasicExpressionFragment {
                  get {
                    return BasicExpressionFragment(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }
              }

              public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                get {
                  if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                  return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                }
                set {
                  guard let newValue = newValue else { return }
                  resultMap = newValue.resultMap
                }
              }

              public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                public static var selections: [GraphQLSelection] {
                  return [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                    GraphQLField("text", type: .scalar(String.self)),
                  ]
                }

                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                  self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                }

                public var __typename: String {
                  get {
                    return resultMap["__typename"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "__typename")
                  }
                }

                public var expressionUnaryType: EmbarkExpressionTypeUnary {
                  get {
                    return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                  }
                }

                public var text: String? {
                  get {
                    return resultMap["text"] as? String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "text")
                  }
                }

                public var fragments: Fragments {
                  get {
                    return Fragments(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }

                public struct Fragments {
                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public var expressionFragment: ExpressionFragment {
                    get {
                      return ExpressionFragment(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public var basicExpressionFragment: BasicExpressionFragment {
                    get {
                      return BasicExpressionFragment(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }
                }
              }

              public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                get {
                  if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                  return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                }
                set {
                  guard let newValue = newValue else { return }
                  resultMap = newValue.resultMap
                }
              }

              public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                public static var selections: [GraphQLSelection] {
                  return [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                    GraphQLField("key", type: .nonNull(.scalar(String.self))),
                    GraphQLField("value", type: .nonNull(.scalar(String.self))),
                    GraphQLField("text", type: .scalar(String.self)),
                  ]
                }

                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                  self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                }

                public var __typename: String {
                  get {
                    return resultMap["__typename"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "__typename")
                  }
                }

                public var expressionBinaryType: EmbarkExpressionTypeBinary {
                  get {
                    return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                  }
                }

                public var key: String {
                  get {
                    return resultMap["key"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "key")
                  }
                }

                public var value: String {
                  get {
                    return resultMap["value"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "value")
                  }
                }

                public var text: String? {
                  get {
                    return resultMap["text"] as? String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "text")
                  }
                }

                public var fragments: Fragments {
                  get {
                    return Fragments(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }

                public struct Fragments {
                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public var expressionFragment: ExpressionFragment {
                    get {
                      return ExpressionFragment(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public var basicExpressionFragment: BasicExpressionFragment {
                    get {
                      return BasicExpressionFragment(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }
                }
              }

              public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
                get {
                  if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
                  return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
                }
                set {
                  guard let newValue = newValue else { return }
                  resultMap = newValue.resultMap
                }
              }

              public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
                public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

                public static var selections: [GraphQLSelection] {
                  return [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
                    GraphQLField("text", type: .scalar(String.self)),
                    GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
                  ]
                }

                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
                  self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
                }

                public var __typename: String {
                  get {
                    return resultMap["__typename"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "__typename")
                  }
                }

                public var expressionMultipleType: EmbarkExpressionTypeMultiple {
                  get {
                    return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "expressionMultipleType")
                  }
                }

                public var text: String? {
                  get {
                    return resultMap["text"] as? String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "text")
                  }
                }

                public var subExpressions: [SubExpression] {
                  get {
                    return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
                  }
                  set {
                    resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
                  }
                }

                public var fragments: Fragments {
                  get {
                    return Fragments(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }

                public struct Fragments {
                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public var expressionFragment: ExpressionFragment {
                    get {
                      return ExpressionFragment(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public var basicExpressionFragment: BasicExpressionFragment {
                    get {
                      return BasicExpressionFragment(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }
                }

                public struct SubExpression: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLTypeCase(
                        variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
                        default: [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        ]
                      )
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
                    return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                  }

                  public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
                    return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                  }

                  public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> SubExpression {
                    return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var basicExpressionFragment: BasicExpressionFragment {
                      get {
                        return BasicExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }

                  public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                    get {
                      if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                      return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                    }
                    set {
                      guard let newValue = newValue else { return }
                      resultMap = newValue.resultMap
                    }
                  }

                  public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                        GraphQLField("text", type: .scalar(String.self)),
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                      self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var expressionUnaryType: EmbarkExpressionTypeUnary {
                      get {
                        return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                      }
                    }

                    public var text: String? {
                      get {
                        return resultMap["text"] as? String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "text")
                      }
                    }

                    public var fragments: Fragments {
                      get {
                        return Fragments(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public struct Fragments {
                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public var basicExpressionFragment: BasicExpressionFragment {
                        get {
                          return BasicExpressionFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }
                    }
                  }

                  public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                    get {
                      if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                      return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                    }
                    set {
                      guard let newValue = newValue else { return }
                      resultMap = newValue.resultMap
                    }
                  }

                  public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                        GraphQLField("key", type: .nonNull(.scalar(String.self))),
                        GraphQLField("value", type: .nonNull(.scalar(String.self))),
                        GraphQLField("text", type: .scalar(String.self)),
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                      self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var expressionBinaryType: EmbarkExpressionTypeBinary {
                      get {
                        return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                      }
                    }

                    public var key: String {
                      get {
                        return resultMap["key"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "key")
                      }
                    }

                    public var value: String {
                      get {
                        return resultMap["value"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "value")
                      }
                    }

                    public var text: String? {
                      get {
                        return resultMap["text"] as? String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "text")
                      }
                    }

                    public var fragments: Fragments {
                      get {
                        return Fragments(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public struct Fragments {
                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public var basicExpressionFragment: BasicExpressionFragment {
                        get {
                          return BasicExpressionFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }
                    }
                  }

                  public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
                    get {
                      if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
                      return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
                    }
                    set {
                      guard let newValue = newValue else { return }
                      resultMap = newValue.resultMap
                    }
                  }

                  public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
                        GraphQLField("text", type: .scalar(String.self)),
                        GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
                      self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var expressionMultipleType: EmbarkExpressionTypeMultiple {
                      get {
                        return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "expressionMultipleType")
                      }
                    }

                    public var text: String? {
                      get {
                        return resultMap["text"] as? String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "text")
                      }
                    }

                    public var subExpressions: [SubExpression] {
                      get {
                        return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
                      }
                      set {
                        resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
                      }
                    }

                    public var fragments: Fragments {
                      get {
                        return Fragments(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public struct Fragments {
                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public var basicExpressionFragment: BasicExpressionFragment {
                        get {
                          return BasicExpressionFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }
                    }

                    public struct SubExpression: GraphQLSelectionSet {
                      public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

                      public static var selections: [GraphQLSelection] {
                        return [
                          GraphQLTypeCase(
                            variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
                            default: [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            ]
                          )
                        ]
                      }

                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
                        return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                      }

                      public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
                        return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                      }

                      public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> SubExpression {
                        return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
                      }

                      public var __typename: String {
                        get {
                          return resultMap["__typename"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "__typename")
                        }
                      }

                      public var fragments: Fragments {
                        get {
                          return Fragments(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public struct Fragments {
                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public var basicExpressionFragment: BasicExpressionFragment {
                          get {
                            return BasicExpressionFragment(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }
                      }

                      public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                        get {
                          if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                          return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                        }
                        set {
                          guard let newValue = newValue else { return }
                          resultMap = newValue.resultMap
                        }
                      }

                      public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                            GraphQLField("text", type: .scalar(String.self)),
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                          self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var expressionUnaryType: EmbarkExpressionTypeUnary {
                          get {
                            return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                          }
                        }

                        public var text: String? {
                          get {
                            return resultMap["text"] as? String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "text")
                          }
                        }

                        public var fragments: Fragments {
                          get {
                            return Fragments(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }

                        public struct Fragments {
                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public var basicExpressionFragment: BasicExpressionFragment {
                            get {
                              return BasicExpressionFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }
                        }
                      }

                      public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                        get {
                          if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                          return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                        }
                        set {
                          guard let newValue = newValue else { return }
                          resultMap = newValue.resultMap
                        }
                      }

                      public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                            GraphQLField("key", type: .nonNull(.scalar(String.self))),
                            GraphQLField("value", type: .nonNull(.scalar(String.self))),
                            GraphQLField("text", type: .scalar(String.self)),
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                          self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var expressionBinaryType: EmbarkExpressionTypeBinary {
                          get {
                            return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                          }
                        }

                        public var key: String {
                          get {
                            return resultMap["key"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "key")
                          }
                        }

                        public var value: String {
                          get {
                            return resultMap["value"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "value")
                          }
                        }

                        public var text: String? {
                          get {
                            return resultMap["text"] as? String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "text")
                          }
                        }

                        public var fragments: Fragments {
                          get {
                            return Fragments(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }

                        public struct Fragments {
                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public var basicExpressionFragment: BasicExpressionFragment {
                            get {
                              return BasicExpressionFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }
                        }
                      }

                      public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
                        get {
                          if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
                          return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
                        }
                        set {
                          guard let newValue = newValue else { return }
                          resultMap = newValue.resultMap
                        }
                      }

                      public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
                            GraphQLField("text", type: .scalar(String.self)),
                            GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
                          self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var expressionMultipleType: EmbarkExpressionTypeMultiple {
                          get {
                            return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "expressionMultipleType")
                          }
                        }

                        public var text: String? {
                          get {
                            return resultMap["text"] as? String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "text")
                          }
                        }

                        public var subExpressions: [SubExpression] {
                          get {
                            return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
                          }
                          set {
                            resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
                          }
                        }

                        public var fragments: Fragments {
                          get {
                            return Fragments(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }

                        public struct Fragments {
                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public var basicExpressionFragment: BasicExpressionFragment {
                            get {
                              return BasicExpressionFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }
                        }

                        public struct SubExpression: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLTypeCase(
                                variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections],
                                default: [
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                ]
                              )
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public static func makeEmbarkExpressionMultiple() -> SubExpression {
                            return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple"])
                          }

                          public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
                            return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                          }

                          public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
                            return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var basicExpressionFragment: BasicExpressionFragment {
                              get {
                                return BasicExpressionFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }
                          }

                          public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                            get {
                              if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                              return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                            }
                            set {
                              guard let newValue = newValue else { return }
                              resultMap = newValue.resultMap
                            }
                          }

                          public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                            public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                            public static var selections: [GraphQLSelection] {
                              return [
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                                GraphQLField("text", type: .scalar(String.self)),
                              ]
                            }

                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                              self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                            }

                            public var __typename: String {
                              get {
                                return resultMap["__typename"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "__typename")
                              }
                            }

                            public var expressionUnaryType: EmbarkExpressionTypeUnary {
                              get {
                                return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                              }
                            }

                            public var text: String? {
                              get {
                                return resultMap["text"] as? String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "text")
                              }
                            }

                            public var fragments: Fragments {
                              get {
                                return Fragments(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public struct Fragments {
                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public var basicExpressionFragment: BasicExpressionFragment {
                                get {
                                  return BasicExpressionFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }
                            }
                          }

                          public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                            get {
                              if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                              return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                            }
                            set {
                              guard let newValue = newValue else { return }
                              resultMap = newValue.resultMap
                            }
                          }

                          public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                            public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                            public static var selections: [GraphQLSelection] {
                              return [
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                                GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                GraphQLField("value", type: .nonNull(.scalar(String.self))),
                                GraphQLField("text", type: .scalar(String.self)),
                              ]
                            }

                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                              self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                            }

                            public var __typename: String {
                              get {
                                return resultMap["__typename"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "__typename")
                              }
                            }

                            public var expressionBinaryType: EmbarkExpressionTypeBinary {
                              get {
                                return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                              }
                            }

                            public var key: String {
                              get {
                                return resultMap["key"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "key")
                              }
                            }

                            public var value: String {
                              get {
                                return resultMap["value"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "value")
                              }
                            }

                            public var text: String? {
                              get {
                                return resultMap["text"] as? String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "text")
                              }
                            }

                            public var fragments: Fragments {
                              get {
                                return Fragments(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public struct Fragments {
                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public var basicExpressionFragment: BasicExpressionFragment {
                                get {
                                  return BasicExpressionFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }

          public struct Api: GraphQLSelectionSet {
            public static let possibleTypes: [String] = ["EmbarkApiPersonalInformation", "EmbarkApiHouseInformation", "EmbarkApiCreateQuote", "EmbarkApiGraphQLQuery", "EmbarkApiGraphQLMutation"]

            public static var selections: [GraphQLSelection] {
              return [
                GraphQLTypeCase(
                  variants: ["EmbarkApiGraphQLQuery": AsEmbarkApiGraphQlQuery.selections, "EmbarkApiGraphQLMutation": AsEmbarkApiGraphQlMutation.selections],
                  default: [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  ]
                )
              ]
            }

            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public static func makeEmbarkApiPersonalInformation() -> Api {
              return Api(unsafeResultMap: ["__typename": "EmbarkApiPersonalInformation"])
            }

            public static func makeEmbarkApiHouseInformation() -> Api {
              return Api(unsafeResultMap: ["__typename": "EmbarkApiHouseInformation"])
            }

            public static func makeEmbarkApiCreateQuote() -> Api {
              return Api(unsafeResultMap: ["__typename": "EmbarkApiCreateQuote"])
            }

            public static func makeEmbarkApiGraphQLQuery(data: AsEmbarkApiGraphQlQuery.Datum) -> Api {
              return Api(unsafeResultMap: ["__typename": "EmbarkApiGraphQLQuery", "data": data.resultMap])
            }

            public static func makeEmbarkApiGraphQLMutation(data: AsEmbarkApiGraphQlMutation.Datum) -> Api {
              return Api(unsafeResultMap: ["__typename": "EmbarkApiGraphQLMutation", "data": data.resultMap])
            }

            public var __typename: String {
              get {
                return resultMap["__typename"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "__typename")
              }
            }

            public var fragments: Fragments {
              get {
                return Fragments(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }

            public struct Fragments {
              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public var apiFragment: ApiFragment {
                get {
                  return ApiFragment(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }
            }

            public var asEmbarkApiGraphQlQuery: AsEmbarkApiGraphQlQuery? {
              get {
                if !AsEmbarkApiGraphQlQuery.possibleTypes.contains(__typename) { return nil }
                return AsEmbarkApiGraphQlQuery(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap = newValue.resultMap
              }
            }

            public struct AsEmbarkApiGraphQlQuery: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkApiGraphQLQuery"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("data", type: .nonNull(.object(Datum.selections))),
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public init(data: Datum) {
                self.init(unsafeResultMap: ["__typename": "EmbarkApiGraphQLQuery", "data": data.resultMap])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var data: Datum {
                get {
                  return Datum(unsafeResultMap: resultMap["data"]! as! ResultMap)
                }
                set {
                  resultMap.updateValue(newValue.resultMap, forKey: "data")
                }
              }

              public var fragments: Fragments {
                get {
                  return Fragments(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public struct Fragments {
                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public var apiFragment: ApiFragment {
                  get {
                    return ApiFragment(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }
              }

              public struct Datum: GraphQLSelectionSet {
                public static let possibleTypes: [String] = ["EmbarkApiGraphQLQueryData"]

                public static var selections: [GraphQLSelection] {
                  return [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("next", type: .object(Next.selections)),
                    GraphQLField("query", type: .nonNull(.scalar(String.self))),
                    GraphQLField("variables", type: .nonNull(.list(.nonNull(.object(Variable.selections))))),
                    GraphQLField("results", alias: "queryResults", type: .nonNull(.list(.nonNull(.object(QueryResult.selections))))),
                    GraphQLField("errors", alias: "queryErrors", type: .nonNull(.list(.nonNull(.object(QueryError.selections))))),
                  ]
                }

                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public init(next: Next? = nil, query: String, variables: [Variable], queryResults: [QueryResult], queryErrors: [QueryError]) {
                  self.init(unsafeResultMap: ["__typename": "EmbarkApiGraphQLQueryData", "next": next.flatMap { (value: Next) -> ResultMap in value.resultMap }, "query": query, "variables": variables.map { (value: Variable) -> ResultMap in value.resultMap }, "queryResults": queryResults.map { (value: QueryResult) -> ResultMap in value.resultMap }, "queryErrors": queryErrors.map { (value: QueryError) -> ResultMap in value.resultMap }])
                }

                public var __typename: String {
                  get {
                    return resultMap["__typename"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "__typename")
                  }
                }

                public var next: Next? {
                  get {
                    return (resultMap["next"] as? ResultMap).flatMap { Next(unsafeResultMap: $0) }
                  }
                  set {
                    resultMap.updateValue(newValue?.resultMap, forKey: "next")
                  }
                }

                public var query: String {
                  get {
                    return resultMap["query"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "query")
                  }
                }

                public var variables: [Variable] {
                  get {
                    return (resultMap["variables"] as! [ResultMap]).map { (value: ResultMap) -> Variable in Variable(unsafeResultMap: value) }
                  }
                  set {
                    resultMap.updateValue(newValue.map { (value: Variable) -> ResultMap in value.resultMap }, forKey: "variables")
                  }
                }

                public var queryResults: [QueryResult] {
                  get {
                    return (resultMap["queryResults"] as! [ResultMap]).map { (value: ResultMap) -> QueryResult in QueryResult(unsafeResultMap: value) }
                  }
                  set {
                    resultMap.updateValue(newValue.map { (value: QueryResult) -> ResultMap in value.resultMap }, forKey: "queryResults")
                  }
                }

                public var queryErrors: [QueryError] {
                  get {
                    return (resultMap["queryErrors"] as! [ResultMap]).map { (value: ResultMap) -> QueryError in QueryError(unsafeResultMap: value) }
                  }
                  set {
                    resultMap.updateValue(newValue.map { (value: QueryError) -> ResultMap in value.resultMap }, forKey: "queryErrors")
                  }
                }

                public struct Next: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkLink"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("name", type: .nonNull(.scalar(String.self))),
                      GraphQLField("label", type: .nonNull(.scalar(String.self))),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(name: String, label: String) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkLink", "name": name, "label": label])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var name: String {
                    get {
                      return resultMap["name"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "name")
                    }
                  }

                  public var label: String {
                    get {
                      return resultMap["label"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "label")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var embarkLinkFragment: EmbarkLinkFragment {
                      get {
                        return EmbarkLinkFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }
                }

                public struct Variable: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable", "EmbarkAPIGraphQLGeneratedVariable", "EmbarkAPIGraphQLMultiActionVariable", "EmbarkAPIGraphQLConstantVariable"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLTypeCase(
                        variants: ["EmbarkAPIGraphQLSingleVariable": AsEmbarkApiGraphQlSingleVariable.selections, "EmbarkAPIGraphQLGeneratedVariable": AsEmbarkApiGraphQlGeneratedVariable.selections, "EmbarkAPIGraphQLMultiActionVariable": AsEmbarkApiGraphQlMultiActionVariable.selections],
                        default: [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        ]
                      )
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public static func makeEmbarkAPIGraphQLConstantVariable() -> Variable {
                    return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLConstantVariable"])
                  }

                  public static func makeEmbarkAPIGraphQLSingleVariable(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) -> Variable {
                    return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                  }

                  public static func makeEmbarkAPIGraphQLGeneratedVariable(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) -> Variable {
                    return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                  }

                  public static func makeEmbarkAPIGraphQLMultiActionVariable(key: String, variables: [AsEmbarkApiGraphQlMultiActionVariable.Variable]) -> Variable {
                    return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: AsEmbarkApiGraphQlMultiActionVariable.Variable) -> ResultMap in value.resultMap }])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var apiVariablesFragment: ApiVariablesFragment {
                      get {
                        return ApiVariablesFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                      get {
                        if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                        return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        guard let newValue = newValue else { return }
                        resultMap += newValue.resultMap
                      }
                    }

                    public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                      get {
                        if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                        return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        guard let newValue = newValue else { return }
                        resultMap += newValue.resultMap
                      }
                    }

                    public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment? {
                      get {
                        if !ApiMultiActionVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                        return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        guard let newValue = newValue else { return }
                        resultMap += newValue.resultMap
                      }
                    }
                  }

                  public var asEmbarkApiGraphQlSingleVariable: AsEmbarkApiGraphQlSingleVariable? {
                    get {
                      if !AsEmbarkApiGraphQlSingleVariable.possibleTypes.contains(__typename) { return nil }
                      return AsEmbarkApiGraphQlSingleVariable(unsafeResultMap: resultMap)
                    }
                    set {
                      guard let newValue = newValue else { return }
                      resultMap = newValue.resultMap
                    }
                  }

                  public struct AsEmbarkApiGraphQlSingleVariable: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("key", type: .nonNull(.scalar(String.self))),
                        GraphQLField("from", type: .nonNull(.scalar(String.self))),
                        GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
                      self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var key: String {
                      get {
                        return resultMap["key"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "key")
                      }
                    }

                    public var from: String {
                      get {
                        return resultMap["from"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "from")
                      }
                    }

                    public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
                      get {
                        return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "as")
                      }
                    }

                    public var fragments: Fragments {
                      get {
                        return Fragments(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public struct Fragments {
                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public var apiVariablesFragment: ApiVariablesFragment {
                        get {
                          return ApiVariablesFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public var apiSingleVariableFragment: ApiSingleVariableFragment {
                        get {
                          return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                        get {
                          if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                          return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          guard let newValue = newValue else { return }
                          resultMap += newValue.resultMap
                        }
                      }

                      public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment? {
                        get {
                          if !ApiMultiActionVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                          return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          guard let newValue = newValue else { return }
                          resultMap += newValue.resultMap
                        }
                      }
                    }
                  }

                  public var asEmbarkApiGraphQlGeneratedVariable: AsEmbarkApiGraphQlGeneratedVariable? {
                    get {
                      if !AsEmbarkApiGraphQlGeneratedVariable.possibleTypes.contains(__typename) { return nil }
                      return AsEmbarkApiGraphQlGeneratedVariable(unsafeResultMap: resultMap)
                    }
                    set {
                      guard let newValue = newValue else { return }
                      resultMap = newValue.resultMap
                    }
                  }

                  public struct AsEmbarkApiGraphQlGeneratedVariable: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("key", type: .nonNull(.scalar(String.self))),
                        GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
                        GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
                      self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var key: String {
                      get {
                        return resultMap["key"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "key")
                      }
                    }

                    public var storeAs: String {
                      get {
                        return resultMap["storeAs"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "storeAs")
                      }
                    }

                    public var type: EmbarkAPIGraphQLVariableGeneratedType {
                      get {
                        return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "type")
                      }
                    }

                    public var fragments: Fragments {
                      get {
                        return Fragments(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public struct Fragments {
                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public var apiVariablesFragment: ApiVariablesFragment {
                        get {
                          return ApiVariablesFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                        get {
                          if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                          return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          guard let newValue = newValue else { return }
                          resultMap += newValue.resultMap
                        }
                      }

                      public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment {
                        get {
                          return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment? {
                        get {
                          if !ApiMultiActionVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                          return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          guard let newValue = newValue else { return }
                          resultMap += newValue.resultMap
                        }
                      }
                    }
                  }

                  public var asEmbarkApiGraphQlMultiActionVariable: AsEmbarkApiGraphQlMultiActionVariable? {
                    get {
                      if !AsEmbarkApiGraphQlMultiActionVariable.possibleTypes.contains(__typename) { return nil }
                      return AsEmbarkApiGraphQlMultiActionVariable(unsafeResultMap: resultMap)
                    }
                    set {
                      guard let newValue = newValue else { return }
                      resultMap = newValue.resultMap
                    }
                  }

                  public struct AsEmbarkApiGraphQlMultiActionVariable: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkAPIGraphQLMultiActionVariable"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("key", type: .nonNull(.scalar(String.self))),
                        GraphQLField("variables", type: .nonNull(.list(.nonNull(.object(Variable.selections))))),
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public init(key: String, variables: [Variable]) {
                      self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: Variable) -> ResultMap in value.resultMap }])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var key: String {
                      get {
                        return resultMap["key"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "key")
                      }
                    }

                    public var variables: [Variable] {
                      get {
                        return (resultMap["variables"] as! [ResultMap]).map { (value: ResultMap) -> Variable in Variable(unsafeResultMap: value) }
                      }
                      set {
                        resultMap.updateValue(newValue.map { (value: Variable) -> ResultMap in value.resultMap }, forKey: "variables")
                      }
                    }

                    public var fragments: Fragments {
                      get {
                        return Fragments(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public struct Fragments {
                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public var apiVariablesFragment: ApiVariablesFragment {
                        get {
                          return ApiVariablesFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                        get {
                          if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                          return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          guard let newValue = newValue else { return }
                          resultMap += newValue.resultMap
                        }
                      }

                      public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                        get {
                          if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                          return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          guard let newValue = newValue else { return }
                          resultMap += newValue.resultMap
                        }
                      }

                      public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment {
                        get {
                          return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }
                    }

                    public struct Variable: GraphQLSelectionSet {
                      public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable", "EmbarkAPIGraphQLGeneratedVariable", "EmbarkAPIGraphQLMultiActionVariable", "EmbarkAPIGraphQLConstantVariable"]

                      public static var selections: [GraphQLSelection] {
                        return [
                          GraphQLTypeCase(
                            variants: ["EmbarkAPIGraphQLSingleVariable": AsEmbarkApiGraphQlSingleVariable.selections, "EmbarkAPIGraphQLGeneratedVariable": AsEmbarkApiGraphQlGeneratedVariable.selections, "EmbarkAPIGraphQLMultiActionVariable": AsEmbarkApiGraphQlMultiActionVariable.selections],
                            default: [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            ]
                          )
                        ]
                      }

                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public static func makeEmbarkAPIGraphQLConstantVariable() -> Variable {
                        return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLConstantVariable"])
                      }

                      public static func makeEmbarkAPIGraphQLSingleVariable(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) -> Variable {
                        return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                      }

                      public static func makeEmbarkAPIGraphQLGeneratedVariable(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) -> Variable {
                        return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                      }

                      public static func makeEmbarkAPIGraphQLMultiActionVariable(key: String, variables: [AsEmbarkApiGraphQlMultiActionVariable.Variable]) -> Variable {
                        return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: AsEmbarkApiGraphQlMultiActionVariable.Variable) -> ResultMap in value.resultMap }])
                      }

                      public var __typename: String {
                        get {
                          return resultMap["__typename"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "__typename")
                        }
                      }

                      public var fragments: Fragments {
                        get {
                          return Fragments(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public struct Fragments {
                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                          get {
                            if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                            return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                          }
                          set {
                            guard let newValue = newValue else { return }
                            resultMap += newValue.resultMap
                          }
                        }

                        public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                          get {
                            if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                            return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                          }
                          set {
                            guard let newValue = newValue else { return }
                            resultMap += newValue.resultMap
                          }
                        }
                      }

                      public var asEmbarkApiGraphQlSingleVariable: AsEmbarkApiGraphQlSingleVariable? {
                        get {
                          if !AsEmbarkApiGraphQlSingleVariable.possibleTypes.contains(__typename) { return nil }
                          return AsEmbarkApiGraphQlSingleVariable(unsafeResultMap: resultMap)
                        }
                        set {
                          guard let newValue = newValue else { return }
                          resultMap = newValue.resultMap
                        }
                      }

                      public struct AsEmbarkApiGraphQlSingleVariable: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("key", type: .nonNull(.scalar(String.self))),
                            GraphQLField("from", type: .nonNull(.scalar(String.self))),
                            GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
                          self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var key: String {
                          get {
                            return resultMap["key"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "key")
                          }
                        }

                        public var from: String {
                          get {
                            return resultMap["from"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "from")
                          }
                        }

                        public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
                          get {
                            return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "as")
                          }
                        }

                        public var fragments: Fragments {
                          get {
                            return Fragments(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }

                        public struct Fragments {
                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public var apiSingleVariableFragment: ApiSingleVariableFragment {
                            get {
                              return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                            get {
                              if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                              return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              guard let newValue = newValue else { return }
                              resultMap += newValue.resultMap
                            }
                          }
                        }
                      }

                      public var asEmbarkApiGraphQlGeneratedVariable: AsEmbarkApiGraphQlGeneratedVariable? {
                        get {
                          if !AsEmbarkApiGraphQlGeneratedVariable.possibleTypes.contains(__typename) { return nil }
                          return AsEmbarkApiGraphQlGeneratedVariable(unsafeResultMap: resultMap)
                        }
                        set {
                          guard let newValue = newValue else { return }
                          resultMap = newValue.resultMap
                        }
                      }

                      public struct AsEmbarkApiGraphQlGeneratedVariable: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("key", type: .nonNull(.scalar(String.self))),
                            GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
                            GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
                          self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var key: String {
                          get {
                            return resultMap["key"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "key")
                          }
                        }

                        public var storeAs: String {
                          get {
                            return resultMap["storeAs"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "storeAs")
                          }
                        }

                        public var type: EmbarkAPIGraphQLVariableGeneratedType {
                          get {
                            return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "type")
                          }
                        }

                        public var fragments: Fragments {
                          get {
                            return Fragments(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }

                        public struct Fragments {
                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                            get {
                              if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                              return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              guard let newValue = newValue else { return }
                              resultMap += newValue.resultMap
                            }
                          }

                          public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment {
                            get {
                              return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }
                        }
                      }

                      public var asEmbarkApiGraphQlMultiActionVariable: AsEmbarkApiGraphQlMultiActionVariable? {
                        get {
                          if !AsEmbarkApiGraphQlMultiActionVariable.possibleTypes.contains(__typename) { return nil }
                          return AsEmbarkApiGraphQlMultiActionVariable(unsafeResultMap: resultMap)
                        }
                        set {
                          guard let newValue = newValue else { return }
                          resultMap = newValue.resultMap
                        }
                      }

                      public struct AsEmbarkApiGraphQlMultiActionVariable: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkAPIGraphQLMultiActionVariable"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("key", type: .nonNull(.scalar(String.self))),
                            GraphQLField("variables", type: .nonNull(.list(.nonNull(.object(Variable.selections))))),
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public init(key: String, variables: [Variable]) {
                          self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: Variable) -> ResultMap in value.resultMap }])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var key: String {
                          get {
                            return resultMap["key"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "key")
                          }
                        }

                        public var variables: [Variable] {
                          get {
                            return (resultMap["variables"] as! [ResultMap]).map { (value: ResultMap) -> Variable in Variable(unsafeResultMap: value) }
                          }
                          set {
                            resultMap.updateValue(newValue.map { (value: Variable) -> ResultMap in value.resultMap }, forKey: "variables")
                          }
                        }

                        public var fragments: Fragments {
                          get {
                            return Fragments(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }

                        public struct Fragments {
                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                            get {
                              if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                              return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              guard let newValue = newValue else { return }
                              resultMap += newValue.resultMap
                            }
                          }

                          public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                            get {
                              if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                              return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              guard let newValue = newValue else { return }
                              resultMap += newValue.resultMap
                            }
                          }
                        }

                        public struct Variable: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable", "EmbarkAPIGraphQLGeneratedVariable", "EmbarkAPIGraphQLMultiActionVariable", "EmbarkAPIGraphQLConstantVariable"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLTypeCase(
                                variants: ["EmbarkAPIGraphQLSingleVariable": AsEmbarkApiGraphQlSingleVariable.selections, "EmbarkAPIGraphQLGeneratedVariable": AsEmbarkApiGraphQlGeneratedVariable.selections],
                                default: [
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                ]
                              )
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public static func makeEmbarkAPIGraphQLMultiActionVariable() -> Variable {
                            return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable"])
                          }

                          public static func makeEmbarkAPIGraphQLConstantVariable() -> Variable {
                            return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLConstantVariable"])
                          }

                          public static func makeEmbarkAPIGraphQLSingleVariable(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) -> Variable {
                            return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                          }

                          public static func makeEmbarkAPIGraphQLGeneratedVariable(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) -> Variable {
                            return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                              get {
                                if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                              get {
                                if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }
                          }

                          public var asEmbarkApiGraphQlSingleVariable: AsEmbarkApiGraphQlSingleVariable? {
                            get {
                              if !AsEmbarkApiGraphQlSingleVariable.possibleTypes.contains(__typename) { return nil }
                              return AsEmbarkApiGraphQlSingleVariable(unsafeResultMap: resultMap)
                            }
                            set {
                              guard let newValue = newValue else { return }
                              resultMap = newValue.resultMap
                            }
                          }

                          public struct AsEmbarkApiGraphQlSingleVariable: GraphQLSelectionSet {
                            public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

                            public static var selections: [GraphQLSelection] {
                              return [
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                GraphQLField("from", type: .nonNull(.scalar(String.self))),
                                GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
                              ]
                            }

                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
                              self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                            }

                            public var __typename: String {
                              get {
                                return resultMap["__typename"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "__typename")
                              }
                            }

                            public var key: String {
                              get {
                                return resultMap["key"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "key")
                              }
                            }

                            public var from: String {
                              get {
                                return resultMap["from"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "from")
                              }
                            }

                            public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
                              get {
                                return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "as")
                              }
                            }

                            public var fragments: Fragments {
                              get {
                                return Fragments(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public struct Fragments {
                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public var apiSingleVariableFragment: ApiSingleVariableFragment {
                                get {
                                  return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                get {
                                  if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                  return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  guard let newValue = newValue else { return }
                                  resultMap += newValue.resultMap
                                }
                              }
                            }
                          }

                          public var asEmbarkApiGraphQlGeneratedVariable: AsEmbarkApiGraphQlGeneratedVariable? {
                            get {
                              if !AsEmbarkApiGraphQlGeneratedVariable.possibleTypes.contains(__typename) { return nil }
                              return AsEmbarkApiGraphQlGeneratedVariable(unsafeResultMap: resultMap)
                            }
                            set {
                              guard let newValue = newValue else { return }
                              resultMap = newValue.resultMap
                            }
                          }

                          public struct AsEmbarkApiGraphQlGeneratedVariable: GraphQLSelectionSet {
                            public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

                            public static var selections: [GraphQLSelection] {
                              return [
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
                                GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
                              ]
                            }

                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
                              self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                            }

                            public var __typename: String {
                              get {
                                return resultMap["__typename"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "__typename")
                              }
                            }

                            public var key: String {
                              get {
                                return resultMap["key"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "key")
                              }
                            }

                            public var storeAs: String {
                              get {
                                return resultMap["storeAs"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "storeAs")
                              }
                            }

                            public var type: EmbarkAPIGraphQLVariableGeneratedType {
                              get {
                                return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "type")
                              }
                            }

                            public var fragments: Fragments {
                              get {
                                return Fragments(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public struct Fragments {
                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                get {
                                  if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                  return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  guard let newValue = newValue else { return }
                                  resultMap += newValue.resultMap
                                }
                              }

                              public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment {
                                get {
                                  return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }

                public struct QueryResult: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkAPIGraphQLResult"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("key", type: .nonNull(.scalar(String.self))),
                      GraphQLField("as", type: .nonNull(.scalar(String.self))),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(key: String, `as`: String) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLResult", "key": key, "as": `as`])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var key: String {
                    get {
                      return resultMap["key"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "key")
                    }
                  }

                  public var `as`: String {
                    get {
                      return resultMap["as"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "as")
                    }
                  }
                }

                public struct QueryError: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkAPIGraphQLError"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("contains", type: .scalar(String.self)),
                      GraphQLField("next", type: .nonNull(.object(Next.selections))),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(contains: String? = nil, next: Next) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLError", "contains": contains, "next": next.resultMap])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var contains: String? {
                    get {
                      return resultMap["contains"] as? String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "contains")
                    }
                  }

                  public var next: Next {
                    get {
                      return Next(unsafeResultMap: resultMap["next"]! as! ResultMap)
                    }
                    set {
                      resultMap.updateValue(newValue.resultMap, forKey: "next")
                    }
                  }

                  public struct Next: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkLink"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("name", type: .nonNull(.scalar(String.self))),
                        GraphQLField("label", type: .nonNull(.scalar(String.self))),
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public init(name: String, label: String) {
                      self.init(unsafeResultMap: ["__typename": "EmbarkLink", "name": name, "label": label])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var name: String {
                      get {
                        return resultMap["name"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "name")
                      }
                    }

                    public var label: String {
                      get {
                        return resultMap["label"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "label")
                      }
                    }

                    public var fragments: Fragments {
                      get {
                        return Fragments(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public struct Fragments {
                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public var embarkLinkFragment: EmbarkLinkFragment {
                        get {
                          return EmbarkLinkFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }
                    }
                  }
                }
              }
            }

            public var asEmbarkApiGraphQlMutation: AsEmbarkApiGraphQlMutation? {
              get {
                if !AsEmbarkApiGraphQlMutation.possibleTypes.contains(__typename) { return nil }
                return AsEmbarkApiGraphQlMutation(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap = newValue.resultMap
              }
            }

            public struct AsEmbarkApiGraphQlMutation: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkApiGraphQLMutation"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("data", type: .nonNull(.object(Datum.selections))),
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public init(data: Datum) {
                self.init(unsafeResultMap: ["__typename": "EmbarkApiGraphQLMutation", "data": data.resultMap])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var data: Datum {
                get {
                  return Datum(unsafeResultMap: resultMap["data"]! as! ResultMap)
                }
                set {
                  resultMap.updateValue(newValue.resultMap, forKey: "data")
                }
              }

              public var fragments: Fragments {
                get {
                  return Fragments(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public struct Fragments {
                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public var apiFragment: ApiFragment {
                  get {
                    return ApiFragment(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }
              }

              public struct Datum: GraphQLSelectionSet {
                public static let possibleTypes: [String] = ["EmbarkApiGraphQLMutationData"]

                public static var selections: [GraphQLSelection] {
                  return [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("next", type: .object(Next.selections)),
                    GraphQLField("mutation", type: .nonNull(.scalar(String.self))),
                    GraphQLField("variables", type: .nonNull(.list(.nonNull(.object(Variable.selections))))),
                    GraphQLField("results", alias: "mutationResults", type: .nonNull(.list(.object(MutationResult.selections)))),
                    GraphQLField("errors", alias: "mutationErrors", type: .nonNull(.list(.nonNull(.object(MutationError.selections))))),
                  ]
                }

                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public init(next: Next? = nil, mutation: String, variables: [Variable], mutationResults: [MutationResult?], mutationErrors: [MutationError]) {
                  self.init(unsafeResultMap: ["__typename": "EmbarkApiGraphQLMutationData", "next": next.flatMap { (value: Next) -> ResultMap in value.resultMap }, "mutation": mutation, "variables": variables.map { (value: Variable) -> ResultMap in value.resultMap }, "mutationResults": mutationResults.map { (value: MutationResult?) -> ResultMap? in value.flatMap { (value: MutationResult) -> ResultMap in value.resultMap } }, "mutationErrors": mutationErrors.map { (value: MutationError) -> ResultMap in value.resultMap }])
                }

                public var __typename: String {
                  get {
                    return resultMap["__typename"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "__typename")
                  }
                }

                public var next: Next? {
                  get {
                    return (resultMap["next"] as? ResultMap).flatMap { Next(unsafeResultMap: $0) }
                  }
                  set {
                    resultMap.updateValue(newValue?.resultMap, forKey: "next")
                  }
                }

                public var mutation: String {
                  get {
                    return resultMap["mutation"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "mutation")
                  }
                }

                public var variables: [Variable] {
                  get {
                    return (resultMap["variables"] as! [ResultMap]).map { (value: ResultMap) -> Variable in Variable(unsafeResultMap: value) }
                  }
                  set {
                    resultMap.updateValue(newValue.map { (value: Variable) -> ResultMap in value.resultMap }, forKey: "variables")
                  }
                }

                public var mutationResults: [MutationResult?] {
                  get {
                    return (resultMap["mutationResults"] as! [ResultMap?]).map { (value: ResultMap?) -> MutationResult? in value.flatMap { (value: ResultMap) -> MutationResult in MutationResult(unsafeResultMap: value) } }
                  }
                  set {
                    resultMap.updateValue(newValue.map { (value: MutationResult?) -> ResultMap? in value.flatMap { (value: MutationResult) -> ResultMap in value.resultMap } }, forKey: "mutationResults")
                  }
                }

                public var mutationErrors: [MutationError] {
                  get {
                    return (resultMap["mutationErrors"] as! [ResultMap]).map { (value: ResultMap) -> MutationError in MutationError(unsafeResultMap: value) }
                  }
                  set {
                    resultMap.updateValue(newValue.map { (value: MutationError) -> ResultMap in value.resultMap }, forKey: "mutationErrors")
                  }
                }

                public struct Next: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkLink"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("name", type: .nonNull(.scalar(String.self))),
                      GraphQLField("label", type: .nonNull(.scalar(String.self))),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(name: String, label: String) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkLink", "name": name, "label": label])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var name: String {
                    get {
                      return resultMap["name"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "name")
                    }
                  }

                  public var label: String {
                    get {
                      return resultMap["label"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "label")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var embarkLinkFragment: EmbarkLinkFragment {
                      get {
                        return EmbarkLinkFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }
                }

                public struct Variable: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable", "EmbarkAPIGraphQLGeneratedVariable", "EmbarkAPIGraphQLMultiActionVariable", "EmbarkAPIGraphQLConstantVariable"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLTypeCase(
                        variants: ["EmbarkAPIGraphQLSingleVariable": AsEmbarkApiGraphQlSingleVariable.selections, "EmbarkAPIGraphQLGeneratedVariable": AsEmbarkApiGraphQlGeneratedVariable.selections, "EmbarkAPIGraphQLMultiActionVariable": AsEmbarkApiGraphQlMultiActionVariable.selections],
                        default: [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        ]
                      )
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public static func makeEmbarkAPIGraphQLConstantVariable() -> Variable {
                    return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLConstantVariable"])
                  }

                  public static func makeEmbarkAPIGraphQLSingleVariable(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) -> Variable {
                    return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                  }

                  public static func makeEmbarkAPIGraphQLGeneratedVariable(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) -> Variable {
                    return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                  }

                  public static func makeEmbarkAPIGraphQLMultiActionVariable(key: String, variables: [AsEmbarkApiGraphQlMultiActionVariable.Variable]) -> Variable {
                    return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: AsEmbarkApiGraphQlMultiActionVariable.Variable) -> ResultMap in value.resultMap }])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var apiVariablesFragment: ApiVariablesFragment {
                      get {
                        return ApiVariablesFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                      get {
                        if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                        return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        guard let newValue = newValue else { return }
                        resultMap += newValue.resultMap
                      }
                    }

                    public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                      get {
                        if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                        return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        guard let newValue = newValue else { return }
                        resultMap += newValue.resultMap
                      }
                    }

                    public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment? {
                      get {
                        if !ApiMultiActionVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                        return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        guard let newValue = newValue else { return }
                        resultMap += newValue.resultMap
                      }
                    }
                  }

                  public var asEmbarkApiGraphQlSingleVariable: AsEmbarkApiGraphQlSingleVariable? {
                    get {
                      if !AsEmbarkApiGraphQlSingleVariable.possibleTypes.contains(__typename) { return nil }
                      return AsEmbarkApiGraphQlSingleVariable(unsafeResultMap: resultMap)
                    }
                    set {
                      guard let newValue = newValue else { return }
                      resultMap = newValue.resultMap
                    }
                  }

                  public struct AsEmbarkApiGraphQlSingleVariable: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("key", type: .nonNull(.scalar(String.self))),
                        GraphQLField("from", type: .nonNull(.scalar(String.self))),
                        GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
                      self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var key: String {
                      get {
                        return resultMap["key"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "key")
                      }
                    }

                    public var from: String {
                      get {
                        return resultMap["from"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "from")
                      }
                    }

                    public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
                      get {
                        return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "as")
                      }
                    }

                    public var fragments: Fragments {
                      get {
                        return Fragments(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public struct Fragments {
                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public var apiVariablesFragment: ApiVariablesFragment {
                        get {
                          return ApiVariablesFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public var apiSingleVariableFragment: ApiSingleVariableFragment {
                        get {
                          return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                        get {
                          if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                          return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          guard let newValue = newValue else { return }
                          resultMap += newValue.resultMap
                        }
                      }

                      public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment? {
                        get {
                          if !ApiMultiActionVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                          return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          guard let newValue = newValue else { return }
                          resultMap += newValue.resultMap
                        }
                      }
                    }
                  }

                  public var asEmbarkApiGraphQlGeneratedVariable: AsEmbarkApiGraphQlGeneratedVariable? {
                    get {
                      if !AsEmbarkApiGraphQlGeneratedVariable.possibleTypes.contains(__typename) { return nil }
                      return AsEmbarkApiGraphQlGeneratedVariable(unsafeResultMap: resultMap)
                    }
                    set {
                      guard let newValue = newValue else { return }
                      resultMap = newValue.resultMap
                    }
                  }

                  public struct AsEmbarkApiGraphQlGeneratedVariable: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("key", type: .nonNull(.scalar(String.self))),
                        GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
                        GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
                      self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var key: String {
                      get {
                        return resultMap["key"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "key")
                      }
                    }

                    public var storeAs: String {
                      get {
                        return resultMap["storeAs"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "storeAs")
                      }
                    }

                    public var type: EmbarkAPIGraphQLVariableGeneratedType {
                      get {
                        return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "type")
                      }
                    }

                    public var fragments: Fragments {
                      get {
                        return Fragments(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public struct Fragments {
                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public var apiVariablesFragment: ApiVariablesFragment {
                        get {
                          return ApiVariablesFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                        get {
                          if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                          return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          guard let newValue = newValue else { return }
                          resultMap += newValue.resultMap
                        }
                      }

                      public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment {
                        get {
                          return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment? {
                        get {
                          if !ApiMultiActionVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                          return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          guard let newValue = newValue else { return }
                          resultMap += newValue.resultMap
                        }
                      }
                    }
                  }

                  public var asEmbarkApiGraphQlMultiActionVariable: AsEmbarkApiGraphQlMultiActionVariable? {
                    get {
                      if !AsEmbarkApiGraphQlMultiActionVariable.possibleTypes.contains(__typename) { return nil }
                      return AsEmbarkApiGraphQlMultiActionVariable(unsafeResultMap: resultMap)
                    }
                    set {
                      guard let newValue = newValue else { return }
                      resultMap = newValue.resultMap
                    }
                  }

                  public struct AsEmbarkApiGraphQlMultiActionVariable: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkAPIGraphQLMultiActionVariable"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("key", type: .nonNull(.scalar(String.self))),
                        GraphQLField("variables", type: .nonNull(.list(.nonNull(.object(Variable.selections))))),
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public init(key: String, variables: [Variable]) {
                      self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: Variable) -> ResultMap in value.resultMap }])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var key: String {
                      get {
                        return resultMap["key"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "key")
                      }
                    }

                    public var variables: [Variable] {
                      get {
                        return (resultMap["variables"] as! [ResultMap]).map { (value: ResultMap) -> Variable in Variable(unsafeResultMap: value) }
                      }
                      set {
                        resultMap.updateValue(newValue.map { (value: Variable) -> ResultMap in value.resultMap }, forKey: "variables")
                      }
                    }

                    public var fragments: Fragments {
                      get {
                        return Fragments(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public struct Fragments {
                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public var apiVariablesFragment: ApiVariablesFragment {
                        get {
                          return ApiVariablesFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                        get {
                          if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                          return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          guard let newValue = newValue else { return }
                          resultMap += newValue.resultMap
                        }
                      }

                      public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                        get {
                          if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                          return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          guard let newValue = newValue else { return }
                          resultMap += newValue.resultMap
                        }
                      }

                      public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment {
                        get {
                          return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }
                    }

                    public struct Variable: GraphQLSelectionSet {
                      public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable", "EmbarkAPIGraphQLGeneratedVariable", "EmbarkAPIGraphQLMultiActionVariable", "EmbarkAPIGraphQLConstantVariable"]

                      public static var selections: [GraphQLSelection] {
                        return [
                          GraphQLTypeCase(
                            variants: ["EmbarkAPIGraphQLSingleVariable": AsEmbarkApiGraphQlSingleVariable.selections, "EmbarkAPIGraphQLGeneratedVariable": AsEmbarkApiGraphQlGeneratedVariable.selections, "EmbarkAPIGraphQLMultiActionVariable": AsEmbarkApiGraphQlMultiActionVariable.selections],
                            default: [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            ]
                          )
                        ]
                      }

                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public static func makeEmbarkAPIGraphQLConstantVariable() -> Variable {
                        return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLConstantVariable"])
                      }

                      public static func makeEmbarkAPIGraphQLSingleVariable(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) -> Variable {
                        return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                      }

                      public static func makeEmbarkAPIGraphQLGeneratedVariable(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) -> Variable {
                        return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                      }

                      public static func makeEmbarkAPIGraphQLMultiActionVariable(key: String, variables: [AsEmbarkApiGraphQlMultiActionVariable.Variable]) -> Variable {
                        return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: AsEmbarkApiGraphQlMultiActionVariable.Variable) -> ResultMap in value.resultMap }])
                      }

                      public var __typename: String {
                        get {
                          return resultMap["__typename"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "__typename")
                        }
                      }

                      public var fragments: Fragments {
                        get {
                          return Fragments(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public struct Fragments {
                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                          get {
                            if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                            return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                          }
                          set {
                            guard let newValue = newValue else { return }
                            resultMap += newValue.resultMap
                          }
                        }

                        public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                          get {
                            if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                            return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                          }
                          set {
                            guard let newValue = newValue else { return }
                            resultMap += newValue.resultMap
                          }
                        }
                      }

                      public var asEmbarkApiGraphQlSingleVariable: AsEmbarkApiGraphQlSingleVariable? {
                        get {
                          if !AsEmbarkApiGraphQlSingleVariable.possibleTypes.contains(__typename) { return nil }
                          return AsEmbarkApiGraphQlSingleVariable(unsafeResultMap: resultMap)
                        }
                        set {
                          guard let newValue = newValue else { return }
                          resultMap = newValue.resultMap
                        }
                      }

                      public struct AsEmbarkApiGraphQlSingleVariable: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("key", type: .nonNull(.scalar(String.self))),
                            GraphQLField("from", type: .nonNull(.scalar(String.self))),
                            GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
                          self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var key: String {
                          get {
                            return resultMap["key"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "key")
                          }
                        }

                        public var from: String {
                          get {
                            return resultMap["from"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "from")
                          }
                        }

                        public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
                          get {
                            return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "as")
                          }
                        }

                        public var fragments: Fragments {
                          get {
                            return Fragments(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }

                        public struct Fragments {
                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public var apiSingleVariableFragment: ApiSingleVariableFragment {
                            get {
                              return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                            get {
                              if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                              return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              guard let newValue = newValue else { return }
                              resultMap += newValue.resultMap
                            }
                          }
                        }
                      }

                      public var asEmbarkApiGraphQlGeneratedVariable: AsEmbarkApiGraphQlGeneratedVariable? {
                        get {
                          if !AsEmbarkApiGraphQlGeneratedVariable.possibleTypes.contains(__typename) { return nil }
                          return AsEmbarkApiGraphQlGeneratedVariable(unsafeResultMap: resultMap)
                        }
                        set {
                          guard let newValue = newValue else { return }
                          resultMap = newValue.resultMap
                        }
                      }

                      public struct AsEmbarkApiGraphQlGeneratedVariable: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("key", type: .nonNull(.scalar(String.self))),
                            GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
                            GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
                          self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var key: String {
                          get {
                            return resultMap["key"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "key")
                          }
                        }

                        public var storeAs: String {
                          get {
                            return resultMap["storeAs"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "storeAs")
                          }
                        }

                        public var type: EmbarkAPIGraphQLVariableGeneratedType {
                          get {
                            return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "type")
                          }
                        }

                        public var fragments: Fragments {
                          get {
                            return Fragments(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }

                        public struct Fragments {
                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                            get {
                              if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                              return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              guard let newValue = newValue else { return }
                              resultMap += newValue.resultMap
                            }
                          }

                          public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment {
                            get {
                              return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }
                        }
                      }

                      public var asEmbarkApiGraphQlMultiActionVariable: AsEmbarkApiGraphQlMultiActionVariable? {
                        get {
                          if !AsEmbarkApiGraphQlMultiActionVariable.possibleTypes.contains(__typename) { return nil }
                          return AsEmbarkApiGraphQlMultiActionVariable(unsafeResultMap: resultMap)
                        }
                        set {
                          guard let newValue = newValue else { return }
                          resultMap = newValue.resultMap
                        }
                      }

                      public struct AsEmbarkApiGraphQlMultiActionVariable: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkAPIGraphQLMultiActionVariable"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("key", type: .nonNull(.scalar(String.self))),
                            GraphQLField("variables", type: .nonNull(.list(.nonNull(.object(Variable.selections))))),
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public init(key: String, variables: [Variable]) {
                          self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: Variable) -> ResultMap in value.resultMap }])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var key: String {
                          get {
                            return resultMap["key"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "key")
                          }
                        }

                        public var variables: [Variable] {
                          get {
                            return (resultMap["variables"] as! [ResultMap]).map { (value: ResultMap) -> Variable in Variable(unsafeResultMap: value) }
                          }
                          set {
                            resultMap.updateValue(newValue.map { (value: Variable) -> ResultMap in value.resultMap }, forKey: "variables")
                          }
                        }

                        public var fragments: Fragments {
                          get {
                            return Fragments(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }

                        public struct Fragments {
                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                            get {
                              if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                              return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              guard let newValue = newValue else { return }
                              resultMap += newValue.resultMap
                            }
                          }

                          public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                            get {
                              if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                              return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              guard let newValue = newValue else { return }
                              resultMap += newValue.resultMap
                            }
                          }
                        }

                        public struct Variable: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable", "EmbarkAPIGraphQLGeneratedVariable", "EmbarkAPIGraphQLMultiActionVariable", "EmbarkAPIGraphQLConstantVariable"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLTypeCase(
                                variants: ["EmbarkAPIGraphQLSingleVariable": AsEmbarkApiGraphQlSingleVariable.selections, "EmbarkAPIGraphQLGeneratedVariable": AsEmbarkApiGraphQlGeneratedVariable.selections],
                                default: [
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                ]
                              )
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public static func makeEmbarkAPIGraphQLMultiActionVariable() -> Variable {
                            return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable"])
                          }

                          public static func makeEmbarkAPIGraphQLConstantVariable() -> Variable {
                            return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLConstantVariable"])
                          }

                          public static func makeEmbarkAPIGraphQLSingleVariable(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) -> Variable {
                            return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                          }

                          public static func makeEmbarkAPIGraphQLGeneratedVariable(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) -> Variable {
                            return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                              get {
                                if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                              get {
                                if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }
                          }

                          public var asEmbarkApiGraphQlSingleVariable: AsEmbarkApiGraphQlSingleVariable? {
                            get {
                              if !AsEmbarkApiGraphQlSingleVariable.possibleTypes.contains(__typename) { return nil }
                              return AsEmbarkApiGraphQlSingleVariable(unsafeResultMap: resultMap)
                            }
                            set {
                              guard let newValue = newValue else { return }
                              resultMap = newValue.resultMap
                            }
                          }

                          public struct AsEmbarkApiGraphQlSingleVariable: GraphQLSelectionSet {
                            public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

                            public static var selections: [GraphQLSelection] {
                              return [
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                GraphQLField("from", type: .nonNull(.scalar(String.self))),
                                GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
                              ]
                            }

                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
                              self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                            }

                            public var __typename: String {
                              get {
                                return resultMap["__typename"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "__typename")
                              }
                            }

                            public var key: String {
                              get {
                                return resultMap["key"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "key")
                              }
                            }

                            public var from: String {
                              get {
                                return resultMap["from"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "from")
                              }
                            }

                            public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
                              get {
                                return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "as")
                              }
                            }

                            public var fragments: Fragments {
                              get {
                                return Fragments(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public struct Fragments {
                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public var apiSingleVariableFragment: ApiSingleVariableFragment {
                                get {
                                  return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                get {
                                  if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                  return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  guard let newValue = newValue else { return }
                                  resultMap += newValue.resultMap
                                }
                              }
                            }
                          }

                          public var asEmbarkApiGraphQlGeneratedVariable: AsEmbarkApiGraphQlGeneratedVariable? {
                            get {
                              if !AsEmbarkApiGraphQlGeneratedVariable.possibleTypes.contains(__typename) { return nil }
                              return AsEmbarkApiGraphQlGeneratedVariable(unsafeResultMap: resultMap)
                            }
                            set {
                              guard let newValue = newValue else { return }
                              resultMap = newValue.resultMap
                            }
                          }

                          public struct AsEmbarkApiGraphQlGeneratedVariable: GraphQLSelectionSet {
                            public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

                            public static var selections: [GraphQLSelection] {
                              return [
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
                                GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
                              ]
                            }

                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
                              self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                            }

                            public var __typename: String {
                              get {
                                return resultMap["__typename"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "__typename")
                              }
                            }

                            public var key: String {
                              get {
                                return resultMap["key"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "key")
                              }
                            }

                            public var storeAs: String {
                              get {
                                return resultMap["storeAs"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "storeAs")
                              }
                            }

                            public var type: EmbarkAPIGraphQLVariableGeneratedType {
                              get {
                                return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "type")
                              }
                            }

                            public var fragments: Fragments {
                              get {
                                return Fragments(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public struct Fragments {
                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                get {
                                  if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                  return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  guard let newValue = newValue else { return }
                                  resultMap += newValue.resultMap
                                }
                              }

                              public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment {
                                get {
                                  return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }

                public struct MutationResult: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkAPIGraphQLResult"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("key", type: .nonNull(.scalar(String.self))),
                      GraphQLField("as", type: .nonNull(.scalar(String.self))),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(key: String, `as`: String) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLResult", "key": key, "as": `as`])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var key: String {
                    get {
                      return resultMap["key"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "key")
                    }
                  }

                  public var `as`: String {
                    get {
                      return resultMap["as"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "as")
                    }
                  }
                }

                public struct MutationError: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkAPIGraphQLError"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("contains", type: .scalar(String.self)),
                      GraphQLField("next", type: .nonNull(.object(Next.selections))),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(contains: String? = nil, next: Next) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLError", "contains": contains, "next": next.resultMap])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var contains: String? {
                    get {
                      return resultMap["contains"] as? String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "contains")
                    }
                  }

                  public var next: Next {
                    get {
                      return Next(unsafeResultMap: resultMap["next"]! as! ResultMap)
                    }
                    set {
                      resultMap.updateValue(newValue.resultMap, forKey: "next")
                    }
                  }

                  public struct Next: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkLink"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("name", type: .nonNull(.scalar(String.self))),
                        GraphQLField("label", type: .nonNull(.scalar(String.self))),
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public init(name: String, label: String) {
                      self.init(unsafeResultMap: ["__typename": "EmbarkLink", "name": name, "label": label])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var name: String {
                      get {
                        return resultMap["name"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "name")
                      }
                    }

                    public var label: String {
                      get {
                        return resultMap["label"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "label")
                      }
                    }

                    public var fragments: Fragments {
                      get {
                        return Fragments(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public struct Fragments {
                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public var embarkLinkFragment: EmbarkLinkFragment {
                        get {
                          return EmbarkLinkFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }
                    }
                  }
                }
              }
            }
          }

          public struct Redirect: GraphQLSelectionSet {
            public static let possibleTypes: [String] = ["EmbarkRedirectUnaryExpression", "EmbarkRedirectBinaryExpression", "EmbarkRedirectMultipleExpressions"]

            public static var selections: [GraphQLSelection] {
              return [
                GraphQLTypeCase(
                  variants: ["EmbarkRedirectUnaryExpression": AsEmbarkRedirectUnaryExpression.selections, "EmbarkRedirectBinaryExpression": AsEmbarkRedirectBinaryExpression.selections, "EmbarkRedirectMultipleExpressions": AsEmbarkRedirectMultipleExpressions.selections],
                  default: [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  ]
                )
              ]
            }

            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public static func makeEmbarkRedirectUnaryExpression(unaryType: EmbarkExpressionTypeUnary, to: String, passedExpressionKey: String? = nil, passedExpressionValue: String? = nil) -> Redirect {
              return Redirect(unsafeResultMap: ["__typename": "EmbarkRedirectUnaryExpression", "unaryType": unaryType, "to": to, "passedExpressionKey": passedExpressionKey, "passedExpressionValue": passedExpressionValue])
            }

            public static func makeEmbarkRedirectBinaryExpression(binaryType: EmbarkExpressionTypeBinary, to: String, key: String, value: String, passedExpressionKey: String? = nil, passedExpressionValue: String? = nil) -> Redirect {
              return Redirect(unsafeResultMap: ["__typename": "EmbarkRedirectBinaryExpression", "binaryType": binaryType, "to": to, "key": key, "value": value, "passedExpressionKey": passedExpressionKey, "passedExpressionValue": passedExpressionValue])
            }

            public static func makeEmbarkRedirectMultipleExpressions(multipleType: EmbarkExpressionTypeMultiple, to: String, passedExpressionKey: String? = nil, passedExpressionValue: String? = nil, subExpressions: [AsEmbarkRedirectMultipleExpressions.SubExpression]) -> Redirect {
              return Redirect(unsafeResultMap: ["__typename": "EmbarkRedirectMultipleExpressions", "multipleType": multipleType, "to": to, "passedExpressionKey": passedExpressionKey, "passedExpressionValue": passedExpressionValue, "subExpressions": subExpressions.map { (value: AsEmbarkRedirectMultipleExpressions.SubExpression) -> ResultMap in value.resultMap }])
            }

            public var __typename: String {
              get {
                return resultMap["__typename"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "__typename")
              }
            }

            public var fragments: Fragments {
              get {
                return Fragments(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }

            public struct Fragments {
              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public var embarkRedirectFragment: EmbarkRedirectFragment {
                get {
                  return EmbarkRedirectFragment(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public var embarkRedirectSingle: EmbarkRedirectSingle {
                get {
                  return EmbarkRedirectSingle(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }
            }

            public var asEmbarkRedirectUnaryExpression: AsEmbarkRedirectUnaryExpression? {
              get {
                if !AsEmbarkRedirectUnaryExpression.possibleTypes.contains(__typename) { return nil }
                return AsEmbarkRedirectUnaryExpression(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap = newValue.resultMap
              }
            }

            public struct AsEmbarkRedirectUnaryExpression: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkRedirectUnaryExpression"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("type", alias: "unaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                  GraphQLField("to", type: .nonNull(.scalar(String.self))),
                  GraphQLField("passedExpressionKey", type: .scalar(String.self)),
                  GraphQLField("passedExpressionValue", type: .scalar(String.self)),
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public init(unaryType: EmbarkExpressionTypeUnary, to: String, passedExpressionKey: String? = nil, passedExpressionValue: String? = nil) {
                self.init(unsafeResultMap: ["__typename": "EmbarkRedirectUnaryExpression", "unaryType": unaryType, "to": to, "passedExpressionKey": passedExpressionKey, "passedExpressionValue": passedExpressionValue])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var unaryType: EmbarkExpressionTypeUnary {
                get {
                  return resultMap["unaryType"]! as! EmbarkExpressionTypeUnary
                }
                set {
                  resultMap.updateValue(newValue, forKey: "unaryType")
                }
              }

              public var to: String {
                get {
                  return resultMap["to"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "to")
                }
              }

              public var passedExpressionKey: String? {
                get {
                  return resultMap["passedExpressionKey"] as? String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "passedExpressionKey")
                }
              }

              public var passedExpressionValue: String? {
                get {
                  return resultMap["passedExpressionValue"] as? String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "passedExpressionValue")
                }
              }

              public var fragments: Fragments {
                get {
                  return Fragments(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public struct Fragments {
                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public var embarkRedirectFragment: EmbarkRedirectFragment {
                  get {
                    return EmbarkRedirectFragment(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }

                public var embarkRedirectSingle: EmbarkRedirectSingle {
                  get {
                    return EmbarkRedirectSingle(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }
              }
            }

            public var asEmbarkRedirectBinaryExpression: AsEmbarkRedirectBinaryExpression? {
              get {
                if !AsEmbarkRedirectBinaryExpression.possibleTypes.contains(__typename) { return nil }
                return AsEmbarkRedirectBinaryExpression(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap = newValue.resultMap
              }
            }

            public struct AsEmbarkRedirectBinaryExpression: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkRedirectBinaryExpression"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("type", alias: "binaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                  GraphQLField("to", type: .nonNull(.scalar(String.self))),
                  GraphQLField("key", type: .nonNull(.scalar(String.self))),
                  GraphQLField("value", type: .nonNull(.scalar(String.self))),
                  GraphQLField("passedExpressionKey", type: .scalar(String.self)),
                  GraphQLField("passedExpressionValue", type: .scalar(String.self)),
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public init(binaryType: EmbarkExpressionTypeBinary, to: String, key: String, value: String, passedExpressionKey: String? = nil, passedExpressionValue: String? = nil) {
                self.init(unsafeResultMap: ["__typename": "EmbarkRedirectBinaryExpression", "binaryType": binaryType, "to": to, "key": key, "value": value, "passedExpressionKey": passedExpressionKey, "passedExpressionValue": passedExpressionValue])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var binaryType: EmbarkExpressionTypeBinary {
                get {
                  return resultMap["binaryType"]! as! EmbarkExpressionTypeBinary
                }
                set {
                  resultMap.updateValue(newValue, forKey: "binaryType")
                }
              }

              public var to: String {
                get {
                  return resultMap["to"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "to")
                }
              }

              public var key: String {
                get {
                  return resultMap["key"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "key")
                }
              }

              public var value: String {
                get {
                  return resultMap["value"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "value")
                }
              }

              public var passedExpressionKey: String? {
                get {
                  return resultMap["passedExpressionKey"] as? String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "passedExpressionKey")
                }
              }

              public var passedExpressionValue: String? {
                get {
                  return resultMap["passedExpressionValue"] as? String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "passedExpressionValue")
                }
              }

              public var fragments: Fragments {
                get {
                  return Fragments(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public struct Fragments {
                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public var embarkRedirectFragment: EmbarkRedirectFragment {
                  get {
                    return EmbarkRedirectFragment(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }

                public var embarkRedirectSingle: EmbarkRedirectSingle {
                  get {
                    return EmbarkRedirectSingle(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }
              }
            }

            public var asEmbarkRedirectMultipleExpressions: AsEmbarkRedirectMultipleExpressions? {
              get {
                if !AsEmbarkRedirectMultipleExpressions.possibleTypes.contains(__typename) { return nil }
                return AsEmbarkRedirectMultipleExpressions(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap = newValue.resultMap
              }
            }

            public struct AsEmbarkRedirectMultipleExpressions: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkRedirectMultipleExpressions"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("type", alias: "multipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
                  GraphQLField("to", type: .nonNull(.scalar(String.self))),
                  GraphQLField("passedExpressionKey", type: .scalar(String.self)),
                  GraphQLField("passedExpressionValue", type: .scalar(String.self)),
                  GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public init(multipleType: EmbarkExpressionTypeMultiple, to: String, passedExpressionKey: String? = nil, passedExpressionValue: String? = nil, subExpressions: [SubExpression]) {
                self.init(unsafeResultMap: ["__typename": "EmbarkRedirectMultipleExpressions", "multipleType": multipleType, "to": to, "passedExpressionKey": passedExpressionKey, "passedExpressionValue": passedExpressionValue, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var multipleType: EmbarkExpressionTypeMultiple {
                get {
                  return resultMap["multipleType"]! as! EmbarkExpressionTypeMultiple
                }
                set {
                  resultMap.updateValue(newValue, forKey: "multipleType")
                }
              }

              public var to: String {
                get {
                  return resultMap["to"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "to")
                }
              }

              public var passedExpressionKey: String? {
                get {
                  return resultMap["passedExpressionKey"] as? String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "passedExpressionKey")
                }
              }

              public var passedExpressionValue: String? {
                get {
                  return resultMap["passedExpressionValue"] as? String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "passedExpressionValue")
                }
              }

              public var subExpressions: [SubExpression] {
                get {
                  return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
                }
                set {
                  resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
                }
              }

              public var fragments: Fragments {
                get {
                  return Fragments(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public struct Fragments {
                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public var embarkRedirectFragment: EmbarkRedirectFragment {
                  get {
                    return EmbarkRedirectFragment(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }

                public var embarkRedirectSingle: EmbarkRedirectSingle {
                  get {
                    return EmbarkRedirectSingle(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }
              }

              public struct SubExpression: GraphQLSelectionSet {
                public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

                public static var selections: [GraphQLSelection] {
                  return [
                    GraphQLTypeCase(
                      variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
                      default: [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      ]
                    )
                  ]
                }

                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
                  return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                }

                public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
                  return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                }

                public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> SubExpression {
                  return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
                }

                public var __typename: String {
                  get {
                    return resultMap["__typename"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "__typename")
                  }
                }

                public var fragments: Fragments {
                  get {
                    return Fragments(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }

                public struct Fragments {
                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public var expressionFragment: ExpressionFragment {
                    get {
                      return ExpressionFragment(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public var basicExpressionFragment: BasicExpressionFragment {
                    get {
                      return BasicExpressionFragment(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }
                }

                public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                  get {
                    if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                    return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                  }
                  set {
                    guard let newValue = newValue else { return }
                    resultMap = newValue.resultMap
                  }
                }

                public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                      GraphQLField("text", type: .scalar(String.self)),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var expressionUnaryType: EmbarkExpressionTypeUnary {
                    get {
                      return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                    }
                  }

                  public var text: String? {
                    get {
                      return resultMap["text"] as? String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "text")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var expressionFragment: ExpressionFragment {
                      get {
                        return ExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public var basicExpressionFragment: BasicExpressionFragment {
                      get {
                        return BasicExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }
                }

                public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                  get {
                    if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                    return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                  }
                  set {
                    guard let newValue = newValue else { return }
                    resultMap = newValue.resultMap
                  }
                }

                public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                      GraphQLField("key", type: .nonNull(.scalar(String.self))),
                      GraphQLField("value", type: .nonNull(.scalar(String.self))),
                      GraphQLField("text", type: .scalar(String.self)),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var expressionBinaryType: EmbarkExpressionTypeBinary {
                    get {
                      return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                    }
                  }

                  public var key: String {
                    get {
                      return resultMap["key"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "key")
                    }
                  }

                  public var value: String {
                    get {
                      return resultMap["value"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "value")
                    }
                  }

                  public var text: String? {
                    get {
                      return resultMap["text"] as? String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "text")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var expressionFragment: ExpressionFragment {
                      get {
                        return ExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public var basicExpressionFragment: BasicExpressionFragment {
                      get {
                        return BasicExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }
                }

                public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
                  get {
                    if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
                    return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
                  }
                  set {
                    guard let newValue = newValue else { return }
                    resultMap = newValue.resultMap
                  }
                }

                public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
                      GraphQLField("text", type: .scalar(String.self)),
                      GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var expressionMultipleType: EmbarkExpressionTypeMultiple {
                    get {
                      return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "expressionMultipleType")
                    }
                  }

                  public var text: String? {
                    get {
                      return resultMap["text"] as? String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "text")
                    }
                  }

                  public var subExpressions: [SubExpression] {
                    get {
                      return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
                    }
                    set {
                      resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var expressionFragment: ExpressionFragment {
                      get {
                        return ExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public var basicExpressionFragment: BasicExpressionFragment {
                      get {
                        return BasicExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }

                  public struct SubExpression: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLTypeCase(
                          variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
                          default: [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          ]
                        )
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
                      return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                    }

                    public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
                      return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                    }

                    public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> SubExpression {
                      return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var fragments: Fragments {
                      get {
                        return Fragments(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public struct Fragments {
                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public var basicExpressionFragment: BasicExpressionFragment {
                        get {
                          return BasicExpressionFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }
                    }

                    public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                      get {
                        if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                        return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                      }
                      set {
                        guard let newValue = newValue else { return }
                        resultMap = newValue.resultMap
                      }
                    }

                    public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                      public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                      public static var selections: [GraphQLSelection] {
                        return [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                          GraphQLField("text", type: .scalar(String.self)),
                        ]
                      }

                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                        self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                      }

                      public var __typename: String {
                        get {
                          return resultMap["__typename"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "__typename")
                        }
                      }

                      public var expressionUnaryType: EmbarkExpressionTypeUnary {
                        get {
                          return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                        }
                      }

                      public var text: String? {
                        get {
                          return resultMap["text"] as? String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "text")
                        }
                      }

                      public var fragments: Fragments {
                        get {
                          return Fragments(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public struct Fragments {
                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public var basicExpressionFragment: BasicExpressionFragment {
                          get {
                            return BasicExpressionFragment(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }
                      }
                    }

                    public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                      get {
                        if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                        return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                      }
                      set {
                        guard let newValue = newValue else { return }
                        resultMap = newValue.resultMap
                      }
                    }

                    public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                      public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                      public static var selections: [GraphQLSelection] {
                        return [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                          GraphQLField("key", type: .nonNull(.scalar(String.self))),
                          GraphQLField("value", type: .nonNull(.scalar(String.self))),
                          GraphQLField("text", type: .scalar(String.self)),
                        ]
                      }

                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                        self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                      }

                      public var __typename: String {
                        get {
                          return resultMap["__typename"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "__typename")
                        }
                      }

                      public var expressionBinaryType: EmbarkExpressionTypeBinary {
                        get {
                          return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                        }
                      }

                      public var key: String {
                        get {
                          return resultMap["key"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "key")
                        }
                      }

                      public var value: String {
                        get {
                          return resultMap["value"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "value")
                        }
                      }

                      public var text: String? {
                        get {
                          return resultMap["text"] as? String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "text")
                        }
                      }

                      public var fragments: Fragments {
                        get {
                          return Fragments(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public struct Fragments {
                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public var basicExpressionFragment: BasicExpressionFragment {
                          get {
                            return BasicExpressionFragment(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }
                      }
                    }

                    public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
                      get {
                        if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
                        return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
                      }
                      set {
                        guard let newValue = newValue else { return }
                        resultMap = newValue.resultMap
                      }
                    }

                    public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
                      public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

                      public static var selections: [GraphQLSelection] {
                        return [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
                          GraphQLField("text", type: .scalar(String.self)),
                          GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
                        ]
                      }

                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
                        self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
                      }

                      public var __typename: String {
                        get {
                          return resultMap["__typename"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "__typename")
                        }
                      }

                      public var expressionMultipleType: EmbarkExpressionTypeMultiple {
                        get {
                          return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "expressionMultipleType")
                        }
                      }

                      public var text: String? {
                        get {
                          return resultMap["text"] as? String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "text")
                        }
                      }

                      public var subExpressions: [SubExpression] {
                        get {
                          return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
                        }
                        set {
                          resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
                        }
                      }

                      public var fragments: Fragments {
                        get {
                          return Fragments(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public struct Fragments {
                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public var basicExpressionFragment: BasicExpressionFragment {
                          get {
                            return BasicExpressionFragment(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }
                      }

                      public struct SubExpression: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLTypeCase(
                              variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
                              default: [
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              ]
                            )
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
                          return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                        }

                        public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
                          return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                        }

                        public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> SubExpression {
                          return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var fragments: Fragments {
                          get {
                            return Fragments(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }

                        public struct Fragments {
                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public var basicExpressionFragment: BasicExpressionFragment {
                            get {
                              return BasicExpressionFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }
                        }

                        public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                          get {
                            if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                            return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                          }
                          set {
                            guard let newValue = newValue else { return }
                            resultMap = newValue.resultMap
                          }
                        }

                        public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                              GraphQLField("text", type: .scalar(String.self)),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var expressionUnaryType: EmbarkExpressionTypeUnary {
                            get {
                              return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                            }
                          }

                          public var text: String? {
                            get {
                              return resultMap["text"] as? String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "text")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var basicExpressionFragment: BasicExpressionFragment {
                              get {
                                return BasicExpressionFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }
                          }
                        }

                        public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                          get {
                            if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                            return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                          }
                          set {
                            guard let newValue = newValue else { return }
                            resultMap = newValue.resultMap
                          }
                        }

                        public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                              GraphQLField("key", type: .nonNull(.scalar(String.self))),
                              GraphQLField("value", type: .nonNull(.scalar(String.self))),
                              GraphQLField("text", type: .scalar(String.self)),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var expressionBinaryType: EmbarkExpressionTypeBinary {
                            get {
                              return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                            }
                          }

                          public var key: String {
                            get {
                              return resultMap["key"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "key")
                            }
                          }

                          public var value: String {
                            get {
                              return resultMap["value"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "value")
                            }
                          }

                          public var text: String? {
                            get {
                              return resultMap["text"] as? String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "text")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var basicExpressionFragment: BasicExpressionFragment {
                              get {
                                return BasicExpressionFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }
                          }
                        }

                        public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
                          get {
                            if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
                            return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
                          }
                          set {
                            guard let newValue = newValue else { return }
                            resultMap = newValue.resultMap
                          }
                        }

                        public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
                              GraphQLField("text", type: .scalar(String.self)),
                              GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var expressionMultipleType: EmbarkExpressionTypeMultiple {
                            get {
                              return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "expressionMultipleType")
                            }
                          }

                          public var text: String? {
                            get {
                              return resultMap["text"] as? String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "text")
                            }
                          }

                          public var subExpressions: [SubExpression] {
                            get {
                              return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
                            }
                            set {
                              resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var basicExpressionFragment: BasicExpressionFragment {
                              get {
                                return BasicExpressionFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }
                          }

                          public struct SubExpression: GraphQLSelectionSet {
                            public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

                            public static var selections: [GraphQLSelection] {
                              return [
                                GraphQLTypeCase(
                                  variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections],
                                  default: [
                                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  ]
                                )
                              ]
                            }

                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public static func makeEmbarkExpressionMultiple() -> SubExpression {
                              return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple"])
                            }

                            public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
                              return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                            }

                            public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
                              return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                            }

                            public var __typename: String {
                              get {
                                return resultMap["__typename"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "__typename")
                              }
                            }

                            public var fragments: Fragments {
                              get {
                                return Fragments(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public struct Fragments {
                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public var basicExpressionFragment: BasicExpressionFragment {
                                get {
                                  return BasicExpressionFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }
                            }

                            public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                              get {
                                if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                                return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap = newValue.resultMap
                              }
                            }

                            public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                              public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                              public static var selections: [GraphQLSelection] {
                                return [
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                                  GraphQLField("text", type: .scalar(String.self)),
                                ]
                              }

                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                                self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                              }

                              public var __typename: String {
                                get {
                                  return resultMap["__typename"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "__typename")
                                }
                              }

                              public var expressionUnaryType: EmbarkExpressionTypeUnary {
                                get {
                                  return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                                }
                              }

                              public var text: String? {
                                get {
                                  return resultMap["text"] as? String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "text")
                                }
                              }

                              public var fragments: Fragments {
                                get {
                                  return Fragments(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public struct Fragments {
                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public var basicExpressionFragment: BasicExpressionFragment {
                                  get {
                                    return BasicExpressionFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    resultMap += newValue.resultMap
                                  }
                                }
                              }
                            }

                            public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                              get {
                                if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                                return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap = newValue.resultMap
                              }
                            }

                            public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                              public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                              public static var selections: [GraphQLSelection] {
                                return [
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                                  GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("value", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("text", type: .scalar(String.self)),
                                ]
                              }

                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                                self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                              }

                              public var __typename: String {
                                get {
                                  return resultMap["__typename"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "__typename")
                                }
                              }

                              public var expressionBinaryType: EmbarkExpressionTypeBinary {
                                get {
                                  return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                                }
                              }

                              public var key: String {
                                get {
                                  return resultMap["key"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "key")
                                }
                              }

                              public var value: String {
                                get {
                                  return resultMap["value"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "value")
                                }
                              }

                              public var text: String? {
                                get {
                                  return resultMap["text"] as? String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "text")
                                }
                              }

                              public var fragments: Fragments {
                                get {
                                  return Fragments(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public struct Fragments {
                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public var basicExpressionFragment: BasicExpressionFragment {
                                  get {
                                    return BasicExpressionFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    resultMap += newValue.resultMap
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }

          public struct Track: GraphQLSelectionSet {
            public static let possibleTypes: [String] = ["EmbarkTrack"]

            public static var selections: [GraphQLSelection] {
              return [
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("eventName", type: .nonNull(.scalar(String.self))),
                GraphQLField("eventKeys", type: .nonNull(.list(.scalar(String.self)))),
                GraphQLField("includeAllKeys", type: .nonNull(.scalar(Bool.self))),
                GraphQLField("customData", type: .scalar(String.self)),
              ]
            }

            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public init(eventName: String, eventKeys: [String?], includeAllKeys: Bool, customData: String? = nil) {
              self.init(unsafeResultMap: ["__typename": "EmbarkTrack", "eventName": eventName, "eventKeys": eventKeys, "includeAllKeys": includeAllKeys, "customData": customData])
            }

            public var __typename: String {
              get {
                return resultMap["__typename"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "__typename")
              }
            }

            public var eventName: String {
              get {
                return resultMap["eventName"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "eventName")
              }
            }

            public var eventKeys: [String?] {
              get {
                return resultMap["eventKeys"]! as! [String?]
              }
              set {
                resultMap.updateValue(newValue, forKey: "eventKeys")
              }
            }

            public var includeAllKeys: Bool {
              get {
                return resultMap["includeAllKeys"]! as! Bool
              }
              set {
                resultMap.updateValue(newValue, forKey: "includeAllKeys")
              }
            }

            public var customData: String? {
              get {
                return resultMap["customData"] as? String
              }
              set {
                resultMap.updateValue(newValue, forKey: "customData")
              }
            }
          }

          public struct Action: GraphQLSelectionSet {
            public static let possibleTypes: [String] = ["EmbarkExternalInsuranceProviderAction", "EmbarkPreviousInsuranceProviderAction", "EmbarkNumberActionSet", "EmbarkTextActionSet", "EmbarkTextAction", "EmbarkSelectAction", "EmbarkNumberAction", "EmbarkMultiAction", "EmbarkDatePickerAction", "EmbarkAddressAutocompleteAction", "EmbarkAudioRecorderAction"]

            public static var selections: [GraphQLSelection] {
              return [
                GraphQLTypeCase(
                  variants: ["EmbarkMultiAction": AsEmbarkMultiAction.selections, "EmbarkAudioRecorderAction": AsEmbarkAudioRecorderAction.selections, "EmbarkTextAction": AsEmbarkTextAction.selections, "EmbarkNumberAction": AsEmbarkNumberAction.selections, "EmbarkAddressAutocompleteAction": AsEmbarkAddressAutocompleteAction.selections, "EmbarkTextActionSet": AsEmbarkTextActionSet.selections, "EmbarkSelectAction": AsEmbarkSelectAction.selections, "EmbarkDatePickerAction": AsEmbarkDatePickerAction.selections, "EmbarkExternalInsuranceProviderAction": AsEmbarkExternalInsuranceProviderAction.selections, "EmbarkPreviousInsuranceProviderAction": AsEmbarkPreviousInsuranceProviderAction.selections, "EmbarkNumberActionSet": AsEmbarkNumberActionSet.selections],
                  default: [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("component", type: .nonNull(.scalar(String.self))),
                  ]
                )
              ]
            }

            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public static func makeEmbarkMultiAction(multiActionData: AsEmbarkMultiAction.MultiActionDatum, component: String) -> Action {
              return Action(unsafeResultMap: ["__typename": "EmbarkMultiAction", "multiActionData": multiActionData.resultMap, "component": component])
            }

            public static func makeEmbarkAudioRecorderAction(component: String, audioRecorderData: AsEmbarkAudioRecorderAction.AudioRecorderDatum) -> Action {
              return Action(unsafeResultMap: ["__typename": "EmbarkAudioRecorderAction", "component": component, "audioRecorderData": audioRecorderData.resultMap])
            }

            public static func makeEmbarkTextAction(component: String, textActionData: AsEmbarkTextAction.TextActionDatum) -> Action {
              return Action(unsafeResultMap: ["__typename": "EmbarkTextAction", "component": component, "textActionData": textActionData.resultMap])
            }

            public static func makeEmbarkNumberAction(component: String, numberActionData: AsEmbarkNumberAction.NumberActionDatum) -> Action {
              return Action(unsafeResultMap: ["__typename": "EmbarkNumberAction", "component": component, "numberActionData": numberActionData.resultMap])
            }

            public static func makeEmbarkAddressAutocompleteAction(component: String, addressAutocompleteActionData: AsEmbarkAddressAutocompleteAction.AddressAutocompleteActionDatum) -> Action {
              return Action(unsafeResultMap: ["__typename": "EmbarkAddressAutocompleteAction", "component": component, "addressAutocompleteActionData": addressAutocompleteActionData.resultMap])
            }

            public static func makeEmbarkTextActionSet(component: String, textActionSetData: AsEmbarkTextActionSet.TextActionSetDatum? = nil) -> Action {
              return Action(unsafeResultMap: ["__typename": "EmbarkTextActionSet", "component": component, "textActionSetData": textActionSetData.flatMap { (value: AsEmbarkTextActionSet.TextActionSetDatum) -> ResultMap in value.resultMap }])
            }

            public static func makeEmbarkSelectAction(component: String, selectActionData: AsEmbarkSelectAction.SelectActionDatum) -> Action {
              return Action(unsafeResultMap: ["__typename": "EmbarkSelectAction", "component": component, "selectActionData": selectActionData.resultMap])
            }

            public static func makeEmbarkDatePickerAction(component: String, next: AsEmbarkDatePickerAction.Next, storeKey: String, label: String, tooltip: AsEmbarkDatePickerAction.Tooltip? = nil) -> Action {
              return Action(unsafeResultMap: ["__typename": "EmbarkDatePickerAction", "component": component, "next": next.resultMap, "storeKey": storeKey, "label": label, "tooltip": tooltip.flatMap { (value: AsEmbarkDatePickerAction.Tooltip) -> ResultMap in value.resultMap }])
            }

            public static func makeEmbarkExternalInsuranceProviderAction(component: String, externalInsuranceProviderData: AsEmbarkExternalInsuranceProviderAction.ExternalInsuranceProviderDatum) -> Action {
              return Action(unsafeResultMap: ["__typename": "EmbarkExternalInsuranceProviderAction", "component": component, "externalInsuranceProviderData": externalInsuranceProviderData.resultMap])
            }

            public static func makeEmbarkPreviousInsuranceProviderAction(component: String, previousInsuranceProviderData: AsEmbarkPreviousInsuranceProviderAction.PreviousInsuranceProviderDatum) -> Action {
              return Action(unsafeResultMap: ["__typename": "EmbarkPreviousInsuranceProviderAction", "component": component, "previousInsuranceProviderData": previousInsuranceProviderData.resultMap])
            }

            public static func makeEmbarkNumberActionSet(component: String, data: AsEmbarkNumberActionSet.Datum? = nil) -> Action {
              return Action(unsafeResultMap: ["__typename": "EmbarkNumberActionSet", "component": component, "data": data.flatMap { (value: AsEmbarkNumberActionSet.Datum) -> ResultMap in value.resultMap }])
            }

            public var __typename: String {
              get {
                return resultMap["__typename"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "__typename")
              }
            }

            public var component: String {
              get {
                return resultMap["component"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "component")
              }
            }

            public var asEmbarkMultiAction: AsEmbarkMultiAction? {
              get {
                if !AsEmbarkMultiAction.possibleTypes.contains(__typename) { return nil }
                return AsEmbarkMultiAction(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap = newValue.resultMap
              }
            }

            public struct AsEmbarkMultiAction: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkMultiAction"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("data", alias: "multiActionData", type: .nonNull(.object(MultiActionDatum.selections))),
                  GraphQLField("component", type: .nonNull(.scalar(String.self))),
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public init(multiActionData: MultiActionDatum, component: String) {
                self.init(unsafeResultMap: ["__typename": "EmbarkMultiAction", "multiActionData": multiActionData.resultMap, "component": component])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var multiActionData: MultiActionDatum {
                get {
                  return MultiActionDatum(unsafeResultMap: resultMap["multiActionData"]! as! ResultMap)
                }
                set {
                  resultMap.updateValue(newValue.resultMap, forKey: "multiActionData")
                }
              }

              public var component: String {
                get {
                  return resultMap["component"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "component")
                }
              }

              public struct MultiActionDatum: GraphQLSelectionSet {
                public static let possibleTypes: [String] = ["EmbarkMultiActionData"]

                public static var selections: [GraphQLSelection] {
                  return [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("addLabel", type: .scalar(String.self)),
                    GraphQLField("key", type: .scalar(String.self)),
                    GraphQLField("maxAmount", type: .nonNull(.scalar(String.self))),
                    GraphQLField("link", type: .nonNull(.object(Link.selections))),
                    GraphQLField("components", type: .nonNull(.list(.nonNull(.object(Component.selections))))),
                  ]
                }

                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public init(addLabel: String? = nil, key: String? = nil, maxAmount: String, link: Link, components: [Component]) {
                  self.init(unsafeResultMap: ["__typename": "EmbarkMultiActionData", "addLabel": addLabel, "key": key, "maxAmount": maxAmount, "link": link.resultMap, "components": components.map { (value: Component) -> ResultMap in value.resultMap }])
                }

                public var __typename: String {
                  get {
                    return resultMap["__typename"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "__typename")
                  }
                }

                public var addLabel: String? {
                  get {
                    return resultMap["addLabel"] as? String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "addLabel")
                  }
                }

                public var key: String? {
                  get {
                    return resultMap["key"] as? String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "key")
                  }
                }

                public var maxAmount: String {
                  get {
                    return resultMap["maxAmount"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "maxAmount")
                  }
                }

                public var link: Link {
                  get {
                    return Link(unsafeResultMap: resultMap["link"]! as! ResultMap)
                  }
                  set {
                    resultMap.updateValue(newValue.resultMap, forKey: "link")
                  }
                }

                public var components: [Component] {
                  get {
                    return (resultMap["components"] as! [ResultMap]).map { (value: ResultMap) -> Component in Component(unsafeResultMap: value) }
                  }
                  set {
                    resultMap.updateValue(newValue.map { (value: Component) -> ResultMap in value.resultMap }, forKey: "components")
                  }
                }

                public struct Link: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkLink"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("name", type: .nonNull(.scalar(String.self))),
                      GraphQLField("label", type: .nonNull(.scalar(String.self))),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(name: String, label: String) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkLink", "name": name, "label": label])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var name: String {
                    get {
                      return resultMap["name"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "name")
                    }
                  }

                  public var label: String {
                    get {
                      return resultMap["label"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "label")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var embarkLinkFragment: EmbarkLinkFragment {
                      get {
                        return EmbarkLinkFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }
                }

                public struct Component: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkMultiActionNumberAction", "EmbarkDropdownAction", "EmbarkSwitchAction"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLTypeCase(
                        variants: ["EmbarkMultiActionNumberAction": AsEmbarkMultiActionNumberAction.selections, "EmbarkDropdownAction": AsEmbarkDropdownAction.selections, "EmbarkSwitchAction": AsEmbarkSwitchAction.selections],
                        default: [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        ]
                      )
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public static func makeEmbarkMultiActionNumberAction(numberActionData: AsEmbarkMultiActionNumberAction.NumberActionDatum) -> Component {
                    return Component(unsafeResultMap: ["__typename": "EmbarkMultiActionNumberAction", "numberActionData": numberActionData.resultMap])
                  }

                  public static func makeEmbarkDropdownAction(dropDownActionData: AsEmbarkDropdownAction.DropDownActionDatum) -> Component {
                    return Component(unsafeResultMap: ["__typename": "EmbarkDropdownAction", "dropDownActionData": dropDownActionData.resultMap])
                  }

                  public static func makeEmbarkSwitchAction(switchActionData: AsEmbarkSwitchAction.SwitchActionDatum) -> Component {
                    return Component(unsafeResultMap: ["__typename": "EmbarkSwitchAction", "switchActionData": switchActionData.resultMap])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var asEmbarkMultiActionNumberAction: AsEmbarkMultiActionNumberAction? {
                    get {
                      if !AsEmbarkMultiActionNumberAction.possibleTypes.contains(__typename) { return nil }
                      return AsEmbarkMultiActionNumberAction(unsafeResultMap: resultMap)
                    }
                    set {
                      guard let newValue = newValue else { return }
                      resultMap = newValue.resultMap
                    }
                  }

                  public struct AsEmbarkMultiActionNumberAction: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkMultiActionNumberAction"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("data", alias: "numberActionData", type: .nonNull(.object(NumberActionDatum.selections))),
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public init(numberActionData: NumberActionDatum) {
                      self.init(unsafeResultMap: ["__typename": "EmbarkMultiActionNumberAction", "numberActionData": numberActionData.resultMap])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var numberActionData: NumberActionDatum {
                      get {
                        return NumberActionDatum(unsafeResultMap: resultMap["numberActionData"]! as! ResultMap)
                      }
                      set {
                        resultMap.updateValue(newValue.resultMap, forKey: "numberActionData")
                      }
                    }

                    public struct NumberActionDatum: GraphQLSelectionSet {
                      public static let possibleTypes: [String] = ["EmbarkMultiActionNumberActionData"]

                      public static var selections: [GraphQLSelection] {
                        return [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("placeholder", type: .nonNull(.scalar(String.self))),
                          GraphQLField("key", type: .nonNull(.scalar(String.self))),
                          GraphQLField("label", type: .scalar(String.self)),
                          GraphQLField("unit", type: .scalar(String.self)),
                        ]
                      }

                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public init(placeholder: String, key: String, label: String? = nil, unit: String? = nil) {
                        self.init(unsafeResultMap: ["__typename": "EmbarkMultiActionNumberActionData", "placeholder": placeholder, "key": key, "label": label, "unit": unit])
                      }

                      public var __typename: String {
                        get {
                          return resultMap["__typename"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "__typename")
                        }
                      }

                      public var placeholder: String {
                        get {
                          return resultMap["placeholder"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "placeholder")
                        }
                      }

                      public var key: String {
                        get {
                          return resultMap["key"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "key")
                        }
                      }

                      public var label: String? {
                        get {
                          return resultMap["label"] as? String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "label")
                        }
                      }

                      public var unit: String? {
                        get {
                          return resultMap["unit"] as? String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "unit")
                        }
                      }
                    }
                  }

                  public var asEmbarkDropdownAction: AsEmbarkDropdownAction? {
                    get {
                      if !AsEmbarkDropdownAction.possibleTypes.contains(__typename) { return nil }
                      return AsEmbarkDropdownAction(unsafeResultMap: resultMap)
                    }
                    set {
                      guard let newValue = newValue else { return }
                      resultMap = newValue.resultMap
                    }
                  }

                  public struct AsEmbarkDropdownAction: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkDropdownAction"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("data", alias: "dropDownActionData", type: .nonNull(.object(DropDownActionDatum.selections))),
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public init(dropDownActionData: DropDownActionDatum) {
                      self.init(unsafeResultMap: ["__typename": "EmbarkDropdownAction", "dropDownActionData": dropDownActionData.resultMap])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var dropDownActionData: DropDownActionDatum {
                      get {
                        return DropDownActionDatum(unsafeResultMap: resultMap["dropDownActionData"]! as! ResultMap)
                      }
                      set {
                        resultMap.updateValue(newValue.resultMap, forKey: "dropDownActionData")
                      }
                    }

                    public struct DropDownActionDatum: GraphQLSelectionSet {
                      public static let possibleTypes: [String] = ["EmbarkDropdownActionData"]

                      public static var selections: [GraphQLSelection] {
                        return [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("label", type: .nonNull(.scalar(String.self))),
                          GraphQLField("key", type: .nonNull(.scalar(String.self))),
                          GraphQLField("options", type: .nonNull(.list(.nonNull(.object(Option.selections))))),
                        ]
                      }

                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public init(label: String, key: String, options: [Option]) {
                        self.init(unsafeResultMap: ["__typename": "EmbarkDropdownActionData", "label": label, "key": key, "options": options.map { (value: Option) -> ResultMap in value.resultMap }])
                      }

                      public var __typename: String {
                        get {
                          return resultMap["__typename"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "__typename")
                        }
                      }

                      public var label: String {
                        get {
                          return resultMap["label"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "label")
                        }
                      }

                      public var key: String {
                        get {
                          return resultMap["key"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "key")
                        }
                      }

                      public var options: [Option] {
                        get {
                          return (resultMap["options"] as! [ResultMap]).map { (value: ResultMap) -> Option in Option(unsafeResultMap: value) }
                        }
                        set {
                          resultMap.updateValue(newValue.map { (value: Option) -> ResultMap in value.resultMap }, forKey: "options")
                        }
                      }

                      public struct Option: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkDropdownOption"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("value", type: .nonNull(.scalar(String.self))),
                            GraphQLField("text", type: .nonNull(.scalar(String.self))),
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public init(value: String, text: String) {
                          self.init(unsafeResultMap: ["__typename": "EmbarkDropdownOption", "value": value, "text": text])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var value: String {
                          get {
                            return resultMap["value"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "value")
                          }
                        }

                        public var text: String {
                          get {
                            return resultMap["text"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "text")
                          }
                        }
                      }
                    }
                  }

                  public var asEmbarkSwitchAction: AsEmbarkSwitchAction? {
                    get {
                      if !AsEmbarkSwitchAction.possibleTypes.contains(__typename) { return nil }
                      return AsEmbarkSwitchAction(unsafeResultMap: resultMap)
                    }
                    set {
                      guard let newValue = newValue else { return }
                      resultMap = newValue.resultMap
                    }
                  }

                  public struct AsEmbarkSwitchAction: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkSwitchAction"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("data", alias: "switchActionData", type: .nonNull(.object(SwitchActionDatum.selections))),
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public init(switchActionData: SwitchActionDatum) {
                      self.init(unsafeResultMap: ["__typename": "EmbarkSwitchAction", "switchActionData": switchActionData.resultMap])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var switchActionData: SwitchActionDatum {
                      get {
                        return SwitchActionDatum(unsafeResultMap: resultMap["switchActionData"]! as! ResultMap)
                      }
                      set {
                        resultMap.updateValue(newValue.resultMap, forKey: "switchActionData")
                      }
                    }

                    public struct SwitchActionDatum: GraphQLSelectionSet {
                      public static let possibleTypes: [String] = ["EmbarkSwitchActionData"]

                      public static var selections: [GraphQLSelection] {
                        return [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("label", type: .nonNull(.scalar(String.self))),
                          GraphQLField("key", type: .nonNull(.scalar(String.self))),
                          GraphQLField("defaultValue", type: .nonNull(.scalar(Bool.self))),
                        ]
                      }

                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public init(label: String, key: String, defaultValue: Bool) {
                        self.init(unsafeResultMap: ["__typename": "EmbarkSwitchActionData", "label": label, "key": key, "defaultValue": defaultValue])
                      }

                      public var __typename: String {
                        get {
                          return resultMap["__typename"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "__typename")
                        }
                      }

                      public var label: String {
                        get {
                          return resultMap["label"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "label")
                        }
                      }

                      public var key: String {
                        get {
                          return resultMap["key"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "key")
                        }
                      }

                      public var defaultValue: Bool {
                        get {
                          return resultMap["defaultValue"]! as! Bool
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "defaultValue")
                        }
                      }
                    }
                  }
                }
              }
            }

            public var asEmbarkAudioRecorderAction: AsEmbarkAudioRecorderAction? {
              get {
                if !AsEmbarkAudioRecorderAction.possibleTypes.contains(__typename) { return nil }
                return AsEmbarkAudioRecorderAction(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap = newValue.resultMap
              }
            }

            public struct AsEmbarkAudioRecorderAction: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkAudioRecorderAction"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("component", type: .nonNull(.scalar(String.self))),
                  GraphQLField("data", alias: "audioRecorderData", type: .nonNull(.object(AudioRecorderDatum.selections))),
                  GraphQLField("component", type: .nonNull(.scalar(String.self))),
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public init(component: String, audioRecorderData: AudioRecorderDatum) {
                self.init(unsafeResultMap: ["__typename": "EmbarkAudioRecorderAction", "component": component, "audioRecorderData": audioRecorderData.resultMap])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var component: String {
                get {
                  return resultMap["component"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "component")
                }
              }

              public var audioRecorderData: AudioRecorderDatum {
                get {
                  return AudioRecorderDatum(unsafeResultMap: resultMap["audioRecorderData"]! as! ResultMap)
                }
                set {
                  resultMap.updateValue(newValue.resultMap, forKey: "audioRecorderData")
                }
              }

              public struct AudioRecorderDatum: GraphQLSelectionSet {
                public static let possibleTypes: [String] = ["EmbarkAudioRecorderActionData"]

                public static var selections: [GraphQLSelection] {
                  return [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("storeKey", type: .nonNull(.scalar(String.self))),
                    GraphQLField("label", type: .nonNull(.scalar(String.self))),
                    GraphQLField("next", type: .nonNull(.object(Next.selections))),
                  ]
                }

                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public init(storeKey: String, label: String, next: Next) {
                  self.init(unsafeResultMap: ["__typename": "EmbarkAudioRecorderActionData", "storeKey": storeKey, "label": label, "next": next.resultMap])
                }

                public var __typename: String {
                  get {
                    return resultMap["__typename"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "__typename")
                  }
                }

                public var storeKey: String {
                  get {
                    return resultMap["storeKey"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "storeKey")
                  }
                }

                public var label: String {
                  get {
                    return resultMap["label"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "label")
                  }
                }

                public var next: Next {
                  get {
                    return Next(unsafeResultMap: resultMap["next"]! as! ResultMap)
                  }
                  set {
                    resultMap.updateValue(newValue.resultMap, forKey: "next")
                  }
                }

                public struct Next: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkLink"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("name", type: .nonNull(.scalar(String.self))),
                      GraphQLField("label", type: .nonNull(.scalar(String.self))),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(name: String, label: String) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkLink", "name": name, "label": label])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var name: String {
                    get {
                      return resultMap["name"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "name")
                    }
                  }

                  public var label: String {
                    get {
                      return resultMap["label"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "label")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var embarkLinkFragment: EmbarkLinkFragment {
                      get {
                        return EmbarkLinkFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }
                }
              }
            }

            public var asEmbarkTextAction: AsEmbarkTextAction? {
              get {
                if !AsEmbarkTextAction.possibleTypes.contains(__typename) { return nil }
                return AsEmbarkTextAction(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap = newValue.resultMap
              }
            }

            public struct AsEmbarkTextAction: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkTextAction"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("component", type: .nonNull(.scalar(String.self))),
                  GraphQLField("component", type: .nonNull(.scalar(String.self))),
                  GraphQLField("data", alias: "textActionData", type: .nonNull(.object(TextActionDatum.selections))),
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public init(component: String, textActionData: TextActionDatum) {
                self.init(unsafeResultMap: ["__typename": "EmbarkTextAction", "component": component, "textActionData": textActionData.resultMap])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var component: String {
                get {
                  return resultMap["component"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "component")
                }
              }

              public var textActionData: TextActionDatum {
                get {
                  return TextActionDatum(unsafeResultMap: resultMap["textActionData"]! as! ResultMap)
                }
                set {
                  resultMap.updateValue(newValue.resultMap, forKey: "textActionData")
                }
              }

              public struct TextActionDatum: GraphQLSelectionSet {
                public static let possibleTypes: [String] = ["EmbarkTextActionData"]

                public static var selections: [GraphQLSelection] {
                  return [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("key", type: .nonNull(.scalar(String.self))),
                    GraphQLField("placeholder", type: .nonNull(.scalar(String.self))),
                    GraphQLField("mask", type: .scalar(String.self)),
                    GraphQLField("api", type: .object(Api.selections)),
                    GraphQLField("link", type: .nonNull(.object(Link.selections))),
                  ]
                }

                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public init(key: String, placeholder: String, mask: String? = nil, api: Api? = nil, link: Link) {
                  self.init(unsafeResultMap: ["__typename": "EmbarkTextActionData", "key": key, "placeholder": placeholder, "mask": mask, "api": api.flatMap { (value: Api) -> ResultMap in value.resultMap }, "link": link.resultMap])
                }

                public var __typename: String {
                  get {
                    return resultMap["__typename"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "__typename")
                  }
                }

                public var key: String {
                  get {
                    return resultMap["key"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "key")
                  }
                }

                public var placeholder: String {
                  get {
                    return resultMap["placeholder"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "placeholder")
                  }
                }

                public var mask: String? {
                  get {
                    return resultMap["mask"] as? String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "mask")
                  }
                }

                public var api: Api? {
                  get {
                    return (resultMap["api"] as? ResultMap).flatMap { Api(unsafeResultMap: $0) }
                  }
                  set {
                    resultMap.updateValue(newValue?.resultMap, forKey: "api")
                  }
                }

                public var link: Link {
                  get {
                    return Link(unsafeResultMap: resultMap["link"]! as! ResultMap)
                  }
                  set {
                    resultMap.updateValue(newValue.resultMap, forKey: "link")
                  }
                }

                public struct Api: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkApiPersonalInformation", "EmbarkApiHouseInformation", "EmbarkApiCreateQuote", "EmbarkApiGraphQLQuery", "EmbarkApiGraphQLMutation"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLTypeCase(
                        variants: ["EmbarkApiGraphQLQuery": AsEmbarkApiGraphQlQuery.selections, "EmbarkApiGraphQLMutation": AsEmbarkApiGraphQlMutation.selections],
                        default: [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        ]
                      )
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public static func makeEmbarkApiPersonalInformation() -> Api {
                    return Api(unsafeResultMap: ["__typename": "EmbarkApiPersonalInformation"])
                  }

                  public static func makeEmbarkApiHouseInformation() -> Api {
                    return Api(unsafeResultMap: ["__typename": "EmbarkApiHouseInformation"])
                  }

                  public static func makeEmbarkApiCreateQuote() -> Api {
                    return Api(unsafeResultMap: ["__typename": "EmbarkApiCreateQuote"])
                  }

                  public static func makeEmbarkApiGraphQLQuery(data: AsEmbarkApiGraphQlQuery.Datum) -> Api {
                    return Api(unsafeResultMap: ["__typename": "EmbarkApiGraphQLQuery", "data": data.resultMap])
                  }

                  public static func makeEmbarkApiGraphQLMutation(data: AsEmbarkApiGraphQlMutation.Datum) -> Api {
                    return Api(unsafeResultMap: ["__typename": "EmbarkApiGraphQLMutation", "data": data.resultMap])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var apiFragment: ApiFragment {
                      get {
                        return ApiFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }

                  public var asEmbarkApiGraphQlQuery: AsEmbarkApiGraphQlQuery? {
                    get {
                      if !AsEmbarkApiGraphQlQuery.possibleTypes.contains(__typename) { return nil }
                      return AsEmbarkApiGraphQlQuery(unsafeResultMap: resultMap)
                    }
                    set {
                      guard let newValue = newValue else { return }
                      resultMap = newValue.resultMap
                    }
                  }

                  public struct AsEmbarkApiGraphQlQuery: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkApiGraphQLQuery"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("data", type: .nonNull(.object(Datum.selections))),
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public init(data: Datum) {
                      self.init(unsafeResultMap: ["__typename": "EmbarkApiGraphQLQuery", "data": data.resultMap])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var data: Datum {
                      get {
                        return Datum(unsafeResultMap: resultMap["data"]! as! ResultMap)
                      }
                      set {
                        resultMap.updateValue(newValue.resultMap, forKey: "data")
                      }
                    }

                    public var fragments: Fragments {
                      get {
                        return Fragments(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public struct Fragments {
                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public var apiFragment: ApiFragment {
                        get {
                          return ApiFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }
                    }

                    public struct Datum: GraphQLSelectionSet {
                      public static let possibleTypes: [String] = ["EmbarkApiGraphQLQueryData"]

                      public static var selections: [GraphQLSelection] {
                        return [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("next", type: .object(Next.selections)),
                          GraphQLField("query", type: .nonNull(.scalar(String.self))),
                          GraphQLField("variables", type: .nonNull(.list(.nonNull(.object(Variable.selections))))),
                          GraphQLField("results", alias: "queryResults", type: .nonNull(.list(.nonNull(.object(QueryResult.selections))))),
                          GraphQLField("errors", alias: "queryErrors", type: .nonNull(.list(.nonNull(.object(QueryError.selections))))),
                        ]
                      }

                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public init(next: Next? = nil, query: String, variables: [Variable], queryResults: [QueryResult], queryErrors: [QueryError]) {
                        self.init(unsafeResultMap: ["__typename": "EmbarkApiGraphQLQueryData", "next": next.flatMap { (value: Next) -> ResultMap in value.resultMap }, "query": query, "variables": variables.map { (value: Variable) -> ResultMap in value.resultMap }, "queryResults": queryResults.map { (value: QueryResult) -> ResultMap in value.resultMap }, "queryErrors": queryErrors.map { (value: QueryError) -> ResultMap in value.resultMap }])
                      }

                      public var __typename: String {
                        get {
                          return resultMap["__typename"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "__typename")
                        }
                      }

                      public var next: Next? {
                        get {
                          return (resultMap["next"] as? ResultMap).flatMap { Next(unsafeResultMap: $0) }
                        }
                        set {
                          resultMap.updateValue(newValue?.resultMap, forKey: "next")
                        }
                      }

                      public var query: String {
                        get {
                          return resultMap["query"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "query")
                        }
                      }

                      public var variables: [Variable] {
                        get {
                          return (resultMap["variables"] as! [ResultMap]).map { (value: ResultMap) -> Variable in Variable(unsafeResultMap: value) }
                        }
                        set {
                          resultMap.updateValue(newValue.map { (value: Variable) -> ResultMap in value.resultMap }, forKey: "variables")
                        }
                      }

                      public var queryResults: [QueryResult] {
                        get {
                          return (resultMap["queryResults"] as! [ResultMap]).map { (value: ResultMap) -> QueryResult in QueryResult(unsafeResultMap: value) }
                        }
                        set {
                          resultMap.updateValue(newValue.map { (value: QueryResult) -> ResultMap in value.resultMap }, forKey: "queryResults")
                        }
                      }

                      public var queryErrors: [QueryError] {
                        get {
                          return (resultMap["queryErrors"] as! [ResultMap]).map { (value: ResultMap) -> QueryError in QueryError(unsafeResultMap: value) }
                        }
                        set {
                          resultMap.updateValue(newValue.map { (value: QueryError) -> ResultMap in value.resultMap }, forKey: "queryErrors")
                        }
                      }

                      public struct Next: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkLink"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("name", type: .nonNull(.scalar(String.self))),
                            GraphQLField("label", type: .nonNull(.scalar(String.self))),
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public init(name: String, label: String) {
                          self.init(unsafeResultMap: ["__typename": "EmbarkLink", "name": name, "label": label])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var name: String {
                          get {
                            return resultMap["name"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "name")
                          }
                        }

                        public var label: String {
                          get {
                            return resultMap["label"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "label")
                          }
                        }

                        public var fragments: Fragments {
                          get {
                            return Fragments(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }

                        public struct Fragments {
                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public var embarkLinkFragment: EmbarkLinkFragment {
                            get {
                              return EmbarkLinkFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }
                        }
                      }

                      public struct Variable: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable", "EmbarkAPIGraphQLGeneratedVariable", "EmbarkAPIGraphQLMultiActionVariable", "EmbarkAPIGraphQLConstantVariable"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLTypeCase(
                              variants: ["EmbarkAPIGraphQLSingleVariable": AsEmbarkApiGraphQlSingleVariable.selections, "EmbarkAPIGraphQLGeneratedVariable": AsEmbarkApiGraphQlGeneratedVariable.selections, "EmbarkAPIGraphQLMultiActionVariable": AsEmbarkApiGraphQlMultiActionVariable.selections],
                              default: [
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              ]
                            )
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public static func makeEmbarkAPIGraphQLConstantVariable() -> Variable {
                          return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLConstantVariable"])
                        }

                        public static func makeEmbarkAPIGraphQLSingleVariable(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) -> Variable {
                          return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                        }

                        public static func makeEmbarkAPIGraphQLGeneratedVariable(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) -> Variable {
                          return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                        }

                        public static func makeEmbarkAPIGraphQLMultiActionVariable(key: String, variables: [AsEmbarkApiGraphQlMultiActionVariable.Variable]) -> Variable {
                          return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: AsEmbarkApiGraphQlMultiActionVariable.Variable) -> ResultMap in value.resultMap }])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var fragments: Fragments {
                          get {
                            return Fragments(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }

                        public struct Fragments {
                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public var apiVariablesFragment: ApiVariablesFragment {
                            get {
                              return ApiVariablesFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                            get {
                              if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                              return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              guard let newValue = newValue else { return }
                              resultMap += newValue.resultMap
                            }
                          }

                          public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                            get {
                              if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                              return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              guard let newValue = newValue else { return }
                              resultMap += newValue.resultMap
                            }
                          }

                          public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment? {
                            get {
                              if !ApiMultiActionVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                              return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              guard let newValue = newValue else { return }
                              resultMap += newValue.resultMap
                            }
                          }
                        }

                        public var asEmbarkApiGraphQlSingleVariable: AsEmbarkApiGraphQlSingleVariable? {
                          get {
                            if !AsEmbarkApiGraphQlSingleVariable.possibleTypes.contains(__typename) { return nil }
                            return AsEmbarkApiGraphQlSingleVariable(unsafeResultMap: resultMap)
                          }
                          set {
                            guard let newValue = newValue else { return }
                            resultMap = newValue.resultMap
                          }
                        }

                        public struct AsEmbarkApiGraphQlSingleVariable: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("key", type: .nonNull(.scalar(String.self))),
                              GraphQLField("from", type: .nonNull(.scalar(String.self))),
                              GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var key: String {
                            get {
                              return resultMap["key"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "key")
                            }
                          }

                          public var from: String {
                            get {
                              return resultMap["from"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "from")
                            }
                          }

                          public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
                            get {
                              return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "as")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var apiVariablesFragment: ApiVariablesFragment {
                              get {
                                return ApiVariablesFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiSingleVariableFragment: ApiSingleVariableFragment {
                              get {
                                return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                              get {
                                if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment? {
                              get {
                                if !ApiMultiActionVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }
                          }
                        }

                        public var asEmbarkApiGraphQlGeneratedVariable: AsEmbarkApiGraphQlGeneratedVariable? {
                          get {
                            if !AsEmbarkApiGraphQlGeneratedVariable.possibleTypes.contains(__typename) { return nil }
                            return AsEmbarkApiGraphQlGeneratedVariable(unsafeResultMap: resultMap)
                          }
                          set {
                            guard let newValue = newValue else { return }
                            resultMap = newValue.resultMap
                          }
                        }

                        public struct AsEmbarkApiGraphQlGeneratedVariable: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("key", type: .nonNull(.scalar(String.self))),
                              GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
                              GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var key: String {
                            get {
                              return resultMap["key"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "key")
                            }
                          }

                          public var storeAs: String {
                            get {
                              return resultMap["storeAs"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "storeAs")
                            }
                          }

                          public var type: EmbarkAPIGraphQLVariableGeneratedType {
                            get {
                              return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "type")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var apiVariablesFragment: ApiVariablesFragment {
                              get {
                                return ApiVariablesFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                              get {
                                if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment {
                              get {
                                return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment? {
                              get {
                                if !ApiMultiActionVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }
                          }
                        }

                        public var asEmbarkApiGraphQlMultiActionVariable: AsEmbarkApiGraphQlMultiActionVariable? {
                          get {
                            if !AsEmbarkApiGraphQlMultiActionVariable.possibleTypes.contains(__typename) { return nil }
                            return AsEmbarkApiGraphQlMultiActionVariable(unsafeResultMap: resultMap)
                          }
                          set {
                            guard let newValue = newValue else { return }
                            resultMap = newValue.resultMap
                          }
                        }

                        public struct AsEmbarkApiGraphQlMultiActionVariable: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkAPIGraphQLMultiActionVariable"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("key", type: .nonNull(.scalar(String.self))),
                              GraphQLField("variables", type: .nonNull(.list(.nonNull(.object(Variable.selections))))),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(key: String, variables: [Variable]) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: Variable) -> ResultMap in value.resultMap }])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var key: String {
                            get {
                              return resultMap["key"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "key")
                            }
                          }

                          public var variables: [Variable] {
                            get {
                              return (resultMap["variables"] as! [ResultMap]).map { (value: ResultMap) -> Variable in Variable(unsafeResultMap: value) }
                            }
                            set {
                              resultMap.updateValue(newValue.map { (value: Variable) -> ResultMap in value.resultMap }, forKey: "variables")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var apiVariablesFragment: ApiVariablesFragment {
                              get {
                                return ApiVariablesFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                              get {
                                if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                              get {
                                if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment {
                              get {
                                return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }
                          }

                          public struct Variable: GraphQLSelectionSet {
                            public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable", "EmbarkAPIGraphQLGeneratedVariable", "EmbarkAPIGraphQLMultiActionVariable", "EmbarkAPIGraphQLConstantVariable"]

                            public static var selections: [GraphQLSelection] {
                              return [
                                GraphQLTypeCase(
                                  variants: ["EmbarkAPIGraphQLSingleVariable": AsEmbarkApiGraphQlSingleVariable.selections, "EmbarkAPIGraphQLGeneratedVariable": AsEmbarkApiGraphQlGeneratedVariable.selections, "EmbarkAPIGraphQLMultiActionVariable": AsEmbarkApiGraphQlMultiActionVariable.selections],
                                  default: [
                                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  ]
                                )
                              ]
                            }

                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public static func makeEmbarkAPIGraphQLConstantVariable() -> Variable {
                              return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLConstantVariable"])
                            }

                            public static func makeEmbarkAPIGraphQLSingleVariable(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) -> Variable {
                              return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                            }

                            public static func makeEmbarkAPIGraphQLGeneratedVariable(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) -> Variable {
                              return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                            }

                            public static func makeEmbarkAPIGraphQLMultiActionVariable(key: String, variables: [AsEmbarkApiGraphQlMultiActionVariable.Variable]) -> Variable {
                              return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: AsEmbarkApiGraphQlMultiActionVariable.Variable) -> ResultMap in value.resultMap }])
                            }

                            public var __typename: String {
                              get {
                                return resultMap["__typename"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "__typename")
                              }
                            }

                            public var fragments: Fragments {
                              get {
                                return Fragments(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public struct Fragments {
                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                get {
                                  if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                  return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  guard let newValue = newValue else { return }
                                  resultMap += newValue.resultMap
                                }
                              }

                              public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                get {
                                  if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                  return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  guard let newValue = newValue else { return }
                                  resultMap += newValue.resultMap
                                }
                              }
                            }

                            public var asEmbarkApiGraphQlSingleVariable: AsEmbarkApiGraphQlSingleVariable? {
                              get {
                                if !AsEmbarkApiGraphQlSingleVariable.possibleTypes.contains(__typename) { return nil }
                                return AsEmbarkApiGraphQlSingleVariable(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap = newValue.resultMap
                              }
                            }

                            public struct AsEmbarkApiGraphQlSingleVariable: GraphQLSelectionSet {
                              public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

                              public static var selections: [GraphQLSelection] {
                                return [
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("from", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
                                ]
                              }

                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
                                self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                              }

                              public var __typename: String {
                                get {
                                  return resultMap["__typename"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "__typename")
                                }
                              }

                              public var key: String {
                                get {
                                  return resultMap["key"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "key")
                                }
                              }

                              public var from: String {
                                get {
                                  return resultMap["from"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "from")
                                }
                              }

                              public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
                                get {
                                  return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "as")
                                }
                              }

                              public var fragments: Fragments {
                                get {
                                  return Fragments(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public struct Fragments {
                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public var apiSingleVariableFragment: ApiSingleVariableFragment {
                                  get {
                                    return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    resultMap += newValue.resultMap
                                  }
                                }

                                public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                  get {
                                    if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                    return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap += newValue.resultMap
                                  }
                                }
                              }
                            }

                            public var asEmbarkApiGraphQlGeneratedVariable: AsEmbarkApiGraphQlGeneratedVariable? {
                              get {
                                if !AsEmbarkApiGraphQlGeneratedVariable.possibleTypes.contains(__typename) { return nil }
                                return AsEmbarkApiGraphQlGeneratedVariable(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap = newValue.resultMap
                              }
                            }

                            public struct AsEmbarkApiGraphQlGeneratedVariable: GraphQLSelectionSet {
                              public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

                              public static var selections: [GraphQLSelection] {
                                return [
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
                                ]
                              }

                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
                                self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                              }

                              public var __typename: String {
                                get {
                                  return resultMap["__typename"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "__typename")
                                }
                              }

                              public var key: String {
                                get {
                                  return resultMap["key"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "key")
                                }
                              }

                              public var storeAs: String {
                                get {
                                  return resultMap["storeAs"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "storeAs")
                                }
                              }

                              public var type: EmbarkAPIGraphQLVariableGeneratedType {
                                get {
                                  return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "type")
                                }
                              }

                              public var fragments: Fragments {
                                get {
                                  return Fragments(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public struct Fragments {
                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                  get {
                                    if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                    return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap += newValue.resultMap
                                  }
                                }

                                public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment {
                                  get {
                                    return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    resultMap += newValue.resultMap
                                  }
                                }
                              }
                            }

                            public var asEmbarkApiGraphQlMultiActionVariable: AsEmbarkApiGraphQlMultiActionVariable? {
                              get {
                                if !AsEmbarkApiGraphQlMultiActionVariable.possibleTypes.contains(__typename) { return nil }
                                return AsEmbarkApiGraphQlMultiActionVariable(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap = newValue.resultMap
                              }
                            }

                            public struct AsEmbarkApiGraphQlMultiActionVariable: GraphQLSelectionSet {
                              public static let possibleTypes: [String] = ["EmbarkAPIGraphQLMultiActionVariable"]

                              public static var selections: [GraphQLSelection] {
                                return [
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("variables", type: .nonNull(.list(.nonNull(.object(Variable.selections))))),
                                ]
                              }

                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public init(key: String, variables: [Variable]) {
                                self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: Variable) -> ResultMap in value.resultMap }])
                              }

                              public var __typename: String {
                                get {
                                  return resultMap["__typename"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "__typename")
                                }
                              }

                              public var key: String {
                                get {
                                  return resultMap["key"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "key")
                                }
                              }

                              public var variables: [Variable] {
                                get {
                                  return (resultMap["variables"] as! [ResultMap]).map { (value: ResultMap) -> Variable in Variable(unsafeResultMap: value) }
                                }
                                set {
                                  resultMap.updateValue(newValue.map { (value: Variable) -> ResultMap in value.resultMap }, forKey: "variables")
                                }
                              }

                              public var fragments: Fragments {
                                get {
                                  return Fragments(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public struct Fragments {
                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                  get {
                                    if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                    return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap += newValue.resultMap
                                  }
                                }

                                public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                  get {
                                    if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                    return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap += newValue.resultMap
                                  }
                                }
                              }

                              public struct Variable: GraphQLSelectionSet {
                                public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable", "EmbarkAPIGraphQLGeneratedVariable", "EmbarkAPIGraphQLMultiActionVariable", "EmbarkAPIGraphQLConstantVariable"]

                                public static var selections: [GraphQLSelection] {
                                  return [
                                    GraphQLTypeCase(
                                      variants: ["EmbarkAPIGraphQLSingleVariable": AsEmbarkApiGraphQlSingleVariable.selections, "EmbarkAPIGraphQLGeneratedVariable": AsEmbarkApiGraphQlGeneratedVariable.selections],
                                      default: [
                                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                      ]
                                    )
                                  ]
                                }

                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public static func makeEmbarkAPIGraphQLMultiActionVariable() -> Variable {
                                  return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable"])
                                }

                                public static func makeEmbarkAPIGraphQLConstantVariable() -> Variable {
                                  return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLConstantVariable"])
                                }

                                public static func makeEmbarkAPIGraphQLSingleVariable(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) -> Variable {
                                  return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                                }

                                public static func makeEmbarkAPIGraphQLGeneratedVariable(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) -> Variable {
                                  return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                                }

                                public var __typename: String {
                                  get {
                                    return resultMap["__typename"]! as! String
                                  }
                                  set {
                                    resultMap.updateValue(newValue, forKey: "__typename")
                                  }
                                }

                                public var fragments: Fragments {
                                  get {
                                    return Fragments(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    resultMap += newValue.resultMap
                                  }
                                }

                                public struct Fragments {
                                  public private(set) var resultMap: ResultMap

                                  public init(unsafeResultMap: ResultMap) {
                                    self.resultMap = unsafeResultMap
                                  }

                                  public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                    get {
                                      if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                      return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      guard let newValue = newValue else { return }
                                      resultMap += newValue.resultMap
                                    }
                                  }

                                  public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                    get {
                                      if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                      return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      guard let newValue = newValue else { return }
                                      resultMap += newValue.resultMap
                                    }
                                  }
                                }

                                public var asEmbarkApiGraphQlSingleVariable: AsEmbarkApiGraphQlSingleVariable? {
                                  get {
                                    if !AsEmbarkApiGraphQlSingleVariable.possibleTypes.contains(__typename) { return nil }
                                    return AsEmbarkApiGraphQlSingleVariable(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap = newValue.resultMap
                                  }
                                }

                                public struct AsEmbarkApiGraphQlSingleVariable: GraphQLSelectionSet {
                                  public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

                                  public static var selections: [GraphQLSelection] {
                                    return [
                                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("from", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
                                    ]
                                  }

                                  public private(set) var resultMap: ResultMap

                                  public init(unsafeResultMap: ResultMap) {
                                    self.resultMap = unsafeResultMap
                                  }

                                  public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
                                    self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                                  }

                                  public var __typename: String {
                                    get {
                                      return resultMap["__typename"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "__typename")
                                    }
                                  }

                                  public var key: String {
                                    get {
                                      return resultMap["key"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "key")
                                    }
                                  }

                                  public var from: String {
                                    get {
                                      return resultMap["from"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "from")
                                    }
                                  }

                                  public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
                                    get {
                                      return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "as")
                                    }
                                  }

                                  public var fragments: Fragments {
                                    get {
                                      return Fragments(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      resultMap += newValue.resultMap
                                    }
                                  }

                                  public struct Fragments {
                                    public private(set) var resultMap: ResultMap

                                    public init(unsafeResultMap: ResultMap) {
                                      self.resultMap = unsafeResultMap
                                    }

                                    public var apiSingleVariableFragment: ApiSingleVariableFragment {
                                      get {
                                        return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                      }
                                      set {
                                        resultMap += newValue.resultMap
                                      }
                                    }

                                    public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                      get {
                                        if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                        return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                      }
                                      set {
                                        guard let newValue = newValue else { return }
                                        resultMap += newValue.resultMap
                                      }
                                    }
                                  }
                                }

                                public var asEmbarkApiGraphQlGeneratedVariable: AsEmbarkApiGraphQlGeneratedVariable? {
                                  get {
                                    if !AsEmbarkApiGraphQlGeneratedVariable.possibleTypes.contains(__typename) { return nil }
                                    return AsEmbarkApiGraphQlGeneratedVariable(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap = newValue.resultMap
                                  }
                                }

                                public struct AsEmbarkApiGraphQlGeneratedVariable: GraphQLSelectionSet {
                                  public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

                                  public static var selections: [GraphQLSelection] {
                                    return [
                                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
                                    ]
                                  }

                                  public private(set) var resultMap: ResultMap

                                  public init(unsafeResultMap: ResultMap) {
                                    self.resultMap = unsafeResultMap
                                  }

                                  public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
                                    self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                                  }

                                  public var __typename: String {
                                    get {
                                      return resultMap["__typename"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "__typename")
                                    }
                                  }

                                  public var key: String {
                                    get {
                                      return resultMap["key"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "key")
                                    }
                                  }

                                  public var storeAs: String {
                                    get {
                                      return resultMap["storeAs"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "storeAs")
                                    }
                                  }

                                  public var type: EmbarkAPIGraphQLVariableGeneratedType {
                                    get {
                                      return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "type")
                                    }
                                  }

                                  public var fragments: Fragments {
                                    get {
                                      return Fragments(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      resultMap += newValue.resultMap
                                    }
                                  }

                                  public struct Fragments {
                                    public private(set) var resultMap: ResultMap

                                    public init(unsafeResultMap: ResultMap) {
                                      self.resultMap = unsafeResultMap
                                    }

                                    public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                      get {
                                        if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                        return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                      }
                                      set {
                                        guard let newValue = newValue else { return }
                                        resultMap += newValue.resultMap
                                      }
                                    }

                                    public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment {
                                      get {
                                        return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                      }
                                      set {
                                        resultMap += newValue.resultMap
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }

                      public struct QueryResult: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkAPIGraphQLResult"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("key", type: .nonNull(.scalar(String.self))),
                            GraphQLField("as", type: .nonNull(.scalar(String.self))),
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public init(key: String, `as`: String) {
                          self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLResult", "key": key, "as": `as`])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var key: String {
                          get {
                            return resultMap["key"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "key")
                          }
                        }

                        public var `as`: String {
                          get {
                            return resultMap["as"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "as")
                          }
                        }
                      }

                      public struct QueryError: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkAPIGraphQLError"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("contains", type: .scalar(String.self)),
                            GraphQLField("next", type: .nonNull(.object(Next.selections))),
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public init(contains: String? = nil, next: Next) {
                          self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLError", "contains": contains, "next": next.resultMap])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var contains: String? {
                          get {
                            return resultMap["contains"] as? String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "contains")
                          }
                        }

                        public var next: Next {
                          get {
                            return Next(unsafeResultMap: resultMap["next"]! as! ResultMap)
                          }
                          set {
                            resultMap.updateValue(newValue.resultMap, forKey: "next")
                          }
                        }

                        public struct Next: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkLink"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("name", type: .nonNull(.scalar(String.self))),
                              GraphQLField("label", type: .nonNull(.scalar(String.self))),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(name: String, label: String) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkLink", "name": name, "label": label])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var name: String {
                            get {
                              return resultMap["name"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "name")
                            }
                          }

                          public var label: String {
                            get {
                              return resultMap["label"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "label")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var embarkLinkFragment: EmbarkLinkFragment {
                              get {
                                return EmbarkLinkFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }
                          }
                        }
                      }
                    }
                  }

                  public var asEmbarkApiGraphQlMutation: AsEmbarkApiGraphQlMutation? {
                    get {
                      if !AsEmbarkApiGraphQlMutation.possibleTypes.contains(__typename) { return nil }
                      return AsEmbarkApiGraphQlMutation(unsafeResultMap: resultMap)
                    }
                    set {
                      guard let newValue = newValue else { return }
                      resultMap = newValue.resultMap
                    }
                  }

                  public struct AsEmbarkApiGraphQlMutation: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkApiGraphQLMutation"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("data", type: .nonNull(.object(Datum.selections))),
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public init(data: Datum) {
                      self.init(unsafeResultMap: ["__typename": "EmbarkApiGraphQLMutation", "data": data.resultMap])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var data: Datum {
                      get {
                        return Datum(unsafeResultMap: resultMap["data"]! as! ResultMap)
                      }
                      set {
                        resultMap.updateValue(newValue.resultMap, forKey: "data")
                      }
                    }

                    public var fragments: Fragments {
                      get {
                        return Fragments(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public struct Fragments {
                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public var apiFragment: ApiFragment {
                        get {
                          return ApiFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }
                    }

                    public struct Datum: GraphQLSelectionSet {
                      public static let possibleTypes: [String] = ["EmbarkApiGraphQLMutationData"]

                      public static var selections: [GraphQLSelection] {
                        return [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("next", type: .object(Next.selections)),
                          GraphQLField("mutation", type: .nonNull(.scalar(String.self))),
                          GraphQLField("variables", type: .nonNull(.list(.nonNull(.object(Variable.selections))))),
                          GraphQLField("results", alias: "mutationResults", type: .nonNull(.list(.object(MutationResult.selections)))),
                          GraphQLField("errors", alias: "mutationErrors", type: .nonNull(.list(.nonNull(.object(MutationError.selections))))),
                        ]
                      }

                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public init(next: Next? = nil, mutation: String, variables: [Variable], mutationResults: [MutationResult?], mutationErrors: [MutationError]) {
                        self.init(unsafeResultMap: ["__typename": "EmbarkApiGraphQLMutationData", "next": next.flatMap { (value: Next) -> ResultMap in value.resultMap }, "mutation": mutation, "variables": variables.map { (value: Variable) -> ResultMap in value.resultMap }, "mutationResults": mutationResults.map { (value: MutationResult?) -> ResultMap? in value.flatMap { (value: MutationResult) -> ResultMap in value.resultMap } }, "mutationErrors": mutationErrors.map { (value: MutationError) -> ResultMap in value.resultMap }])
                      }

                      public var __typename: String {
                        get {
                          return resultMap["__typename"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "__typename")
                        }
                      }

                      public var next: Next? {
                        get {
                          return (resultMap["next"] as? ResultMap).flatMap { Next(unsafeResultMap: $0) }
                        }
                        set {
                          resultMap.updateValue(newValue?.resultMap, forKey: "next")
                        }
                      }

                      public var mutation: String {
                        get {
                          return resultMap["mutation"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "mutation")
                        }
                      }

                      public var variables: [Variable] {
                        get {
                          return (resultMap["variables"] as! [ResultMap]).map { (value: ResultMap) -> Variable in Variable(unsafeResultMap: value) }
                        }
                        set {
                          resultMap.updateValue(newValue.map { (value: Variable) -> ResultMap in value.resultMap }, forKey: "variables")
                        }
                      }

                      public var mutationResults: [MutationResult?] {
                        get {
                          return (resultMap["mutationResults"] as! [ResultMap?]).map { (value: ResultMap?) -> MutationResult? in value.flatMap { (value: ResultMap) -> MutationResult in MutationResult(unsafeResultMap: value) } }
                        }
                        set {
                          resultMap.updateValue(newValue.map { (value: MutationResult?) -> ResultMap? in value.flatMap { (value: MutationResult) -> ResultMap in value.resultMap } }, forKey: "mutationResults")
                        }
                      }

                      public var mutationErrors: [MutationError] {
                        get {
                          return (resultMap["mutationErrors"] as! [ResultMap]).map { (value: ResultMap) -> MutationError in MutationError(unsafeResultMap: value) }
                        }
                        set {
                          resultMap.updateValue(newValue.map { (value: MutationError) -> ResultMap in value.resultMap }, forKey: "mutationErrors")
                        }
                      }

                      public struct Next: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkLink"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("name", type: .nonNull(.scalar(String.self))),
                            GraphQLField("label", type: .nonNull(.scalar(String.self))),
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public init(name: String, label: String) {
                          self.init(unsafeResultMap: ["__typename": "EmbarkLink", "name": name, "label": label])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var name: String {
                          get {
                            return resultMap["name"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "name")
                          }
                        }

                        public var label: String {
                          get {
                            return resultMap["label"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "label")
                          }
                        }

                        public var fragments: Fragments {
                          get {
                            return Fragments(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }

                        public struct Fragments {
                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public var embarkLinkFragment: EmbarkLinkFragment {
                            get {
                              return EmbarkLinkFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }
                        }
                      }

                      public struct Variable: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable", "EmbarkAPIGraphQLGeneratedVariable", "EmbarkAPIGraphQLMultiActionVariable", "EmbarkAPIGraphQLConstantVariable"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLTypeCase(
                              variants: ["EmbarkAPIGraphQLSingleVariable": AsEmbarkApiGraphQlSingleVariable.selections, "EmbarkAPIGraphQLGeneratedVariable": AsEmbarkApiGraphQlGeneratedVariable.selections, "EmbarkAPIGraphQLMultiActionVariable": AsEmbarkApiGraphQlMultiActionVariable.selections],
                              default: [
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              ]
                            )
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public static func makeEmbarkAPIGraphQLConstantVariable() -> Variable {
                          return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLConstantVariable"])
                        }

                        public static func makeEmbarkAPIGraphQLSingleVariable(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) -> Variable {
                          return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                        }

                        public static func makeEmbarkAPIGraphQLGeneratedVariable(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) -> Variable {
                          return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                        }

                        public static func makeEmbarkAPIGraphQLMultiActionVariable(key: String, variables: [AsEmbarkApiGraphQlMultiActionVariable.Variable]) -> Variable {
                          return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: AsEmbarkApiGraphQlMultiActionVariable.Variable) -> ResultMap in value.resultMap }])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var fragments: Fragments {
                          get {
                            return Fragments(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }

                        public struct Fragments {
                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public var apiVariablesFragment: ApiVariablesFragment {
                            get {
                              return ApiVariablesFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                            get {
                              if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                              return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              guard let newValue = newValue else { return }
                              resultMap += newValue.resultMap
                            }
                          }

                          public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                            get {
                              if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                              return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              guard let newValue = newValue else { return }
                              resultMap += newValue.resultMap
                            }
                          }

                          public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment? {
                            get {
                              if !ApiMultiActionVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                              return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              guard let newValue = newValue else { return }
                              resultMap += newValue.resultMap
                            }
                          }
                        }

                        public var asEmbarkApiGraphQlSingleVariable: AsEmbarkApiGraphQlSingleVariable? {
                          get {
                            if !AsEmbarkApiGraphQlSingleVariable.possibleTypes.contains(__typename) { return nil }
                            return AsEmbarkApiGraphQlSingleVariable(unsafeResultMap: resultMap)
                          }
                          set {
                            guard let newValue = newValue else { return }
                            resultMap = newValue.resultMap
                          }
                        }

                        public struct AsEmbarkApiGraphQlSingleVariable: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("key", type: .nonNull(.scalar(String.self))),
                              GraphQLField("from", type: .nonNull(.scalar(String.self))),
                              GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var key: String {
                            get {
                              return resultMap["key"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "key")
                            }
                          }

                          public var from: String {
                            get {
                              return resultMap["from"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "from")
                            }
                          }

                          public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
                            get {
                              return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "as")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var apiVariablesFragment: ApiVariablesFragment {
                              get {
                                return ApiVariablesFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiSingleVariableFragment: ApiSingleVariableFragment {
                              get {
                                return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                              get {
                                if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment? {
                              get {
                                if !ApiMultiActionVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }
                          }
                        }

                        public var asEmbarkApiGraphQlGeneratedVariable: AsEmbarkApiGraphQlGeneratedVariable? {
                          get {
                            if !AsEmbarkApiGraphQlGeneratedVariable.possibleTypes.contains(__typename) { return nil }
                            return AsEmbarkApiGraphQlGeneratedVariable(unsafeResultMap: resultMap)
                          }
                          set {
                            guard let newValue = newValue else { return }
                            resultMap = newValue.resultMap
                          }
                        }

                        public struct AsEmbarkApiGraphQlGeneratedVariable: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("key", type: .nonNull(.scalar(String.self))),
                              GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
                              GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var key: String {
                            get {
                              return resultMap["key"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "key")
                            }
                          }

                          public var storeAs: String {
                            get {
                              return resultMap["storeAs"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "storeAs")
                            }
                          }

                          public var type: EmbarkAPIGraphQLVariableGeneratedType {
                            get {
                              return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "type")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var apiVariablesFragment: ApiVariablesFragment {
                              get {
                                return ApiVariablesFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                              get {
                                if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment {
                              get {
                                return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment? {
                              get {
                                if !ApiMultiActionVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }
                          }
                        }

                        public var asEmbarkApiGraphQlMultiActionVariable: AsEmbarkApiGraphQlMultiActionVariable? {
                          get {
                            if !AsEmbarkApiGraphQlMultiActionVariable.possibleTypes.contains(__typename) { return nil }
                            return AsEmbarkApiGraphQlMultiActionVariable(unsafeResultMap: resultMap)
                          }
                          set {
                            guard let newValue = newValue else { return }
                            resultMap = newValue.resultMap
                          }
                        }

                        public struct AsEmbarkApiGraphQlMultiActionVariable: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkAPIGraphQLMultiActionVariable"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("key", type: .nonNull(.scalar(String.self))),
                              GraphQLField("variables", type: .nonNull(.list(.nonNull(.object(Variable.selections))))),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(key: String, variables: [Variable]) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: Variable) -> ResultMap in value.resultMap }])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var key: String {
                            get {
                              return resultMap["key"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "key")
                            }
                          }

                          public var variables: [Variable] {
                            get {
                              return (resultMap["variables"] as! [ResultMap]).map { (value: ResultMap) -> Variable in Variable(unsafeResultMap: value) }
                            }
                            set {
                              resultMap.updateValue(newValue.map { (value: Variable) -> ResultMap in value.resultMap }, forKey: "variables")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var apiVariablesFragment: ApiVariablesFragment {
                              get {
                                return ApiVariablesFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                              get {
                                if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                              get {
                                if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment {
                              get {
                                return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }
                          }

                          public struct Variable: GraphQLSelectionSet {
                            public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable", "EmbarkAPIGraphQLGeneratedVariable", "EmbarkAPIGraphQLMultiActionVariable", "EmbarkAPIGraphQLConstantVariable"]

                            public static var selections: [GraphQLSelection] {
                              return [
                                GraphQLTypeCase(
                                  variants: ["EmbarkAPIGraphQLSingleVariable": AsEmbarkApiGraphQlSingleVariable.selections, "EmbarkAPIGraphQLGeneratedVariable": AsEmbarkApiGraphQlGeneratedVariable.selections, "EmbarkAPIGraphQLMultiActionVariable": AsEmbarkApiGraphQlMultiActionVariable.selections],
                                  default: [
                                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  ]
                                )
                              ]
                            }

                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public static func makeEmbarkAPIGraphQLConstantVariable() -> Variable {
                              return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLConstantVariable"])
                            }

                            public static func makeEmbarkAPIGraphQLSingleVariable(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) -> Variable {
                              return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                            }

                            public static func makeEmbarkAPIGraphQLGeneratedVariable(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) -> Variable {
                              return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                            }

                            public static func makeEmbarkAPIGraphQLMultiActionVariable(key: String, variables: [AsEmbarkApiGraphQlMultiActionVariable.Variable]) -> Variable {
                              return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: AsEmbarkApiGraphQlMultiActionVariable.Variable) -> ResultMap in value.resultMap }])
                            }

                            public var __typename: String {
                              get {
                                return resultMap["__typename"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "__typename")
                              }
                            }

                            public var fragments: Fragments {
                              get {
                                return Fragments(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public struct Fragments {
                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                get {
                                  if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                  return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  guard let newValue = newValue else { return }
                                  resultMap += newValue.resultMap
                                }
                              }

                              public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                get {
                                  if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                  return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  guard let newValue = newValue else { return }
                                  resultMap += newValue.resultMap
                                }
                              }
                            }

                            public var asEmbarkApiGraphQlSingleVariable: AsEmbarkApiGraphQlSingleVariable? {
                              get {
                                if !AsEmbarkApiGraphQlSingleVariable.possibleTypes.contains(__typename) { return nil }
                                return AsEmbarkApiGraphQlSingleVariable(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap = newValue.resultMap
                              }
                            }

                            public struct AsEmbarkApiGraphQlSingleVariable: GraphQLSelectionSet {
                              public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

                              public static var selections: [GraphQLSelection] {
                                return [
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("from", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
                                ]
                              }

                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
                                self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                              }

                              public var __typename: String {
                                get {
                                  return resultMap["__typename"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "__typename")
                                }
                              }

                              public var key: String {
                                get {
                                  return resultMap["key"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "key")
                                }
                              }

                              public var from: String {
                                get {
                                  return resultMap["from"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "from")
                                }
                              }

                              public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
                                get {
                                  return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "as")
                                }
                              }

                              public var fragments: Fragments {
                                get {
                                  return Fragments(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public struct Fragments {
                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public var apiSingleVariableFragment: ApiSingleVariableFragment {
                                  get {
                                    return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    resultMap += newValue.resultMap
                                  }
                                }

                                public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                  get {
                                    if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                    return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap += newValue.resultMap
                                  }
                                }
                              }
                            }

                            public var asEmbarkApiGraphQlGeneratedVariable: AsEmbarkApiGraphQlGeneratedVariable? {
                              get {
                                if !AsEmbarkApiGraphQlGeneratedVariable.possibleTypes.contains(__typename) { return nil }
                                return AsEmbarkApiGraphQlGeneratedVariable(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap = newValue.resultMap
                              }
                            }

                            public struct AsEmbarkApiGraphQlGeneratedVariable: GraphQLSelectionSet {
                              public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

                              public static var selections: [GraphQLSelection] {
                                return [
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
                                ]
                              }

                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
                                self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                              }

                              public var __typename: String {
                                get {
                                  return resultMap["__typename"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "__typename")
                                }
                              }

                              public var key: String {
                                get {
                                  return resultMap["key"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "key")
                                }
                              }

                              public var storeAs: String {
                                get {
                                  return resultMap["storeAs"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "storeAs")
                                }
                              }

                              public var type: EmbarkAPIGraphQLVariableGeneratedType {
                                get {
                                  return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "type")
                                }
                              }

                              public var fragments: Fragments {
                                get {
                                  return Fragments(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public struct Fragments {
                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                  get {
                                    if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                    return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap += newValue.resultMap
                                  }
                                }

                                public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment {
                                  get {
                                    return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    resultMap += newValue.resultMap
                                  }
                                }
                              }
                            }

                            public var asEmbarkApiGraphQlMultiActionVariable: AsEmbarkApiGraphQlMultiActionVariable? {
                              get {
                                if !AsEmbarkApiGraphQlMultiActionVariable.possibleTypes.contains(__typename) { return nil }
                                return AsEmbarkApiGraphQlMultiActionVariable(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap = newValue.resultMap
                              }
                            }

                            public struct AsEmbarkApiGraphQlMultiActionVariable: GraphQLSelectionSet {
                              public static let possibleTypes: [String] = ["EmbarkAPIGraphQLMultiActionVariable"]

                              public static var selections: [GraphQLSelection] {
                                return [
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("variables", type: .nonNull(.list(.nonNull(.object(Variable.selections))))),
                                ]
                              }

                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public init(key: String, variables: [Variable]) {
                                self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: Variable) -> ResultMap in value.resultMap }])
                              }

                              public var __typename: String {
                                get {
                                  return resultMap["__typename"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "__typename")
                                }
                              }

                              public var key: String {
                                get {
                                  return resultMap["key"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "key")
                                }
                              }

                              public var variables: [Variable] {
                                get {
                                  return (resultMap["variables"] as! [ResultMap]).map { (value: ResultMap) -> Variable in Variable(unsafeResultMap: value) }
                                }
                                set {
                                  resultMap.updateValue(newValue.map { (value: Variable) -> ResultMap in value.resultMap }, forKey: "variables")
                                }
                              }

                              public var fragments: Fragments {
                                get {
                                  return Fragments(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public struct Fragments {
                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                  get {
                                    if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                    return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap += newValue.resultMap
                                  }
                                }

                                public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                  get {
                                    if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                    return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap += newValue.resultMap
                                  }
                                }
                              }

                              public struct Variable: GraphQLSelectionSet {
                                public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable", "EmbarkAPIGraphQLGeneratedVariable", "EmbarkAPIGraphQLMultiActionVariable", "EmbarkAPIGraphQLConstantVariable"]

                                public static var selections: [GraphQLSelection] {
                                  return [
                                    GraphQLTypeCase(
                                      variants: ["EmbarkAPIGraphQLSingleVariable": AsEmbarkApiGraphQlSingleVariable.selections, "EmbarkAPIGraphQLGeneratedVariable": AsEmbarkApiGraphQlGeneratedVariable.selections],
                                      default: [
                                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                      ]
                                    )
                                  ]
                                }

                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public static func makeEmbarkAPIGraphQLMultiActionVariable() -> Variable {
                                  return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable"])
                                }

                                public static func makeEmbarkAPIGraphQLConstantVariable() -> Variable {
                                  return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLConstantVariable"])
                                }

                                public static func makeEmbarkAPIGraphQLSingleVariable(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) -> Variable {
                                  return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                                }

                                public static func makeEmbarkAPIGraphQLGeneratedVariable(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) -> Variable {
                                  return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                                }

                                public var __typename: String {
                                  get {
                                    return resultMap["__typename"]! as! String
                                  }
                                  set {
                                    resultMap.updateValue(newValue, forKey: "__typename")
                                  }
                                }

                                public var fragments: Fragments {
                                  get {
                                    return Fragments(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    resultMap += newValue.resultMap
                                  }
                                }

                                public struct Fragments {
                                  public private(set) var resultMap: ResultMap

                                  public init(unsafeResultMap: ResultMap) {
                                    self.resultMap = unsafeResultMap
                                  }

                                  public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                    get {
                                      if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                      return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      guard let newValue = newValue else { return }
                                      resultMap += newValue.resultMap
                                    }
                                  }

                                  public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                    get {
                                      if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                      return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      guard let newValue = newValue else { return }
                                      resultMap += newValue.resultMap
                                    }
                                  }
                                }

                                public var asEmbarkApiGraphQlSingleVariable: AsEmbarkApiGraphQlSingleVariable? {
                                  get {
                                    if !AsEmbarkApiGraphQlSingleVariable.possibleTypes.contains(__typename) { return nil }
                                    return AsEmbarkApiGraphQlSingleVariable(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap = newValue.resultMap
                                  }
                                }

                                public struct AsEmbarkApiGraphQlSingleVariable: GraphQLSelectionSet {
                                  public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

                                  public static var selections: [GraphQLSelection] {
                                    return [
                                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("from", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
                                    ]
                                  }

                                  public private(set) var resultMap: ResultMap

                                  public init(unsafeResultMap: ResultMap) {
                                    self.resultMap = unsafeResultMap
                                  }

                                  public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
                                    self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                                  }

                                  public var __typename: String {
                                    get {
                                      return resultMap["__typename"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "__typename")
                                    }
                                  }

                                  public var key: String {
                                    get {
                                      return resultMap["key"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "key")
                                    }
                                  }

                                  public var from: String {
                                    get {
                                      return resultMap["from"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "from")
                                    }
                                  }

                                  public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
                                    get {
                                      return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "as")
                                    }
                                  }

                                  public var fragments: Fragments {
                                    get {
                                      return Fragments(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      resultMap += newValue.resultMap
                                    }
                                  }

                                  public struct Fragments {
                                    public private(set) var resultMap: ResultMap

                                    public init(unsafeResultMap: ResultMap) {
                                      self.resultMap = unsafeResultMap
                                    }

                                    public var apiSingleVariableFragment: ApiSingleVariableFragment {
                                      get {
                                        return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                      }
                                      set {
                                        resultMap += newValue.resultMap
                                      }
                                    }

                                    public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                      get {
                                        if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                        return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                      }
                                      set {
                                        guard let newValue = newValue else { return }
                                        resultMap += newValue.resultMap
                                      }
                                    }
                                  }
                                }

                                public var asEmbarkApiGraphQlGeneratedVariable: AsEmbarkApiGraphQlGeneratedVariable? {
                                  get {
                                    if !AsEmbarkApiGraphQlGeneratedVariable.possibleTypes.contains(__typename) { return nil }
                                    return AsEmbarkApiGraphQlGeneratedVariable(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap = newValue.resultMap
                                  }
                                }

                                public struct AsEmbarkApiGraphQlGeneratedVariable: GraphQLSelectionSet {
                                  public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

                                  public static var selections: [GraphQLSelection] {
                                    return [
                                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
                                    ]
                                  }

                                  public private(set) var resultMap: ResultMap

                                  public init(unsafeResultMap: ResultMap) {
                                    self.resultMap = unsafeResultMap
                                  }

                                  public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
                                    self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                                  }

                                  public var __typename: String {
                                    get {
                                      return resultMap["__typename"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "__typename")
                                    }
                                  }

                                  public var key: String {
                                    get {
                                      return resultMap["key"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "key")
                                    }
                                  }

                                  public var storeAs: String {
                                    get {
                                      return resultMap["storeAs"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "storeAs")
                                    }
                                  }

                                  public var type: EmbarkAPIGraphQLVariableGeneratedType {
                                    get {
                                      return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "type")
                                    }
                                  }

                                  public var fragments: Fragments {
                                    get {
                                      return Fragments(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      resultMap += newValue.resultMap
                                    }
                                  }

                                  public struct Fragments {
                                    public private(set) var resultMap: ResultMap

                                    public init(unsafeResultMap: ResultMap) {
                                      self.resultMap = unsafeResultMap
                                    }

                                    public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                      get {
                                        if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                        return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                      }
                                      set {
                                        guard let newValue = newValue else { return }
                                        resultMap += newValue.resultMap
                                      }
                                    }

                                    public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment {
                                      get {
                                        return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                      }
                                      set {
                                        resultMap += newValue.resultMap
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }

                      public struct MutationResult: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkAPIGraphQLResult"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("key", type: .nonNull(.scalar(String.self))),
                            GraphQLField("as", type: .nonNull(.scalar(String.self))),
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public init(key: String, `as`: String) {
                          self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLResult", "key": key, "as": `as`])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var key: String {
                          get {
                            return resultMap["key"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "key")
                          }
                        }

                        public var `as`: String {
                          get {
                            return resultMap["as"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "as")
                          }
                        }
                      }

                      public struct MutationError: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkAPIGraphQLError"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("contains", type: .scalar(String.self)),
                            GraphQLField("next", type: .nonNull(.object(Next.selections))),
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public init(contains: String? = nil, next: Next) {
                          self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLError", "contains": contains, "next": next.resultMap])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var contains: String? {
                          get {
                            return resultMap["contains"] as? String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "contains")
                          }
                        }

                        public var next: Next {
                          get {
                            return Next(unsafeResultMap: resultMap["next"]! as! ResultMap)
                          }
                          set {
                            resultMap.updateValue(newValue.resultMap, forKey: "next")
                          }
                        }

                        public struct Next: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkLink"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("name", type: .nonNull(.scalar(String.self))),
                              GraphQLField("label", type: .nonNull(.scalar(String.self))),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(name: String, label: String) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkLink", "name": name, "label": label])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var name: String {
                            get {
                              return resultMap["name"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "name")
                            }
                          }

                          public var label: String {
                            get {
                              return resultMap["label"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "label")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var embarkLinkFragment: EmbarkLinkFragment {
                              get {
                                return EmbarkLinkFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }

                public struct Link: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkLink"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("name", type: .nonNull(.scalar(String.self))),
                      GraphQLField("label", type: .nonNull(.scalar(String.self))),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(name: String, label: String) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkLink", "name": name, "label": label])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var name: String {
                    get {
                      return resultMap["name"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "name")
                    }
                  }

                  public var label: String {
                    get {
                      return resultMap["label"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "label")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var embarkLinkFragment: EmbarkLinkFragment {
                      get {
                        return EmbarkLinkFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }
                }
              }
            }

            public var asEmbarkNumberAction: AsEmbarkNumberAction? {
              get {
                if !AsEmbarkNumberAction.possibleTypes.contains(__typename) { return nil }
                return AsEmbarkNumberAction(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap = newValue.resultMap
              }
            }

            public struct AsEmbarkNumberAction: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkNumberAction"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("component", type: .nonNull(.scalar(String.self))),
                  GraphQLField("component", type: .nonNull(.scalar(String.self))),
                  GraphQLField("data", alias: "numberActionData", type: .nonNull(.object(NumberActionDatum.selections))),
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public init(component: String, numberActionData: NumberActionDatum) {
                self.init(unsafeResultMap: ["__typename": "EmbarkNumberAction", "component": component, "numberActionData": numberActionData.resultMap])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var component: String {
                get {
                  return resultMap["component"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "component")
                }
              }

              public var numberActionData: NumberActionDatum {
                get {
                  return NumberActionDatum(unsafeResultMap: resultMap["numberActionData"]! as! ResultMap)
                }
                set {
                  resultMap.updateValue(newValue.resultMap, forKey: "numberActionData")
                }
              }

              public struct NumberActionDatum: GraphQLSelectionSet {
                public static let possibleTypes: [String] = ["EmbarkNumberActionData"]

                public static var selections: [GraphQLSelection] {
                  return [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("key", type: .nonNull(.scalar(String.self))),
                    GraphQLField("placeholder", type: .nonNull(.scalar(String.self))),
                    GraphQLField("unit", type: .scalar(String.self)),
                    GraphQLField("label", type: .scalar(String.self)),
                    GraphQLField("maxValue", type: .scalar(Int.self)),
                    GraphQLField("minValue", type: .scalar(Int.self)),
                    GraphQLField("link", type: .nonNull(.object(Link.selections))),
                  ]
                }

                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public init(key: String, placeholder: String, unit: String? = nil, label: String? = nil, maxValue: Int? = nil, minValue: Int? = nil, link: Link) {
                  self.init(unsafeResultMap: ["__typename": "EmbarkNumberActionData", "key": key, "placeholder": placeholder, "unit": unit, "label": label, "maxValue": maxValue, "minValue": minValue, "link": link.resultMap])
                }

                public var __typename: String {
                  get {
                    return resultMap["__typename"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "__typename")
                  }
                }

                public var key: String {
                  get {
                    return resultMap["key"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "key")
                  }
                }

                public var placeholder: String {
                  get {
                    return resultMap["placeholder"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "placeholder")
                  }
                }

                public var unit: String? {
                  get {
                    return resultMap["unit"] as? String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "unit")
                  }
                }

                public var label: String? {
                  get {
                    return resultMap["label"] as? String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "label")
                  }
                }

                public var maxValue: Int? {
                  get {
                    return resultMap["maxValue"] as? Int
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "maxValue")
                  }
                }

                public var minValue: Int? {
                  get {
                    return resultMap["minValue"] as? Int
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "minValue")
                  }
                }

                public var link: Link {
                  get {
                    return Link(unsafeResultMap: resultMap["link"]! as! ResultMap)
                  }
                  set {
                    resultMap.updateValue(newValue.resultMap, forKey: "link")
                  }
                }

                public var fragments: Fragments {
                  get {
                    return Fragments(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }

                public struct Fragments {
                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public var embarkNumberActionFragment: EmbarkNumberActionFragment {
                    get {
                      return EmbarkNumberActionFragment(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }
                }

                public struct Link: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkLink"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("name", type: .nonNull(.scalar(String.self))),
                      GraphQLField("label", type: .nonNull(.scalar(String.self))),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(name: String, label: String) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkLink", "name": name, "label": label])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var name: String {
                    get {
                      return resultMap["name"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "name")
                    }
                  }

                  public var label: String {
                    get {
                      return resultMap["label"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "label")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var embarkLinkFragment: EmbarkLinkFragment {
                      get {
                        return EmbarkLinkFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }
                }
              }
            }

            public var asEmbarkAddressAutocompleteAction: AsEmbarkAddressAutocompleteAction? {
              get {
                if !AsEmbarkAddressAutocompleteAction.possibleTypes.contains(__typename) { return nil }
                return AsEmbarkAddressAutocompleteAction(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap = newValue.resultMap
              }
            }

            public struct AsEmbarkAddressAutocompleteAction: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkAddressAutocompleteAction"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("component", type: .nonNull(.scalar(String.self))),
                  GraphQLField("component", type: .nonNull(.scalar(String.self))),
                  GraphQLField("data", alias: "addressAutocompleteActionData", type: .nonNull(.object(AddressAutocompleteActionDatum.selections))),
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public init(component: String, addressAutocompleteActionData: AddressAutocompleteActionDatum) {
                self.init(unsafeResultMap: ["__typename": "EmbarkAddressAutocompleteAction", "component": component, "addressAutocompleteActionData": addressAutocompleteActionData.resultMap])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var component: String {
                get {
                  return resultMap["component"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "component")
                }
              }

              public var addressAutocompleteActionData: AddressAutocompleteActionDatum {
                get {
                  return AddressAutocompleteActionDatum(unsafeResultMap: resultMap["addressAutocompleteActionData"]! as! ResultMap)
                }
                set {
                  resultMap.updateValue(newValue.resultMap, forKey: "addressAutocompleteActionData")
                }
              }

              public struct AddressAutocompleteActionDatum: GraphQLSelectionSet {
                public static let possibleTypes: [String] = ["EmbarkAddressAutocompleteActionData"]

                public static var selections: [GraphQLSelection] {
                  return [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("placeholder", type: .nonNull(.scalar(String.self))),
                    GraphQLField("key", type: .nonNull(.scalar(String.self))),
                    GraphQLField("link", type: .nonNull(.object(Link.selections))),
                    GraphQLField("api", type: .object(Api.selections)),
                  ]
                }

                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public init(placeholder: String, key: String, link: Link, api: Api? = nil) {
                  self.init(unsafeResultMap: ["__typename": "EmbarkAddressAutocompleteActionData", "placeholder": placeholder, "key": key, "link": link.resultMap, "api": api.flatMap { (value: Api) -> ResultMap in value.resultMap }])
                }

                public var __typename: String {
                  get {
                    return resultMap["__typename"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "__typename")
                  }
                }

                public var placeholder: String {
                  get {
                    return resultMap["placeholder"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "placeholder")
                  }
                }

                public var key: String {
                  get {
                    return resultMap["key"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "key")
                  }
                }

                public var link: Link {
                  get {
                    return Link(unsafeResultMap: resultMap["link"]! as! ResultMap)
                  }
                  set {
                    resultMap.updateValue(newValue.resultMap, forKey: "link")
                  }
                }

                public var api: Api? {
                  get {
                    return (resultMap["api"] as? ResultMap).flatMap { Api(unsafeResultMap: $0) }
                  }
                  set {
                    resultMap.updateValue(newValue?.resultMap, forKey: "api")
                  }
                }

                public struct Link: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkLink"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("name", type: .nonNull(.scalar(String.self))),
                      GraphQLField("label", type: .nonNull(.scalar(String.self))),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(name: String, label: String) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkLink", "name": name, "label": label])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var name: String {
                    get {
                      return resultMap["name"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "name")
                    }
                  }

                  public var label: String {
                    get {
                      return resultMap["label"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "label")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var embarkLinkFragment: EmbarkLinkFragment {
                      get {
                        return EmbarkLinkFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }
                }

                public struct Api: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkApiPersonalInformation", "EmbarkApiHouseInformation", "EmbarkApiCreateQuote", "EmbarkApiGraphQLQuery", "EmbarkApiGraphQLMutation"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLTypeCase(
                        variants: ["EmbarkApiGraphQLQuery": AsEmbarkApiGraphQlQuery.selections, "EmbarkApiGraphQLMutation": AsEmbarkApiGraphQlMutation.selections],
                        default: [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        ]
                      )
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public static func makeEmbarkApiPersonalInformation() -> Api {
                    return Api(unsafeResultMap: ["__typename": "EmbarkApiPersonalInformation"])
                  }

                  public static func makeEmbarkApiHouseInformation() -> Api {
                    return Api(unsafeResultMap: ["__typename": "EmbarkApiHouseInformation"])
                  }

                  public static func makeEmbarkApiCreateQuote() -> Api {
                    return Api(unsafeResultMap: ["__typename": "EmbarkApiCreateQuote"])
                  }

                  public static func makeEmbarkApiGraphQLQuery(data: AsEmbarkApiGraphQlQuery.Datum) -> Api {
                    return Api(unsafeResultMap: ["__typename": "EmbarkApiGraphQLQuery", "data": data.resultMap])
                  }

                  public static func makeEmbarkApiGraphQLMutation(data: AsEmbarkApiGraphQlMutation.Datum) -> Api {
                    return Api(unsafeResultMap: ["__typename": "EmbarkApiGraphQLMutation", "data": data.resultMap])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var apiFragment: ApiFragment {
                      get {
                        return ApiFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }

                  public var asEmbarkApiGraphQlQuery: AsEmbarkApiGraphQlQuery? {
                    get {
                      if !AsEmbarkApiGraphQlQuery.possibleTypes.contains(__typename) { return nil }
                      return AsEmbarkApiGraphQlQuery(unsafeResultMap: resultMap)
                    }
                    set {
                      guard let newValue = newValue else { return }
                      resultMap = newValue.resultMap
                    }
                  }

                  public struct AsEmbarkApiGraphQlQuery: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkApiGraphQLQuery"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("data", type: .nonNull(.object(Datum.selections))),
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public init(data: Datum) {
                      self.init(unsafeResultMap: ["__typename": "EmbarkApiGraphQLQuery", "data": data.resultMap])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var data: Datum {
                      get {
                        return Datum(unsafeResultMap: resultMap["data"]! as! ResultMap)
                      }
                      set {
                        resultMap.updateValue(newValue.resultMap, forKey: "data")
                      }
                    }

                    public var fragments: Fragments {
                      get {
                        return Fragments(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public struct Fragments {
                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public var apiFragment: ApiFragment {
                        get {
                          return ApiFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }
                    }

                    public struct Datum: GraphQLSelectionSet {
                      public static let possibleTypes: [String] = ["EmbarkApiGraphQLQueryData"]

                      public static var selections: [GraphQLSelection] {
                        return [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("next", type: .object(Next.selections)),
                          GraphQLField("query", type: .nonNull(.scalar(String.self))),
                          GraphQLField("variables", type: .nonNull(.list(.nonNull(.object(Variable.selections))))),
                          GraphQLField("results", alias: "queryResults", type: .nonNull(.list(.nonNull(.object(QueryResult.selections))))),
                          GraphQLField("errors", alias: "queryErrors", type: .nonNull(.list(.nonNull(.object(QueryError.selections))))),
                        ]
                      }

                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public init(next: Next? = nil, query: String, variables: [Variable], queryResults: [QueryResult], queryErrors: [QueryError]) {
                        self.init(unsafeResultMap: ["__typename": "EmbarkApiGraphQLQueryData", "next": next.flatMap { (value: Next) -> ResultMap in value.resultMap }, "query": query, "variables": variables.map { (value: Variable) -> ResultMap in value.resultMap }, "queryResults": queryResults.map { (value: QueryResult) -> ResultMap in value.resultMap }, "queryErrors": queryErrors.map { (value: QueryError) -> ResultMap in value.resultMap }])
                      }

                      public var __typename: String {
                        get {
                          return resultMap["__typename"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "__typename")
                        }
                      }

                      public var next: Next? {
                        get {
                          return (resultMap["next"] as? ResultMap).flatMap { Next(unsafeResultMap: $0) }
                        }
                        set {
                          resultMap.updateValue(newValue?.resultMap, forKey: "next")
                        }
                      }

                      public var query: String {
                        get {
                          return resultMap["query"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "query")
                        }
                      }

                      public var variables: [Variable] {
                        get {
                          return (resultMap["variables"] as! [ResultMap]).map { (value: ResultMap) -> Variable in Variable(unsafeResultMap: value) }
                        }
                        set {
                          resultMap.updateValue(newValue.map { (value: Variable) -> ResultMap in value.resultMap }, forKey: "variables")
                        }
                      }

                      public var queryResults: [QueryResult] {
                        get {
                          return (resultMap["queryResults"] as! [ResultMap]).map { (value: ResultMap) -> QueryResult in QueryResult(unsafeResultMap: value) }
                        }
                        set {
                          resultMap.updateValue(newValue.map { (value: QueryResult) -> ResultMap in value.resultMap }, forKey: "queryResults")
                        }
                      }

                      public var queryErrors: [QueryError] {
                        get {
                          return (resultMap["queryErrors"] as! [ResultMap]).map { (value: ResultMap) -> QueryError in QueryError(unsafeResultMap: value) }
                        }
                        set {
                          resultMap.updateValue(newValue.map { (value: QueryError) -> ResultMap in value.resultMap }, forKey: "queryErrors")
                        }
                      }

                      public struct Next: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkLink"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("name", type: .nonNull(.scalar(String.self))),
                            GraphQLField("label", type: .nonNull(.scalar(String.self))),
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public init(name: String, label: String) {
                          self.init(unsafeResultMap: ["__typename": "EmbarkLink", "name": name, "label": label])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var name: String {
                          get {
                            return resultMap["name"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "name")
                          }
                        }

                        public var label: String {
                          get {
                            return resultMap["label"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "label")
                          }
                        }

                        public var fragments: Fragments {
                          get {
                            return Fragments(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }

                        public struct Fragments {
                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public var embarkLinkFragment: EmbarkLinkFragment {
                            get {
                              return EmbarkLinkFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }
                        }
                      }

                      public struct Variable: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable", "EmbarkAPIGraphQLGeneratedVariable", "EmbarkAPIGraphQLMultiActionVariable", "EmbarkAPIGraphQLConstantVariable"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLTypeCase(
                              variants: ["EmbarkAPIGraphQLSingleVariable": AsEmbarkApiGraphQlSingleVariable.selections, "EmbarkAPIGraphQLGeneratedVariable": AsEmbarkApiGraphQlGeneratedVariable.selections, "EmbarkAPIGraphQLMultiActionVariable": AsEmbarkApiGraphQlMultiActionVariable.selections],
                              default: [
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              ]
                            )
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public static func makeEmbarkAPIGraphQLConstantVariable() -> Variable {
                          return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLConstantVariable"])
                        }

                        public static func makeEmbarkAPIGraphQLSingleVariable(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) -> Variable {
                          return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                        }

                        public static func makeEmbarkAPIGraphQLGeneratedVariable(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) -> Variable {
                          return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                        }

                        public static func makeEmbarkAPIGraphQLMultiActionVariable(key: String, variables: [AsEmbarkApiGraphQlMultiActionVariable.Variable]) -> Variable {
                          return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: AsEmbarkApiGraphQlMultiActionVariable.Variable) -> ResultMap in value.resultMap }])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var fragments: Fragments {
                          get {
                            return Fragments(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }

                        public struct Fragments {
                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public var apiVariablesFragment: ApiVariablesFragment {
                            get {
                              return ApiVariablesFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                            get {
                              if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                              return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              guard let newValue = newValue else { return }
                              resultMap += newValue.resultMap
                            }
                          }

                          public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                            get {
                              if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                              return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              guard let newValue = newValue else { return }
                              resultMap += newValue.resultMap
                            }
                          }

                          public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment? {
                            get {
                              if !ApiMultiActionVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                              return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              guard let newValue = newValue else { return }
                              resultMap += newValue.resultMap
                            }
                          }
                        }

                        public var asEmbarkApiGraphQlSingleVariable: AsEmbarkApiGraphQlSingleVariable? {
                          get {
                            if !AsEmbarkApiGraphQlSingleVariable.possibleTypes.contains(__typename) { return nil }
                            return AsEmbarkApiGraphQlSingleVariable(unsafeResultMap: resultMap)
                          }
                          set {
                            guard let newValue = newValue else { return }
                            resultMap = newValue.resultMap
                          }
                        }

                        public struct AsEmbarkApiGraphQlSingleVariable: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("key", type: .nonNull(.scalar(String.self))),
                              GraphQLField("from", type: .nonNull(.scalar(String.self))),
                              GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var key: String {
                            get {
                              return resultMap["key"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "key")
                            }
                          }

                          public var from: String {
                            get {
                              return resultMap["from"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "from")
                            }
                          }

                          public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
                            get {
                              return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "as")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var apiVariablesFragment: ApiVariablesFragment {
                              get {
                                return ApiVariablesFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiSingleVariableFragment: ApiSingleVariableFragment {
                              get {
                                return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                              get {
                                if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment? {
                              get {
                                if !ApiMultiActionVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }
                          }
                        }

                        public var asEmbarkApiGraphQlGeneratedVariable: AsEmbarkApiGraphQlGeneratedVariable? {
                          get {
                            if !AsEmbarkApiGraphQlGeneratedVariable.possibleTypes.contains(__typename) { return nil }
                            return AsEmbarkApiGraphQlGeneratedVariable(unsafeResultMap: resultMap)
                          }
                          set {
                            guard let newValue = newValue else { return }
                            resultMap = newValue.resultMap
                          }
                        }

                        public struct AsEmbarkApiGraphQlGeneratedVariable: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("key", type: .nonNull(.scalar(String.self))),
                              GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
                              GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var key: String {
                            get {
                              return resultMap["key"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "key")
                            }
                          }

                          public var storeAs: String {
                            get {
                              return resultMap["storeAs"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "storeAs")
                            }
                          }

                          public var type: EmbarkAPIGraphQLVariableGeneratedType {
                            get {
                              return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "type")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var apiVariablesFragment: ApiVariablesFragment {
                              get {
                                return ApiVariablesFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                              get {
                                if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment {
                              get {
                                return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment? {
                              get {
                                if !ApiMultiActionVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }
                          }
                        }

                        public var asEmbarkApiGraphQlMultiActionVariable: AsEmbarkApiGraphQlMultiActionVariable? {
                          get {
                            if !AsEmbarkApiGraphQlMultiActionVariable.possibleTypes.contains(__typename) { return nil }
                            return AsEmbarkApiGraphQlMultiActionVariable(unsafeResultMap: resultMap)
                          }
                          set {
                            guard let newValue = newValue else { return }
                            resultMap = newValue.resultMap
                          }
                        }

                        public struct AsEmbarkApiGraphQlMultiActionVariable: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkAPIGraphQLMultiActionVariable"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("key", type: .nonNull(.scalar(String.self))),
                              GraphQLField("variables", type: .nonNull(.list(.nonNull(.object(Variable.selections))))),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(key: String, variables: [Variable]) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: Variable) -> ResultMap in value.resultMap }])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var key: String {
                            get {
                              return resultMap["key"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "key")
                            }
                          }

                          public var variables: [Variable] {
                            get {
                              return (resultMap["variables"] as! [ResultMap]).map { (value: ResultMap) -> Variable in Variable(unsafeResultMap: value) }
                            }
                            set {
                              resultMap.updateValue(newValue.map { (value: Variable) -> ResultMap in value.resultMap }, forKey: "variables")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var apiVariablesFragment: ApiVariablesFragment {
                              get {
                                return ApiVariablesFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                              get {
                                if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                              get {
                                if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment {
                              get {
                                return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }
                          }

                          public struct Variable: GraphQLSelectionSet {
                            public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable", "EmbarkAPIGraphQLGeneratedVariable", "EmbarkAPIGraphQLMultiActionVariable", "EmbarkAPIGraphQLConstantVariable"]

                            public static var selections: [GraphQLSelection] {
                              return [
                                GraphQLTypeCase(
                                  variants: ["EmbarkAPIGraphQLSingleVariable": AsEmbarkApiGraphQlSingleVariable.selections, "EmbarkAPIGraphQLGeneratedVariable": AsEmbarkApiGraphQlGeneratedVariable.selections, "EmbarkAPIGraphQLMultiActionVariable": AsEmbarkApiGraphQlMultiActionVariable.selections],
                                  default: [
                                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  ]
                                )
                              ]
                            }

                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public static func makeEmbarkAPIGraphQLConstantVariable() -> Variable {
                              return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLConstantVariable"])
                            }

                            public static func makeEmbarkAPIGraphQLSingleVariable(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) -> Variable {
                              return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                            }

                            public static func makeEmbarkAPIGraphQLGeneratedVariable(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) -> Variable {
                              return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                            }

                            public static func makeEmbarkAPIGraphQLMultiActionVariable(key: String, variables: [AsEmbarkApiGraphQlMultiActionVariable.Variable]) -> Variable {
                              return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: AsEmbarkApiGraphQlMultiActionVariable.Variable) -> ResultMap in value.resultMap }])
                            }

                            public var __typename: String {
                              get {
                                return resultMap["__typename"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "__typename")
                              }
                            }

                            public var fragments: Fragments {
                              get {
                                return Fragments(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public struct Fragments {
                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                get {
                                  if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                  return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  guard let newValue = newValue else { return }
                                  resultMap += newValue.resultMap
                                }
                              }

                              public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                get {
                                  if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                  return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  guard let newValue = newValue else { return }
                                  resultMap += newValue.resultMap
                                }
                              }
                            }

                            public var asEmbarkApiGraphQlSingleVariable: AsEmbarkApiGraphQlSingleVariable? {
                              get {
                                if !AsEmbarkApiGraphQlSingleVariable.possibleTypes.contains(__typename) { return nil }
                                return AsEmbarkApiGraphQlSingleVariable(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap = newValue.resultMap
                              }
                            }

                            public struct AsEmbarkApiGraphQlSingleVariable: GraphQLSelectionSet {
                              public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

                              public static var selections: [GraphQLSelection] {
                                return [
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("from", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
                                ]
                              }

                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
                                self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                              }

                              public var __typename: String {
                                get {
                                  return resultMap["__typename"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "__typename")
                                }
                              }

                              public var key: String {
                                get {
                                  return resultMap["key"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "key")
                                }
                              }

                              public var from: String {
                                get {
                                  return resultMap["from"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "from")
                                }
                              }

                              public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
                                get {
                                  return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "as")
                                }
                              }

                              public var fragments: Fragments {
                                get {
                                  return Fragments(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public struct Fragments {
                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public var apiSingleVariableFragment: ApiSingleVariableFragment {
                                  get {
                                    return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    resultMap += newValue.resultMap
                                  }
                                }

                                public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                  get {
                                    if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                    return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap += newValue.resultMap
                                  }
                                }
                              }
                            }

                            public var asEmbarkApiGraphQlGeneratedVariable: AsEmbarkApiGraphQlGeneratedVariable? {
                              get {
                                if !AsEmbarkApiGraphQlGeneratedVariable.possibleTypes.contains(__typename) { return nil }
                                return AsEmbarkApiGraphQlGeneratedVariable(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap = newValue.resultMap
                              }
                            }

                            public struct AsEmbarkApiGraphQlGeneratedVariable: GraphQLSelectionSet {
                              public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

                              public static var selections: [GraphQLSelection] {
                                return [
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
                                ]
                              }

                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
                                self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                              }

                              public var __typename: String {
                                get {
                                  return resultMap["__typename"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "__typename")
                                }
                              }

                              public var key: String {
                                get {
                                  return resultMap["key"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "key")
                                }
                              }

                              public var storeAs: String {
                                get {
                                  return resultMap["storeAs"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "storeAs")
                                }
                              }

                              public var type: EmbarkAPIGraphQLVariableGeneratedType {
                                get {
                                  return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "type")
                                }
                              }

                              public var fragments: Fragments {
                                get {
                                  return Fragments(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public struct Fragments {
                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                  get {
                                    if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                    return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap += newValue.resultMap
                                  }
                                }

                                public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment {
                                  get {
                                    return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    resultMap += newValue.resultMap
                                  }
                                }
                              }
                            }

                            public var asEmbarkApiGraphQlMultiActionVariable: AsEmbarkApiGraphQlMultiActionVariable? {
                              get {
                                if !AsEmbarkApiGraphQlMultiActionVariable.possibleTypes.contains(__typename) { return nil }
                                return AsEmbarkApiGraphQlMultiActionVariable(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap = newValue.resultMap
                              }
                            }

                            public struct AsEmbarkApiGraphQlMultiActionVariable: GraphQLSelectionSet {
                              public static let possibleTypes: [String] = ["EmbarkAPIGraphQLMultiActionVariable"]

                              public static var selections: [GraphQLSelection] {
                                return [
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("variables", type: .nonNull(.list(.nonNull(.object(Variable.selections))))),
                                ]
                              }

                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public init(key: String, variables: [Variable]) {
                                self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: Variable) -> ResultMap in value.resultMap }])
                              }

                              public var __typename: String {
                                get {
                                  return resultMap["__typename"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "__typename")
                                }
                              }

                              public var key: String {
                                get {
                                  return resultMap["key"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "key")
                                }
                              }

                              public var variables: [Variable] {
                                get {
                                  return (resultMap["variables"] as! [ResultMap]).map { (value: ResultMap) -> Variable in Variable(unsafeResultMap: value) }
                                }
                                set {
                                  resultMap.updateValue(newValue.map { (value: Variable) -> ResultMap in value.resultMap }, forKey: "variables")
                                }
                              }

                              public var fragments: Fragments {
                                get {
                                  return Fragments(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public struct Fragments {
                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                  get {
                                    if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                    return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap += newValue.resultMap
                                  }
                                }

                                public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                  get {
                                    if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                    return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap += newValue.resultMap
                                  }
                                }
                              }

                              public struct Variable: GraphQLSelectionSet {
                                public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable", "EmbarkAPIGraphQLGeneratedVariable", "EmbarkAPIGraphQLMultiActionVariable", "EmbarkAPIGraphQLConstantVariable"]

                                public static var selections: [GraphQLSelection] {
                                  return [
                                    GraphQLTypeCase(
                                      variants: ["EmbarkAPIGraphQLSingleVariable": AsEmbarkApiGraphQlSingleVariable.selections, "EmbarkAPIGraphQLGeneratedVariable": AsEmbarkApiGraphQlGeneratedVariable.selections],
                                      default: [
                                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                      ]
                                    )
                                  ]
                                }

                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public static func makeEmbarkAPIGraphQLMultiActionVariable() -> Variable {
                                  return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable"])
                                }

                                public static func makeEmbarkAPIGraphQLConstantVariable() -> Variable {
                                  return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLConstantVariable"])
                                }

                                public static func makeEmbarkAPIGraphQLSingleVariable(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) -> Variable {
                                  return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                                }

                                public static func makeEmbarkAPIGraphQLGeneratedVariable(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) -> Variable {
                                  return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                                }

                                public var __typename: String {
                                  get {
                                    return resultMap["__typename"]! as! String
                                  }
                                  set {
                                    resultMap.updateValue(newValue, forKey: "__typename")
                                  }
                                }

                                public var fragments: Fragments {
                                  get {
                                    return Fragments(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    resultMap += newValue.resultMap
                                  }
                                }

                                public struct Fragments {
                                  public private(set) var resultMap: ResultMap

                                  public init(unsafeResultMap: ResultMap) {
                                    self.resultMap = unsafeResultMap
                                  }

                                  public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                    get {
                                      if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                      return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      guard let newValue = newValue else { return }
                                      resultMap += newValue.resultMap
                                    }
                                  }

                                  public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                    get {
                                      if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                      return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      guard let newValue = newValue else { return }
                                      resultMap += newValue.resultMap
                                    }
                                  }
                                }

                                public var asEmbarkApiGraphQlSingleVariable: AsEmbarkApiGraphQlSingleVariable? {
                                  get {
                                    if !AsEmbarkApiGraphQlSingleVariable.possibleTypes.contains(__typename) { return nil }
                                    return AsEmbarkApiGraphQlSingleVariable(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap = newValue.resultMap
                                  }
                                }

                                public struct AsEmbarkApiGraphQlSingleVariable: GraphQLSelectionSet {
                                  public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

                                  public static var selections: [GraphQLSelection] {
                                    return [
                                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("from", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
                                    ]
                                  }

                                  public private(set) var resultMap: ResultMap

                                  public init(unsafeResultMap: ResultMap) {
                                    self.resultMap = unsafeResultMap
                                  }

                                  public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
                                    self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                                  }

                                  public var __typename: String {
                                    get {
                                      return resultMap["__typename"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "__typename")
                                    }
                                  }

                                  public var key: String {
                                    get {
                                      return resultMap["key"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "key")
                                    }
                                  }

                                  public var from: String {
                                    get {
                                      return resultMap["from"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "from")
                                    }
                                  }

                                  public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
                                    get {
                                      return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "as")
                                    }
                                  }

                                  public var fragments: Fragments {
                                    get {
                                      return Fragments(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      resultMap += newValue.resultMap
                                    }
                                  }

                                  public struct Fragments {
                                    public private(set) var resultMap: ResultMap

                                    public init(unsafeResultMap: ResultMap) {
                                      self.resultMap = unsafeResultMap
                                    }

                                    public var apiSingleVariableFragment: ApiSingleVariableFragment {
                                      get {
                                        return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                      }
                                      set {
                                        resultMap += newValue.resultMap
                                      }
                                    }

                                    public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                      get {
                                        if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                        return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                      }
                                      set {
                                        guard let newValue = newValue else { return }
                                        resultMap += newValue.resultMap
                                      }
                                    }
                                  }
                                }

                                public var asEmbarkApiGraphQlGeneratedVariable: AsEmbarkApiGraphQlGeneratedVariable? {
                                  get {
                                    if !AsEmbarkApiGraphQlGeneratedVariable.possibleTypes.contains(__typename) { return nil }
                                    return AsEmbarkApiGraphQlGeneratedVariable(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap = newValue.resultMap
                                  }
                                }

                                public struct AsEmbarkApiGraphQlGeneratedVariable: GraphQLSelectionSet {
                                  public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

                                  public static var selections: [GraphQLSelection] {
                                    return [
                                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
                                    ]
                                  }

                                  public private(set) var resultMap: ResultMap

                                  public init(unsafeResultMap: ResultMap) {
                                    self.resultMap = unsafeResultMap
                                  }

                                  public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
                                    self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                                  }

                                  public var __typename: String {
                                    get {
                                      return resultMap["__typename"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "__typename")
                                    }
                                  }

                                  public var key: String {
                                    get {
                                      return resultMap["key"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "key")
                                    }
                                  }

                                  public var storeAs: String {
                                    get {
                                      return resultMap["storeAs"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "storeAs")
                                    }
                                  }

                                  public var type: EmbarkAPIGraphQLVariableGeneratedType {
                                    get {
                                      return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "type")
                                    }
                                  }

                                  public var fragments: Fragments {
                                    get {
                                      return Fragments(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      resultMap += newValue.resultMap
                                    }
                                  }

                                  public struct Fragments {
                                    public private(set) var resultMap: ResultMap

                                    public init(unsafeResultMap: ResultMap) {
                                      self.resultMap = unsafeResultMap
                                    }

                                    public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                      get {
                                        if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                        return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                      }
                                      set {
                                        guard let newValue = newValue else { return }
                                        resultMap += newValue.resultMap
                                      }
                                    }

                                    public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment {
                                      get {
                                        return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                      }
                                      set {
                                        resultMap += newValue.resultMap
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }

                      public struct QueryResult: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkAPIGraphQLResult"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("key", type: .nonNull(.scalar(String.self))),
                            GraphQLField("as", type: .nonNull(.scalar(String.self))),
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public init(key: String, `as`: String) {
                          self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLResult", "key": key, "as": `as`])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var key: String {
                          get {
                            return resultMap["key"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "key")
                          }
                        }

                        public var `as`: String {
                          get {
                            return resultMap["as"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "as")
                          }
                        }
                      }

                      public struct QueryError: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkAPIGraphQLError"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("contains", type: .scalar(String.self)),
                            GraphQLField("next", type: .nonNull(.object(Next.selections))),
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public init(contains: String? = nil, next: Next) {
                          self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLError", "contains": contains, "next": next.resultMap])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var contains: String? {
                          get {
                            return resultMap["contains"] as? String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "contains")
                          }
                        }

                        public var next: Next {
                          get {
                            return Next(unsafeResultMap: resultMap["next"]! as! ResultMap)
                          }
                          set {
                            resultMap.updateValue(newValue.resultMap, forKey: "next")
                          }
                        }

                        public struct Next: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkLink"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("name", type: .nonNull(.scalar(String.self))),
                              GraphQLField("label", type: .nonNull(.scalar(String.self))),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(name: String, label: String) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkLink", "name": name, "label": label])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var name: String {
                            get {
                              return resultMap["name"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "name")
                            }
                          }

                          public var label: String {
                            get {
                              return resultMap["label"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "label")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var embarkLinkFragment: EmbarkLinkFragment {
                              get {
                                return EmbarkLinkFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }
                          }
                        }
                      }
                    }
                  }

                  public var asEmbarkApiGraphQlMutation: AsEmbarkApiGraphQlMutation? {
                    get {
                      if !AsEmbarkApiGraphQlMutation.possibleTypes.contains(__typename) { return nil }
                      return AsEmbarkApiGraphQlMutation(unsafeResultMap: resultMap)
                    }
                    set {
                      guard let newValue = newValue else { return }
                      resultMap = newValue.resultMap
                    }
                  }

                  public struct AsEmbarkApiGraphQlMutation: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkApiGraphQLMutation"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("data", type: .nonNull(.object(Datum.selections))),
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public init(data: Datum) {
                      self.init(unsafeResultMap: ["__typename": "EmbarkApiGraphQLMutation", "data": data.resultMap])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var data: Datum {
                      get {
                        return Datum(unsafeResultMap: resultMap["data"]! as! ResultMap)
                      }
                      set {
                        resultMap.updateValue(newValue.resultMap, forKey: "data")
                      }
                    }

                    public var fragments: Fragments {
                      get {
                        return Fragments(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public struct Fragments {
                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public var apiFragment: ApiFragment {
                        get {
                          return ApiFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }
                    }

                    public struct Datum: GraphQLSelectionSet {
                      public static let possibleTypes: [String] = ["EmbarkApiGraphQLMutationData"]

                      public static var selections: [GraphQLSelection] {
                        return [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("next", type: .object(Next.selections)),
                          GraphQLField("mutation", type: .nonNull(.scalar(String.self))),
                          GraphQLField("variables", type: .nonNull(.list(.nonNull(.object(Variable.selections))))),
                          GraphQLField("results", alias: "mutationResults", type: .nonNull(.list(.object(MutationResult.selections)))),
                          GraphQLField("errors", alias: "mutationErrors", type: .nonNull(.list(.nonNull(.object(MutationError.selections))))),
                        ]
                      }

                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public init(next: Next? = nil, mutation: String, variables: [Variable], mutationResults: [MutationResult?], mutationErrors: [MutationError]) {
                        self.init(unsafeResultMap: ["__typename": "EmbarkApiGraphQLMutationData", "next": next.flatMap { (value: Next) -> ResultMap in value.resultMap }, "mutation": mutation, "variables": variables.map { (value: Variable) -> ResultMap in value.resultMap }, "mutationResults": mutationResults.map { (value: MutationResult?) -> ResultMap? in value.flatMap { (value: MutationResult) -> ResultMap in value.resultMap } }, "mutationErrors": mutationErrors.map { (value: MutationError) -> ResultMap in value.resultMap }])
                      }

                      public var __typename: String {
                        get {
                          return resultMap["__typename"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "__typename")
                        }
                      }

                      public var next: Next? {
                        get {
                          return (resultMap["next"] as? ResultMap).flatMap { Next(unsafeResultMap: $0) }
                        }
                        set {
                          resultMap.updateValue(newValue?.resultMap, forKey: "next")
                        }
                      }

                      public var mutation: String {
                        get {
                          return resultMap["mutation"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "mutation")
                        }
                      }

                      public var variables: [Variable] {
                        get {
                          return (resultMap["variables"] as! [ResultMap]).map { (value: ResultMap) -> Variable in Variable(unsafeResultMap: value) }
                        }
                        set {
                          resultMap.updateValue(newValue.map { (value: Variable) -> ResultMap in value.resultMap }, forKey: "variables")
                        }
                      }

                      public var mutationResults: [MutationResult?] {
                        get {
                          return (resultMap["mutationResults"] as! [ResultMap?]).map { (value: ResultMap?) -> MutationResult? in value.flatMap { (value: ResultMap) -> MutationResult in MutationResult(unsafeResultMap: value) } }
                        }
                        set {
                          resultMap.updateValue(newValue.map { (value: MutationResult?) -> ResultMap? in value.flatMap { (value: MutationResult) -> ResultMap in value.resultMap } }, forKey: "mutationResults")
                        }
                      }

                      public var mutationErrors: [MutationError] {
                        get {
                          return (resultMap["mutationErrors"] as! [ResultMap]).map { (value: ResultMap) -> MutationError in MutationError(unsafeResultMap: value) }
                        }
                        set {
                          resultMap.updateValue(newValue.map { (value: MutationError) -> ResultMap in value.resultMap }, forKey: "mutationErrors")
                        }
                      }

                      public struct Next: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkLink"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("name", type: .nonNull(.scalar(String.self))),
                            GraphQLField("label", type: .nonNull(.scalar(String.self))),
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public init(name: String, label: String) {
                          self.init(unsafeResultMap: ["__typename": "EmbarkLink", "name": name, "label": label])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var name: String {
                          get {
                            return resultMap["name"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "name")
                          }
                        }

                        public var label: String {
                          get {
                            return resultMap["label"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "label")
                          }
                        }

                        public var fragments: Fragments {
                          get {
                            return Fragments(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }

                        public struct Fragments {
                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public var embarkLinkFragment: EmbarkLinkFragment {
                            get {
                              return EmbarkLinkFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }
                        }
                      }

                      public struct Variable: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable", "EmbarkAPIGraphQLGeneratedVariable", "EmbarkAPIGraphQLMultiActionVariable", "EmbarkAPIGraphQLConstantVariable"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLTypeCase(
                              variants: ["EmbarkAPIGraphQLSingleVariable": AsEmbarkApiGraphQlSingleVariable.selections, "EmbarkAPIGraphQLGeneratedVariable": AsEmbarkApiGraphQlGeneratedVariable.selections, "EmbarkAPIGraphQLMultiActionVariable": AsEmbarkApiGraphQlMultiActionVariable.selections],
                              default: [
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              ]
                            )
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public static func makeEmbarkAPIGraphQLConstantVariable() -> Variable {
                          return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLConstantVariable"])
                        }

                        public static func makeEmbarkAPIGraphQLSingleVariable(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) -> Variable {
                          return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                        }

                        public static func makeEmbarkAPIGraphQLGeneratedVariable(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) -> Variable {
                          return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                        }

                        public static func makeEmbarkAPIGraphQLMultiActionVariable(key: String, variables: [AsEmbarkApiGraphQlMultiActionVariable.Variable]) -> Variable {
                          return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: AsEmbarkApiGraphQlMultiActionVariable.Variable) -> ResultMap in value.resultMap }])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var fragments: Fragments {
                          get {
                            return Fragments(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }

                        public struct Fragments {
                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public var apiVariablesFragment: ApiVariablesFragment {
                            get {
                              return ApiVariablesFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                            get {
                              if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                              return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              guard let newValue = newValue else { return }
                              resultMap += newValue.resultMap
                            }
                          }

                          public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                            get {
                              if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                              return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              guard let newValue = newValue else { return }
                              resultMap += newValue.resultMap
                            }
                          }

                          public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment? {
                            get {
                              if !ApiMultiActionVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                              return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              guard let newValue = newValue else { return }
                              resultMap += newValue.resultMap
                            }
                          }
                        }

                        public var asEmbarkApiGraphQlSingleVariable: AsEmbarkApiGraphQlSingleVariable? {
                          get {
                            if !AsEmbarkApiGraphQlSingleVariable.possibleTypes.contains(__typename) { return nil }
                            return AsEmbarkApiGraphQlSingleVariable(unsafeResultMap: resultMap)
                          }
                          set {
                            guard let newValue = newValue else { return }
                            resultMap = newValue.resultMap
                          }
                        }

                        public struct AsEmbarkApiGraphQlSingleVariable: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("key", type: .nonNull(.scalar(String.self))),
                              GraphQLField("from", type: .nonNull(.scalar(String.self))),
                              GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var key: String {
                            get {
                              return resultMap["key"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "key")
                            }
                          }

                          public var from: String {
                            get {
                              return resultMap["from"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "from")
                            }
                          }

                          public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
                            get {
                              return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "as")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var apiVariablesFragment: ApiVariablesFragment {
                              get {
                                return ApiVariablesFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiSingleVariableFragment: ApiSingleVariableFragment {
                              get {
                                return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                              get {
                                if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment? {
                              get {
                                if !ApiMultiActionVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }
                          }
                        }

                        public var asEmbarkApiGraphQlGeneratedVariable: AsEmbarkApiGraphQlGeneratedVariable? {
                          get {
                            if !AsEmbarkApiGraphQlGeneratedVariable.possibleTypes.contains(__typename) { return nil }
                            return AsEmbarkApiGraphQlGeneratedVariable(unsafeResultMap: resultMap)
                          }
                          set {
                            guard let newValue = newValue else { return }
                            resultMap = newValue.resultMap
                          }
                        }

                        public struct AsEmbarkApiGraphQlGeneratedVariable: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("key", type: .nonNull(.scalar(String.self))),
                              GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
                              GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var key: String {
                            get {
                              return resultMap["key"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "key")
                            }
                          }

                          public var storeAs: String {
                            get {
                              return resultMap["storeAs"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "storeAs")
                            }
                          }

                          public var type: EmbarkAPIGraphQLVariableGeneratedType {
                            get {
                              return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "type")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var apiVariablesFragment: ApiVariablesFragment {
                              get {
                                return ApiVariablesFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                              get {
                                if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment {
                              get {
                                return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment? {
                              get {
                                if !ApiMultiActionVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }
                          }
                        }

                        public var asEmbarkApiGraphQlMultiActionVariable: AsEmbarkApiGraphQlMultiActionVariable? {
                          get {
                            if !AsEmbarkApiGraphQlMultiActionVariable.possibleTypes.contains(__typename) { return nil }
                            return AsEmbarkApiGraphQlMultiActionVariable(unsafeResultMap: resultMap)
                          }
                          set {
                            guard let newValue = newValue else { return }
                            resultMap = newValue.resultMap
                          }
                        }

                        public struct AsEmbarkApiGraphQlMultiActionVariable: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkAPIGraphQLMultiActionVariable"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("key", type: .nonNull(.scalar(String.self))),
                              GraphQLField("variables", type: .nonNull(.list(.nonNull(.object(Variable.selections))))),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(key: String, variables: [Variable]) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: Variable) -> ResultMap in value.resultMap }])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var key: String {
                            get {
                              return resultMap["key"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "key")
                            }
                          }

                          public var variables: [Variable] {
                            get {
                              return (resultMap["variables"] as! [ResultMap]).map { (value: ResultMap) -> Variable in Variable(unsafeResultMap: value) }
                            }
                            set {
                              resultMap.updateValue(newValue.map { (value: Variable) -> ResultMap in value.resultMap }, forKey: "variables")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var apiVariablesFragment: ApiVariablesFragment {
                              get {
                                return ApiVariablesFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                              get {
                                if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                              get {
                                if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment {
                              get {
                                return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }
                          }

                          public struct Variable: GraphQLSelectionSet {
                            public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable", "EmbarkAPIGraphQLGeneratedVariable", "EmbarkAPIGraphQLMultiActionVariable", "EmbarkAPIGraphQLConstantVariable"]

                            public static var selections: [GraphQLSelection] {
                              return [
                                GraphQLTypeCase(
                                  variants: ["EmbarkAPIGraphQLSingleVariable": AsEmbarkApiGraphQlSingleVariable.selections, "EmbarkAPIGraphQLGeneratedVariable": AsEmbarkApiGraphQlGeneratedVariable.selections, "EmbarkAPIGraphQLMultiActionVariable": AsEmbarkApiGraphQlMultiActionVariable.selections],
                                  default: [
                                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  ]
                                )
                              ]
                            }

                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public static func makeEmbarkAPIGraphQLConstantVariable() -> Variable {
                              return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLConstantVariable"])
                            }

                            public static func makeEmbarkAPIGraphQLSingleVariable(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) -> Variable {
                              return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                            }

                            public static func makeEmbarkAPIGraphQLGeneratedVariable(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) -> Variable {
                              return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                            }

                            public static func makeEmbarkAPIGraphQLMultiActionVariable(key: String, variables: [AsEmbarkApiGraphQlMultiActionVariable.Variable]) -> Variable {
                              return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: AsEmbarkApiGraphQlMultiActionVariable.Variable) -> ResultMap in value.resultMap }])
                            }

                            public var __typename: String {
                              get {
                                return resultMap["__typename"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "__typename")
                              }
                            }

                            public var fragments: Fragments {
                              get {
                                return Fragments(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public struct Fragments {
                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                get {
                                  if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                  return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  guard let newValue = newValue else { return }
                                  resultMap += newValue.resultMap
                                }
                              }

                              public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                get {
                                  if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                  return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  guard let newValue = newValue else { return }
                                  resultMap += newValue.resultMap
                                }
                              }
                            }

                            public var asEmbarkApiGraphQlSingleVariable: AsEmbarkApiGraphQlSingleVariable? {
                              get {
                                if !AsEmbarkApiGraphQlSingleVariable.possibleTypes.contains(__typename) { return nil }
                                return AsEmbarkApiGraphQlSingleVariable(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap = newValue.resultMap
                              }
                            }

                            public struct AsEmbarkApiGraphQlSingleVariable: GraphQLSelectionSet {
                              public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

                              public static var selections: [GraphQLSelection] {
                                return [
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("from", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
                                ]
                              }

                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
                                self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                              }

                              public var __typename: String {
                                get {
                                  return resultMap["__typename"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "__typename")
                                }
                              }

                              public var key: String {
                                get {
                                  return resultMap["key"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "key")
                                }
                              }

                              public var from: String {
                                get {
                                  return resultMap["from"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "from")
                                }
                              }

                              public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
                                get {
                                  return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "as")
                                }
                              }

                              public var fragments: Fragments {
                                get {
                                  return Fragments(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public struct Fragments {
                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public var apiSingleVariableFragment: ApiSingleVariableFragment {
                                  get {
                                    return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    resultMap += newValue.resultMap
                                  }
                                }

                                public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                  get {
                                    if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                    return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap += newValue.resultMap
                                  }
                                }
                              }
                            }

                            public var asEmbarkApiGraphQlGeneratedVariable: AsEmbarkApiGraphQlGeneratedVariable? {
                              get {
                                if !AsEmbarkApiGraphQlGeneratedVariable.possibleTypes.contains(__typename) { return nil }
                                return AsEmbarkApiGraphQlGeneratedVariable(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap = newValue.resultMap
                              }
                            }

                            public struct AsEmbarkApiGraphQlGeneratedVariable: GraphQLSelectionSet {
                              public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

                              public static var selections: [GraphQLSelection] {
                                return [
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
                                ]
                              }

                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
                                self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                              }

                              public var __typename: String {
                                get {
                                  return resultMap["__typename"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "__typename")
                                }
                              }

                              public var key: String {
                                get {
                                  return resultMap["key"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "key")
                                }
                              }

                              public var storeAs: String {
                                get {
                                  return resultMap["storeAs"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "storeAs")
                                }
                              }

                              public var type: EmbarkAPIGraphQLVariableGeneratedType {
                                get {
                                  return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "type")
                                }
                              }

                              public var fragments: Fragments {
                                get {
                                  return Fragments(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public struct Fragments {
                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                  get {
                                    if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                    return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap += newValue.resultMap
                                  }
                                }

                                public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment {
                                  get {
                                    return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    resultMap += newValue.resultMap
                                  }
                                }
                              }
                            }

                            public var asEmbarkApiGraphQlMultiActionVariable: AsEmbarkApiGraphQlMultiActionVariable? {
                              get {
                                if !AsEmbarkApiGraphQlMultiActionVariable.possibleTypes.contains(__typename) { return nil }
                                return AsEmbarkApiGraphQlMultiActionVariable(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap = newValue.resultMap
                              }
                            }

                            public struct AsEmbarkApiGraphQlMultiActionVariable: GraphQLSelectionSet {
                              public static let possibleTypes: [String] = ["EmbarkAPIGraphQLMultiActionVariable"]

                              public static var selections: [GraphQLSelection] {
                                return [
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("variables", type: .nonNull(.list(.nonNull(.object(Variable.selections))))),
                                ]
                              }

                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public init(key: String, variables: [Variable]) {
                                self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: Variable) -> ResultMap in value.resultMap }])
                              }

                              public var __typename: String {
                                get {
                                  return resultMap["__typename"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "__typename")
                                }
                              }

                              public var key: String {
                                get {
                                  return resultMap["key"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "key")
                                }
                              }

                              public var variables: [Variable] {
                                get {
                                  return (resultMap["variables"] as! [ResultMap]).map { (value: ResultMap) -> Variable in Variable(unsafeResultMap: value) }
                                }
                                set {
                                  resultMap.updateValue(newValue.map { (value: Variable) -> ResultMap in value.resultMap }, forKey: "variables")
                                }
                              }

                              public var fragments: Fragments {
                                get {
                                  return Fragments(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public struct Fragments {
                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                  get {
                                    if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                    return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap += newValue.resultMap
                                  }
                                }

                                public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                  get {
                                    if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                    return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap += newValue.resultMap
                                  }
                                }
                              }

                              public struct Variable: GraphQLSelectionSet {
                                public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable", "EmbarkAPIGraphQLGeneratedVariable", "EmbarkAPIGraphQLMultiActionVariable", "EmbarkAPIGraphQLConstantVariable"]

                                public static var selections: [GraphQLSelection] {
                                  return [
                                    GraphQLTypeCase(
                                      variants: ["EmbarkAPIGraphQLSingleVariable": AsEmbarkApiGraphQlSingleVariable.selections, "EmbarkAPIGraphQLGeneratedVariable": AsEmbarkApiGraphQlGeneratedVariable.selections],
                                      default: [
                                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                      ]
                                    )
                                  ]
                                }

                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public static func makeEmbarkAPIGraphQLMultiActionVariable() -> Variable {
                                  return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable"])
                                }

                                public static func makeEmbarkAPIGraphQLConstantVariable() -> Variable {
                                  return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLConstantVariable"])
                                }

                                public static func makeEmbarkAPIGraphQLSingleVariable(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) -> Variable {
                                  return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                                }

                                public static func makeEmbarkAPIGraphQLGeneratedVariable(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) -> Variable {
                                  return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                                }

                                public var __typename: String {
                                  get {
                                    return resultMap["__typename"]! as! String
                                  }
                                  set {
                                    resultMap.updateValue(newValue, forKey: "__typename")
                                  }
                                }

                                public var fragments: Fragments {
                                  get {
                                    return Fragments(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    resultMap += newValue.resultMap
                                  }
                                }

                                public struct Fragments {
                                  public private(set) var resultMap: ResultMap

                                  public init(unsafeResultMap: ResultMap) {
                                    self.resultMap = unsafeResultMap
                                  }

                                  public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                    get {
                                      if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                      return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      guard let newValue = newValue else { return }
                                      resultMap += newValue.resultMap
                                    }
                                  }

                                  public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                    get {
                                      if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                      return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      guard let newValue = newValue else { return }
                                      resultMap += newValue.resultMap
                                    }
                                  }
                                }

                                public var asEmbarkApiGraphQlSingleVariable: AsEmbarkApiGraphQlSingleVariable? {
                                  get {
                                    if !AsEmbarkApiGraphQlSingleVariable.possibleTypes.contains(__typename) { return nil }
                                    return AsEmbarkApiGraphQlSingleVariable(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap = newValue.resultMap
                                  }
                                }

                                public struct AsEmbarkApiGraphQlSingleVariable: GraphQLSelectionSet {
                                  public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

                                  public static var selections: [GraphQLSelection] {
                                    return [
                                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("from", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
                                    ]
                                  }

                                  public private(set) var resultMap: ResultMap

                                  public init(unsafeResultMap: ResultMap) {
                                    self.resultMap = unsafeResultMap
                                  }

                                  public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
                                    self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                                  }

                                  public var __typename: String {
                                    get {
                                      return resultMap["__typename"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "__typename")
                                    }
                                  }

                                  public var key: String {
                                    get {
                                      return resultMap["key"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "key")
                                    }
                                  }

                                  public var from: String {
                                    get {
                                      return resultMap["from"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "from")
                                    }
                                  }

                                  public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
                                    get {
                                      return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "as")
                                    }
                                  }

                                  public var fragments: Fragments {
                                    get {
                                      return Fragments(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      resultMap += newValue.resultMap
                                    }
                                  }

                                  public struct Fragments {
                                    public private(set) var resultMap: ResultMap

                                    public init(unsafeResultMap: ResultMap) {
                                      self.resultMap = unsafeResultMap
                                    }

                                    public var apiSingleVariableFragment: ApiSingleVariableFragment {
                                      get {
                                        return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                      }
                                      set {
                                        resultMap += newValue.resultMap
                                      }
                                    }

                                    public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                      get {
                                        if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                        return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                      }
                                      set {
                                        guard let newValue = newValue else { return }
                                        resultMap += newValue.resultMap
                                      }
                                    }
                                  }
                                }

                                public var asEmbarkApiGraphQlGeneratedVariable: AsEmbarkApiGraphQlGeneratedVariable? {
                                  get {
                                    if !AsEmbarkApiGraphQlGeneratedVariable.possibleTypes.contains(__typename) { return nil }
                                    return AsEmbarkApiGraphQlGeneratedVariable(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap = newValue.resultMap
                                  }
                                }

                                public struct AsEmbarkApiGraphQlGeneratedVariable: GraphQLSelectionSet {
                                  public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

                                  public static var selections: [GraphQLSelection] {
                                    return [
                                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
                                    ]
                                  }

                                  public private(set) var resultMap: ResultMap

                                  public init(unsafeResultMap: ResultMap) {
                                    self.resultMap = unsafeResultMap
                                  }

                                  public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
                                    self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                                  }

                                  public var __typename: String {
                                    get {
                                      return resultMap["__typename"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "__typename")
                                    }
                                  }

                                  public var key: String {
                                    get {
                                      return resultMap["key"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "key")
                                    }
                                  }

                                  public var storeAs: String {
                                    get {
                                      return resultMap["storeAs"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "storeAs")
                                    }
                                  }

                                  public var type: EmbarkAPIGraphQLVariableGeneratedType {
                                    get {
                                      return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "type")
                                    }
                                  }

                                  public var fragments: Fragments {
                                    get {
                                      return Fragments(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      resultMap += newValue.resultMap
                                    }
                                  }

                                  public struct Fragments {
                                    public private(set) var resultMap: ResultMap

                                    public init(unsafeResultMap: ResultMap) {
                                      self.resultMap = unsafeResultMap
                                    }

                                    public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                      get {
                                        if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                        return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                      }
                                      set {
                                        guard let newValue = newValue else { return }
                                        resultMap += newValue.resultMap
                                      }
                                    }

                                    public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment {
                                      get {
                                        return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                      }
                                      set {
                                        resultMap += newValue.resultMap
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }

                      public struct MutationResult: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkAPIGraphQLResult"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("key", type: .nonNull(.scalar(String.self))),
                            GraphQLField("as", type: .nonNull(.scalar(String.self))),
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public init(key: String, `as`: String) {
                          self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLResult", "key": key, "as": `as`])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var key: String {
                          get {
                            return resultMap["key"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "key")
                          }
                        }

                        public var `as`: String {
                          get {
                            return resultMap["as"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "as")
                          }
                        }
                      }

                      public struct MutationError: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkAPIGraphQLError"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("contains", type: .scalar(String.self)),
                            GraphQLField("next", type: .nonNull(.object(Next.selections))),
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public init(contains: String? = nil, next: Next) {
                          self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLError", "contains": contains, "next": next.resultMap])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var contains: String? {
                          get {
                            return resultMap["contains"] as? String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "contains")
                          }
                        }

                        public var next: Next {
                          get {
                            return Next(unsafeResultMap: resultMap["next"]! as! ResultMap)
                          }
                          set {
                            resultMap.updateValue(newValue.resultMap, forKey: "next")
                          }
                        }

                        public struct Next: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkLink"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("name", type: .nonNull(.scalar(String.self))),
                              GraphQLField("label", type: .nonNull(.scalar(String.self))),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(name: String, label: String) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkLink", "name": name, "label": label])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var name: String {
                            get {
                              return resultMap["name"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "name")
                            }
                          }

                          public var label: String {
                            get {
                              return resultMap["label"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "label")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var embarkLinkFragment: EmbarkLinkFragment {
                              get {
                                return EmbarkLinkFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }

            public var asEmbarkTextActionSet: AsEmbarkTextActionSet? {
              get {
                if !AsEmbarkTextActionSet.possibleTypes.contains(__typename) { return nil }
                return AsEmbarkTextActionSet(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap = newValue.resultMap
              }
            }

            public struct AsEmbarkTextActionSet: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkTextActionSet"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("component", type: .nonNull(.scalar(String.self))),
                  GraphQLField("data", alias: "textActionSetData", type: .object(TextActionSetDatum.selections)),
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public init(component: String, textActionSetData: TextActionSetDatum? = nil) {
                self.init(unsafeResultMap: ["__typename": "EmbarkTextActionSet", "component": component, "textActionSetData": textActionSetData.flatMap { (value: TextActionSetDatum) -> ResultMap in value.resultMap }])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var component: String {
                get {
                  return resultMap["component"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "component")
                }
              }

              public var textActionSetData: TextActionSetDatum? {
                get {
                  return (resultMap["textActionSetData"] as? ResultMap).flatMap { TextActionSetDatum(unsafeResultMap: $0) }
                }
                set {
                  resultMap.updateValue(newValue?.resultMap, forKey: "textActionSetData")
                }
              }

              public struct TextActionSetDatum: GraphQLSelectionSet {
                public static let possibleTypes: [String] = ["EmbarkTextActionSetData"]

                public static var selections: [GraphQLSelection] {
                  return [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("link", type: .nonNull(.object(Link.selections))),
                    GraphQLField("api", type: .object(Api.selections)),
                    GraphQLField("textActions", type: .nonNull(.list(.nonNull(.object(TextAction.selections))))),
                  ]
                }

                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public init(link: Link, api: Api? = nil, textActions: [TextAction]) {
                  self.init(unsafeResultMap: ["__typename": "EmbarkTextActionSetData", "link": link.resultMap, "api": api.flatMap { (value: Api) -> ResultMap in value.resultMap }, "textActions": textActions.map { (value: TextAction) -> ResultMap in value.resultMap }])
                }

                public var __typename: String {
                  get {
                    return resultMap["__typename"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "__typename")
                  }
                }

                public var link: Link {
                  get {
                    return Link(unsafeResultMap: resultMap["link"]! as! ResultMap)
                  }
                  set {
                    resultMap.updateValue(newValue.resultMap, forKey: "link")
                  }
                }

                public var api: Api? {
                  get {
                    return (resultMap["api"] as? ResultMap).flatMap { Api(unsafeResultMap: $0) }
                  }
                  set {
                    resultMap.updateValue(newValue?.resultMap, forKey: "api")
                  }
                }

                public var textActions: [TextAction] {
                  get {
                    return (resultMap["textActions"] as! [ResultMap]).map { (value: ResultMap) -> TextAction in TextAction(unsafeResultMap: value) }
                  }
                  set {
                    resultMap.updateValue(newValue.map { (value: TextAction) -> ResultMap in value.resultMap }, forKey: "textActions")
                  }
                }

                public struct Link: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkLink"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("name", type: .nonNull(.scalar(String.self))),
                      GraphQLField("label", type: .nonNull(.scalar(String.self))),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(name: String, label: String) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkLink", "name": name, "label": label])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var name: String {
                    get {
                      return resultMap["name"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "name")
                    }
                  }

                  public var label: String {
                    get {
                      return resultMap["label"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "label")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var embarkLinkFragment: EmbarkLinkFragment {
                      get {
                        return EmbarkLinkFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }
                }

                public struct Api: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkApiPersonalInformation", "EmbarkApiHouseInformation", "EmbarkApiCreateQuote", "EmbarkApiGraphQLQuery", "EmbarkApiGraphQLMutation"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLTypeCase(
                        variants: ["EmbarkApiGraphQLQuery": AsEmbarkApiGraphQlQuery.selections, "EmbarkApiGraphQLMutation": AsEmbarkApiGraphQlMutation.selections],
                        default: [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        ]
                      )
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public static func makeEmbarkApiPersonalInformation() -> Api {
                    return Api(unsafeResultMap: ["__typename": "EmbarkApiPersonalInformation"])
                  }

                  public static func makeEmbarkApiHouseInformation() -> Api {
                    return Api(unsafeResultMap: ["__typename": "EmbarkApiHouseInformation"])
                  }

                  public static func makeEmbarkApiCreateQuote() -> Api {
                    return Api(unsafeResultMap: ["__typename": "EmbarkApiCreateQuote"])
                  }

                  public static func makeEmbarkApiGraphQLQuery(data: AsEmbarkApiGraphQlQuery.Datum) -> Api {
                    return Api(unsafeResultMap: ["__typename": "EmbarkApiGraphQLQuery", "data": data.resultMap])
                  }

                  public static func makeEmbarkApiGraphQLMutation(data: AsEmbarkApiGraphQlMutation.Datum) -> Api {
                    return Api(unsafeResultMap: ["__typename": "EmbarkApiGraphQLMutation", "data": data.resultMap])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var apiFragment: ApiFragment {
                      get {
                        return ApiFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }

                  public var asEmbarkApiGraphQlQuery: AsEmbarkApiGraphQlQuery? {
                    get {
                      if !AsEmbarkApiGraphQlQuery.possibleTypes.contains(__typename) { return nil }
                      return AsEmbarkApiGraphQlQuery(unsafeResultMap: resultMap)
                    }
                    set {
                      guard let newValue = newValue else { return }
                      resultMap = newValue.resultMap
                    }
                  }

                  public struct AsEmbarkApiGraphQlQuery: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkApiGraphQLQuery"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("data", type: .nonNull(.object(Datum.selections))),
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public init(data: Datum) {
                      self.init(unsafeResultMap: ["__typename": "EmbarkApiGraphQLQuery", "data": data.resultMap])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var data: Datum {
                      get {
                        return Datum(unsafeResultMap: resultMap["data"]! as! ResultMap)
                      }
                      set {
                        resultMap.updateValue(newValue.resultMap, forKey: "data")
                      }
                    }

                    public var fragments: Fragments {
                      get {
                        return Fragments(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public struct Fragments {
                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public var apiFragment: ApiFragment {
                        get {
                          return ApiFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }
                    }

                    public struct Datum: GraphQLSelectionSet {
                      public static let possibleTypes: [String] = ["EmbarkApiGraphQLQueryData"]

                      public static var selections: [GraphQLSelection] {
                        return [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("next", type: .object(Next.selections)),
                          GraphQLField("query", type: .nonNull(.scalar(String.self))),
                          GraphQLField("variables", type: .nonNull(.list(.nonNull(.object(Variable.selections))))),
                          GraphQLField("results", alias: "queryResults", type: .nonNull(.list(.nonNull(.object(QueryResult.selections))))),
                          GraphQLField("errors", alias: "queryErrors", type: .nonNull(.list(.nonNull(.object(QueryError.selections))))),
                        ]
                      }

                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public init(next: Next? = nil, query: String, variables: [Variable], queryResults: [QueryResult], queryErrors: [QueryError]) {
                        self.init(unsafeResultMap: ["__typename": "EmbarkApiGraphQLQueryData", "next": next.flatMap { (value: Next) -> ResultMap in value.resultMap }, "query": query, "variables": variables.map { (value: Variable) -> ResultMap in value.resultMap }, "queryResults": queryResults.map { (value: QueryResult) -> ResultMap in value.resultMap }, "queryErrors": queryErrors.map { (value: QueryError) -> ResultMap in value.resultMap }])
                      }

                      public var __typename: String {
                        get {
                          return resultMap["__typename"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "__typename")
                        }
                      }

                      public var next: Next? {
                        get {
                          return (resultMap["next"] as? ResultMap).flatMap { Next(unsafeResultMap: $0) }
                        }
                        set {
                          resultMap.updateValue(newValue?.resultMap, forKey: "next")
                        }
                      }

                      public var query: String {
                        get {
                          return resultMap["query"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "query")
                        }
                      }

                      public var variables: [Variable] {
                        get {
                          return (resultMap["variables"] as! [ResultMap]).map { (value: ResultMap) -> Variable in Variable(unsafeResultMap: value) }
                        }
                        set {
                          resultMap.updateValue(newValue.map { (value: Variable) -> ResultMap in value.resultMap }, forKey: "variables")
                        }
                      }

                      public var queryResults: [QueryResult] {
                        get {
                          return (resultMap["queryResults"] as! [ResultMap]).map { (value: ResultMap) -> QueryResult in QueryResult(unsafeResultMap: value) }
                        }
                        set {
                          resultMap.updateValue(newValue.map { (value: QueryResult) -> ResultMap in value.resultMap }, forKey: "queryResults")
                        }
                      }

                      public var queryErrors: [QueryError] {
                        get {
                          return (resultMap["queryErrors"] as! [ResultMap]).map { (value: ResultMap) -> QueryError in QueryError(unsafeResultMap: value) }
                        }
                        set {
                          resultMap.updateValue(newValue.map { (value: QueryError) -> ResultMap in value.resultMap }, forKey: "queryErrors")
                        }
                      }

                      public struct Next: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkLink"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("name", type: .nonNull(.scalar(String.self))),
                            GraphQLField("label", type: .nonNull(.scalar(String.self))),
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public init(name: String, label: String) {
                          self.init(unsafeResultMap: ["__typename": "EmbarkLink", "name": name, "label": label])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var name: String {
                          get {
                            return resultMap["name"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "name")
                          }
                        }

                        public var label: String {
                          get {
                            return resultMap["label"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "label")
                          }
                        }

                        public var fragments: Fragments {
                          get {
                            return Fragments(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }

                        public struct Fragments {
                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public var embarkLinkFragment: EmbarkLinkFragment {
                            get {
                              return EmbarkLinkFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }
                        }
                      }

                      public struct Variable: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable", "EmbarkAPIGraphQLGeneratedVariable", "EmbarkAPIGraphQLMultiActionVariable", "EmbarkAPIGraphQLConstantVariable"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLTypeCase(
                              variants: ["EmbarkAPIGraphQLSingleVariable": AsEmbarkApiGraphQlSingleVariable.selections, "EmbarkAPIGraphQLGeneratedVariable": AsEmbarkApiGraphQlGeneratedVariable.selections, "EmbarkAPIGraphQLMultiActionVariable": AsEmbarkApiGraphQlMultiActionVariable.selections],
                              default: [
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              ]
                            )
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public static func makeEmbarkAPIGraphQLConstantVariable() -> Variable {
                          return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLConstantVariable"])
                        }

                        public static func makeEmbarkAPIGraphQLSingleVariable(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) -> Variable {
                          return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                        }

                        public static func makeEmbarkAPIGraphQLGeneratedVariable(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) -> Variable {
                          return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                        }

                        public static func makeEmbarkAPIGraphQLMultiActionVariable(key: String, variables: [AsEmbarkApiGraphQlMultiActionVariable.Variable]) -> Variable {
                          return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: AsEmbarkApiGraphQlMultiActionVariable.Variable) -> ResultMap in value.resultMap }])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var fragments: Fragments {
                          get {
                            return Fragments(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }

                        public struct Fragments {
                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public var apiVariablesFragment: ApiVariablesFragment {
                            get {
                              return ApiVariablesFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                            get {
                              if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                              return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              guard let newValue = newValue else { return }
                              resultMap += newValue.resultMap
                            }
                          }

                          public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                            get {
                              if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                              return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              guard let newValue = newValue else { return }
                              resultMap += newValue.resultMap
                            }
                          }

                          public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment? {
                            get {
                              if !ApiMultiActionVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                              return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              guard let newValue = newValue else { return }
                              resultMap += newValue.resultMap
                            }
                          }
                        }

                        public var asEmbarkApiGraphQlSingleVariable: AsEmbarkApiGraphQlSingleVariable? {
                          get {
                            if !AsEmbarkApiGraphQlSingleVariable.possibleTypes.contains(__typename) { return nil }
                            return AsEmbarkApiGraphQlSingleVariable(unsafeResultMap: resultMap)
                          }
                          set {
                            guard let newValue = newValue else { return }
                            resultMap = newValue.resultMap
                          }
                        }

                        public struct AsEmbarkApiGraphQlSingleVariable: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("key", type: .nonNull(.scalar(String.self))),
                              GraphQLField("from", type: .nonNull(.scalar(String.self))),
                              GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var key: String {
                            get {
                              return resultMap["key"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "key")
                            }
                          }

                          public var from: String {
                            get {
                              return resultMap["from"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "from")
                            }
                          }

                          public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
                            get {
                              return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "as")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var apiVariablesFragment: ApiVariablesFragment {
                              get {
                                return ApiVariablesFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiSingleVariableFragment: ApiSingleVariableFragment {
                              get {
                                return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                              get {
                                if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment? {
                              get {
                                if !ApiMultiActionVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }
                          }
                        }

                        public var asEmbarkApiGraphQlGeneratedVariable: AsEmbarkApiGraphQlGeneratedVariable? {
                          get {
                            if !AsEmbarkApiGraphQlGeneratedVariable.possibleTypes.contains(__typename) { return nil }
                            return AsEmbarkApiGraphQlGeneratedVariable(unsafeResultMap: resultMap)
                          }
                          set {
                            guard let newValue = newValue else { return }
                            resultMap = newValue.resultMap
                          }
                        }

                        public struct AsEmbarkApiGraphQlGeneratedVariable: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("key", type: .nonNull(.scalar(String.self))),
                              GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
                              GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var key: String {
                            get {
                              return resultMap["key"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "key")
                            }
                          }

                          public var storeAs: String {
                            get {
                              return resultMap["storeAs"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "storeAs")
                            }
                          }

                          public var type: EmbarkAPIGraphQLVariableGeneratedType {
                            get {
                              return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "type")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var apiVariablesFragment: ApiVariablesFragment {
                              get {
                                return ApiVariablesFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                              get {
                                if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment {
                              get {
                                return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment? {
                              get {
                                if !ApiMultiActionVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }
                          }
                        }

                        public var asEmbarkApiGraphQlMultiActionVariable: AsEmbarkApiGraphQlMultiActionVariable? {
                          get {
                            if !AsEmbarkApiGraphQlMultiActionVariable.possibleTypes.contains(__typename) { return nil }
                            return AsEmbarkApiGraphQlMultiActionVariable(unsafeResultMap: resultMap)
                          }
                          set {
                            guard let newValue = newValue else { return }
                            resultMap = newValue.resultMap
                          }
                        }

                        public struct AsEmbarkApiGraphQlMultiActionVariable: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkAPIGraphQLMultiActionVariable"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("key", type: .nonNull(.scalar(String.self))),
                              GraphQLField("variables", type: .nonNull(.list(.nonNull(.object(Variable.selections))))),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(key: String, variables: [Variable]) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: Variable) -> ResultMap in value.resultMap }])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var key: String {
                            get {
                              return resultMap["key"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "key")
                            }
                          }

                          public var variables: [Variable] {
                            get {
                              return (resultMap["variables"] as! [ResultMap]).map { (value: ResultMap) -> Variable in Variable(unsafeResultMap: value) }
                            }
                            set {
                              resultMap.updateValue(newValue.map { (value: Variable) -> ResultMap in value.resultMap }, forKey: "variables")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var apiVariablesFragment: ApiVariablesFragment {
                              get {
                                return ApiVariablesFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                              get {
                                if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                              get {
                                if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment {
                              get {
                                return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }
                          }

                          public struct Variable: GraphQLSelectionSet {
                            public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable", "EmbarkAPIGraphQLGeneratedVariable", "EmbarkAPIGraphQLMultiActionVariable", "EmbarkAPIGraphQLConstantVariable"]

                            public static var selections: [GraphQLSelection] {
                              return [
                                GraphQLTypeCase(
                                  variants: ["EmbarkAPIGraphQLSingleVariable": AsEmbarkApiGraphQlSingleVariable.selections, "EmbarkAPIGraphQLGeneratedVariable": AsEmbarkApiGraphQlGeneratedVariable.selections, "EmbarkAPIGraphQLMultiActionVariable": AsEmbarkApiGraphQlMultiActionVariable.selections],
                                  default: [
                                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  ]
                                )
                              ]
                            }

                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public static func makeEmbarkAPIGraphQLConstantVariable() -> Variable {
                              return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLConstantVariable"])
                            }

                            public static func makeEmbarkAPIGraphQLSingleVariable(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) -> Variable {
                              return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                            }

                            public static func makeEmbarkAPIGraphQLGeneratedVariable(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) -> Variable {
                              return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                            }

                            public static func makeEmbarkAPIGraphQLMultiActionVariable(key: String, variables: [AsEmbarkApiGraphQlMultiActionVariable.Variable]) -> Variable {
                              return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: AsEmbarkApiGraphQlMultiActionVariable.Variable) -> ResultMap in value.resultMap }])
                            }

                            public var __typename: String {
                              get {
                                return resultMap["__typename"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "__typename")
                              }
                            }

                            public var fragments: Fragments {
                              get {
                                return Fragments(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public struct Fragments {
                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                get {
                                  if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                  return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  guard let newValue = newValue else { return }
                                  resultMap += newValue.resultMap
                                }
                              }

                              public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                get {
                                  if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                  return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  guard let newValue = newValue else { return }
                                  resultMap += newValue.resultMap
                                }
                              }
                            }

                            public var asEmbarkApiGraphQlSingleVariable: AsEmbarkApiGraphQlSingleVariable? {
                              get {
                                if !AsEmbarkApiGraphQlSingleVariable.possibleTypes.contains(__typename) { return nil }
                                return AsEmbarkApiGraphQlSingleVariable(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap = newValue.resultMap
                              }
                            }

                            public struct AsEmbarkApiGraphQlSingleVariable: GraphQLSelectionSet {
                              public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

                              public static var selections: [GraphQLSelection] {
                                return [
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("from", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
                                ]
                              }

                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
                                self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                              }

                              public var __typename: String {
                                get {
                                  return resultMap["__typename"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "__typename")
                                }
                              }

                              public var key: String {
                                get {
                                  return resultMap["key"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "key")
                                }
                              }

                              public var from: String {
                                get {
                                  return resultMap["from"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "from")
                                }
                              }

                              public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
                                get {
                                  return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "as")
                                }
                              }

                              public var fragments: Fragments {
                                get {
                                  return Fragments(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public struct Fragments {
                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public var apiSingleVariableFragment: ApiSingleVariableFragment {
                                  get {
                                    return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    resultMap += newValue.resultMap
                                  }
                                }

                                public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                  get {
                                    if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                    return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap += newValue.resultMap
                                  }
                                }
                              }
                            }

                            public var asEmbarkApiGraphQlGeneratedVariable: AsEmbarkApiGraphQlGeneratedVariable? {
                              get {
                                if !AsEmbarkApiGraphQlGeneratedVariable.possibleTypes.contains(__typename) { return nil }
                                return AsEmbarkApiGraphQlGeneratedVariable(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap = newValue.resultMap
                              }
                            }

                            public struct AsEmbarkApiGraphQlGeneratedVariable: GraphQLSelectionSet {
                              public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

                              public static var selections: [GraphQLSelection] {
                                return [
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
                                ]
                              }

                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
                                self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                              }

                              public var __typename: String {
                                get {
                                  return resultMap["__typename"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "__typename")
                                }
                              }

                              public var key: String {
                                get {
                                  return resultMap["key"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "key")
                                }
                              }

                              public var storeAs: String {
                                get {
                                  return resultMap["storeAs"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "storeAs")
                                }
                              }

                              public var type: EmbarkAPIGraphQLVariableGeneratedType {
                                get {
                                  return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "type")
                                }
                              }

                              public var fragments: Fragments {
                                get {
                                  return Fragments(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public struct Fragments {
                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                  get {
                                    if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                    return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap += newValue.resultMap
                                  }
                                }

                                public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment {
                                  get {
                                    return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    resultMap += newValue.resultMap
                                  }
                                }
                              }
                            }

                            public var asEmbarkApiGraphQlMultiActionVariable: AsEmbarkApiGraphQlMultiActionVariable? {
                              get {
                                if !AsEmbarkApiGraphQlMultiActionVariable.possibleTypes.contains(__typename) { return nil }
                                return AsEmbarkApiGraphQlMultiActionVariable(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap = newValue.resultMap
                              }
                            }

                            public struct AsEmbarkApiGraphQlMultiActionVariable: GraphQLSelectionSet {
                              public static let possibleTypes: [String] = ["EmbarkAPIGraphQLMultiActionVariable"]

                              public static var selections: [GraphQLSelection] {
                                return [
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("variables", type: .nonNull(.list(.nonNull(.object(Variable.selections))))),
                                ]
                              }

                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public init(key: String, variables: [Variable]) {
                                self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: Variable) -> ResultMap in value.resultMap }])
                              }

                              public var __typename: String {
                                get {
                                  return resultMap["__typename"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "__typename")
                                }
                              }

                              public var key: String {
                                get {
                                  return resultMap["key"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "key")
                                }
                              }

                              public var variables: [Variable] {
                                get {
                                  return (resultMap["variables"] as! [ResultMap]).map { (value: ResultMap) -> Variable in Variable(unsafeResultMap: value) }
                                }
                                set {
                                  resultMap.updateValue(newValue.map { (value: Variable) -> ResultMap in value.resultMap }, forKey: "variables")
                                }
                              }

                              public var fragments: Fragments {
                                get {
                                  return Fragments(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public struct Fragments {
                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                  get {
                                    if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                    return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap += newValue.resultMap
                                  }
                                }

                                public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                  get {
                                    if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                    return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap += newValue.resultMap
                                  }
                                }
                              }

                              public struct Variable: GraphQLSelectionSet {
                                public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable", "EmbarkAPIGraphQLGeneratedVariable", "EmbarkAPIGraphQLMultiActionVariable", "EmbarkAPIGraphQLConstantVariable"]

                                public static var selections: [GraphQLSelection] {
                                  return [
                                    GraphQLTypeCase(
                                      variants: ["EmbarkAPIGraphQLSingleVariable": AsEmbarkApiGraphQlSingleVariable.selections, "EmbarkAPIGraphQLGeneratedVariable": AsEmbarkApiGraphQlGeneratedVariable.selections],
                                      default: [
                                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                      ]
                                    )
                                  ]
                                }

                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public static func makeEmbarkAPIGraphQLMultiActionVariable() -> Variable {
                                  return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable"])
                                }

                                public static func makeEmbarkAPIGraphQLConstantVariable() -> Variable {
                                  return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLConstantVariable"])
                                }

                                public static func makeEmbarkAPIGraphQLSingleVariable(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) -> Variable {
                                  return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                                }

                                public static func makeEmbarkAPIGraphQLGeneratedVariable(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) -> Variable {
                                  return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                                }

                                public var __typename: String {
                                  get {
                                    return resultMap["__typename"]! as! String
                                  }
                                  set {
                                    resultMap.updateValue(newValue, forKey: "__typename")
                                  }
                                }

                                public var fragments: Fragments {
                                  get {
                                    return Fragments(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    resultMap += newValue.resultMap
                                  }
                                }

                                public struct Fragments {
                                  public private(set) var resultMap: ResultMap

                                  public init(unsafeResultMap: ResultMap) {
                                    self.resultMap = unsafeResultMap
                                  }

                                  public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                    get {
                                      if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                      return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      guard let newValue = newValue else { return }
                                      resultMap += newValue.resultMap
                                    }
                                  }

                                  public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                    get {
                                      if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                      return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      guard let newValue = newValue else { return }
                                      resultMap += newValue.resultMap
                                    }
                                  }
                                }

                                public var asEmbarkApiGraphQlSingleVariable: AsEmbarkApiGraphQlSingleVariable? {
                                  get {
                                    if !AsEmbarkApiGraphQlSingleVariable.possibleTypes.contains(__typename) { return nil }
                                    return AsEmbarkApiGraphQlSingleVariable(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap = newValue.resultMap
                                  }
                                }

                                public struct AsEmbarkApiGraphQlSingleVariable: GraphQLSelectionSet {
                                  public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

                                  public static var selections: [GraphQLSelection] {
                                    return [
                                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("from", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
                                    ]
                                  }

                                  public private(set) var resultMap: ResultMap

                                  public init(unsafeResultMap: ResultMap) {
                                    self.resultMap = unsafeResultMap
                                  }

                                  public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
                                    self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                                  }

                                  public var __typename: String {
                                    get {
                                      return resultMap["__typename"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "__typename")
                                    }
                                  }

                                  public var key: String {
                                    get {
                                      return resultMap["key"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "key")
                                    }
                                  }

                                  public var from: String {
                                    get {
                                      return resultMap["from"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "from")
                                    }
                                  }

                                  public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
                                    get {
                                      return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "as")
                                    }
                                  }

                                  public var fragments: Fragments {
                                    get {
                                      return Fragments(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      resultMap += newValue.resultMap
                                    }
                                  }

                                  public struct Fragments {
                                    public private(set) var resultMap: ResultMap

                                    public init(unsafeResultMap: ResultMap) {
                                      self.resultMap = unsafeResultMap
                                    }

                                    public var apiSingleVariableFragment: ApiSingleVariableFragment {
                                      get {
                                        return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                      }
                                      set {
                                        resultMap += newValue.resultMap
                                      }
                                    }

                                    public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                      get {
                                        if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                        return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                      }
                                      set {
                                        guard let newValue = newValue else { return }
                                        resultMap += newValue.resultMap
                                      }
                                    }
                                  }
                                }

                                public var asEmbarkApiGraphQlGeneratedVariable: AsEmbarkApiGraphQlGeneratedVariable? {
                                  get {
                                    if !AsEmbarkApiGraphQlGeneratedVariable.possibleTypes.contains(__typename) { return nil }
                                    return AsEmbarkApiGraphQlGeneratedVariable(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap = newValue.resultMap
                                  }
                                }

                                public struct AsEmbarkApiGraphQlGeneratedVariable: GraphQLSelectionSet {
                                  public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

                                  public static var selections: [GraphQLSelection] {
                                    return [
                                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
                                    ]
                                  }

                                  public private(set) var resultMap: ResultMap

                                  public init(unsafeResultMap: ResultMap) {
                                    self.resultMap = unsafeResultMap
                                  }

                                  public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
                                    self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                                  }

                                  public var __typename: String {
                                    get {
                                      return resultMap["__typename"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "__typename")
                                    }
                                  }

                                  public var key: String {
                                    get {
                                      return resultMap["key"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "key")
                                    }
                                  }

                                  public var storeAs: String {
                                    get {
                                      return resultMap["storeAs"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "storeAs")
                                    }
                                  }

                                  public var type: EmbarkAPIGraphQLVariableGeneratedType {
                                    get {
                                      return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "type")
                                    }
                                  }

                                  public var fragments: Fragments {
                                    get {
                                      return Fragments(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      resultMap += newValue.resultMap
                                    }
                                  }

                                  public struct Fragments {
                                    public private(set) var resultMap: ResultMap

                                    public init(unsafeResultMap: ResultMap) {
                                      self.resultMap = unsafeResultMap
                                    }

                                    public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                      get {
                                        if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                        return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                      }
                                      set {
                                        guard let newValue = newValue else { return }
                                        resultMap += newValue.resultMap
                                      }
                                    }

                                    public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment {
                                      get {
                                        return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                      }
                                      set {
                                        resultMap += newValue.resultMap
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }

                      public struct QueryResult: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkAPIGraphQLResult"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("key", type: .nonNull(.scalar(String.self))),
                            GraphQLField("as", type: .nonNull(.scalar(String.self))),
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public init(key: String, `as`: String) {
                          self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLResult", "key": key, "as": `as`])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var key: String {
                          get {
                            return resultMap["key"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "key")
                          }
                        }

                        public var `as`: String {
                          get {
                            return resultMap["as"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "as")
                          }
                        }
                      }

                      public struct QueryError: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkAPIGraphQLError"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("contains", type: .scalar(String.self)),
                            GraphQLField("next", type: .nonNull(.object(Next.selections))),
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public init(contains: String? = nil, next: Next) {
                          self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLError", "contains": contains, "next": next.resultMap])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var contains: String? {
                          get {
                            return resultMap["contains"] as? String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "contains")
                          }
                        }

                        public var next: Next {
                          get {
                            return Next(unsafeResultMap: resultMap["next"]! as! ResultMap)
                          }
                          set {
                            resultMap.updateValue(newValue.resultMap, forKey: "next")
                          }
                        }

                        public struct Next: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkLink"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("name", type: .nonNull(.scalar(String.self))),
                              GraphQLField("label", type: .nonNull(.scalar(String.self))),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(name: String, label: String) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkLink", "name": name, "label": label])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var name: String {
                            get {
                              return resultMap["name"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "name")
                            }
                          }

                          public var label: String {
                            get {
                              return resultMap["label"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "label")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var embarkLinkFragment: EmbarkLinkFragment {
                              get {
                                return EmbarkLinkFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }
                          }
                        }
                      }
                    }
                  }

                  public var asEmbarkApiGraphQlMutation: AsEmbarkApiGraphQlMutation? {
                    get {
                      if !AsEmbarkApiGraphQlMutation.possibleTypes.contains(__typename) { return nil }
                      return AsEmbarkApiGraphQlMutation(unsafeResultMap: resultMap)
                    }
                    set {
                      guard let newValue = newValue else { return }
                      resultMap = newValue.resultMap
                    }
                  }

                  public struct AsEmbarkApiGraphQlMutation: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkApiGraphQLMutation"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("data", type: .nonNull(.object(Datum.selections))),
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public init(data: Datum) {
                      self.init(unsafeResultMap: ["__typename": "EmbarkApiGraphQLMutation", "data": data.resultMap])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var data: Datum {
                      get {
                        return Datum(unsafeResultMap: resultMap["data"]! as! ResultMap)
                      }
                      set {
                        resultMap.updateValue(newValue.resultMap, forKey: "data")
                      }
                    }

                    public var fragments: Fragments {
                      get {
                        return Fragments(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public struct Fragments {
                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public var apiFragment: ApiFragment {
                        get {
                          return ApiFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }
                    }

                    public struct Datum: GraphQLSelectionSet {
                      public static let possibleTypes: [String] = ["EmbarkApiGraphQLMutationData"]

                      public static var selections: [GraphQLSelection] {
                        return [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("next", type: .object(Next.selections)),
                          GraphQLField("mutation", type: .nonNull(.scalar(String.self))),
                          GraphQLField("variables", type: .nonNull(.list(.nonNull(.object(Variable.selections))))),
                          GraphQLField("results", alias: "mutationResults", type: .nonNull(.list(.object(MutationResult.selections)))),
                          GraphQLField("errors", alias: "mutationErrors", type: .nonNull(.list(.nonNull(.object(MutationError.selections))))),
                        ]
                      }

                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public init(next: Next? = nil, mutation: String, variables: [Variable], mutationResults: [MutationResult?], mutationErrors: [MutationError]) {
                        self.init(unsafeResultMap: ["__typename": "EmbarkApiGraphQLMutationData", "next": next.flatMap { (value: Next) -> ResultMap in value.resultMap }, "mutation": mutation, "variables": variables.map { (value: Variable) -> ResultMap in value.resultMap }, "mutationResults": mutationResults.map { (value: MutationResult?) -> ResultMap? in value.flatMap { (value: MutationResult) -> ResultMap in value.resultMap } }, "mutationErrors": mutationErrors.map { (value: MutationError) -> ResultMap in value.resultMap }])
                      }

                      public var __typename: String {
                        get {
                          return resultMap["__typename"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "__typename")
                        }
                      }

                      public var next: Next? {
                        get {
                          return (resultMap["next"] as? ResultMap).flatMap { Next(unsafeResultMap: $0) }
                        }
                        set {
                          resultMap.updateValue(newValue?.resultMap, forKey: "next")
                        }
                      }

                      public var mutation: String {
                        get {
                          return resultMap["mutation"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "mutation")
                        }
                      }

                      public var variables: [Variable] {
                        get {
                          return (resultMap["variables"] as! [ResultMap]).map { (value: ResultMap) -> Variable in Variable(unsafeResultMap: value) }
                        }
                        set {
                          resultMap.updateValue(newValue.map { (value: Variable) -> ResultMap in value.resultMap }, forKey: "variables")
                        }
                      }

                      public var mutationResults: [MutationResult?] {
                        get {
                          return (resultMap["mutationResults"] as! [ResultMap?]).map { (value: ResultMap?) -> MutationResult? in value.flatMap { (value: ResultMap) -> MutationResult in MutationResult(unsafeResultMap: value) } }
                        }
                        set {
                          resultMap.updateValue(newValue.map { (value: MutationResult?) -> ResultMap? in value.flatMap { (value: MutationResult) -> ResultMap in value.resultMap } }, forKey: "mutationResults")
                        }
                      }

                      public var mutationErrors: [MutationError] {
                        get {
                          return (resultMap["mutationErrors"] as! [ResultMap]).map { (value: ResultMap) -> MutationError in MutationError(unsafeResultMap: value) }
                        }
                        set {
                          resultMap.updateValue(newValue.map { (value: MutationError) -> ResultMap in value.resultMap }, forKey: "mutationErrors")
                        }
                      }

                      public struct Next: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkLink"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("name", type: .nonNull(.scalar(String.self))),
                            GraphQLField("label", type: .nonNull(.scalar(String.self))),
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public init(name: String, label: String) {
                          self.init(unsafeResultMap: ["__typename": "EmbarkLink", "name": name, "label": label])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var name: String {
                          get {
                            return resultMap["name"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "name")
                          }
                        }

                        public var label: String {
                          get {
                            return resultMap["label"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "label")
                          }
                        }

                        public var fragments: Fragments {
                          get {
                            return Fragments(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }

                        public struct Fragments {
                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public var embarkLinkFragment: EmbarkLinkFragment {
                            get {
                              return EmbarkLinkFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }
                        }
                      }

                      public struct Variable: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable", "EmbarkAPIGraphQLGeneratedVariable", "EmbarkAPIGraphQLMultiActionVariable", "EmbarkAPIGraphQLConstantVariable"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLTypeCase(
                              variants: ["EmbarkAPIGraphQLSingleVariable": AsEmbarkApiGraphQlSingleVariable.selections, "EmbarkAPIGraphQLGeneratedVariable": AsEmbarkApiGraphQlGeneratedVariable.selections, "EmbarkAPIGraphQLMultiActionVariable": AsEmbarkApiGraphQlMultiActionVariable.selections],
                              default: [
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              ]
                            )
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public static func makeEmbarkAPIGraphQLConstantVariable() -> Variable {
                          return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLConstantVariable"])
                        }

                        public static func makeEmbarkAPIGraphQLSingleVariable(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) -> Variable {
                          return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                        }

                        public static func makeEmbarkAPIGraphQLGeneratedVariable(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) -> Variable {
                          return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                        }

                        public static func makeEmbarkAPIGraphQLMultiActionVariable(key: String, variables: [AsEmbarkApiGraphQlMultiActionVariable.Variable]) -> Variable {
                          return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: AsEmbarkApiGraphQlMultiActionVariable.Variable) -> ResultMap in value.resultMap }])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var fragments: Fragments {
                          get {
                            return Fragments(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }

                        public struct Fragments {
                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public var apiVariablesFragment: ApiVariablesFragment {
                            get {
                              return ApiVariablesFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                            get {
                              if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                              return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              guard let newValue = newValue else { return }
                              resultMap += newValue.resultMap
                            }
                          }

                          public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                            get {
                              if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                              return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              guard let newValue = newValue else { return }
                              resultMap += newValue.resultMap
                            }
                          }

                          public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment? {
                            get {
                              if !ApiMultiActionVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                              return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              guard let newValue = newValue else { return }
                              resultMap += newValue.resultMap
                            }
                          }
                        }

                        public var asEmbarkApiGraphQlSingleVariable: AsEmbarkApiGraphQlSingleVariable? {
                          get {
                            if !AsEmbarkApiGraphQlSingleVariable.possibleTypes.contains(__typename) { return nil }
                            return AsEmbarkApiGraphQlSingleVariable(unsafeResultMap: resultMap)
                          }
                          set {
                            guard let newValue = newValue else { return }
                            resultMap = newValue.resultMap
                          }
                        }

                        public struct AsEmbarkApiGraphQlSingleVariable: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("key", type: .nonNull(.scalar(String.self))),
                              GraphQLField("from", type: .nonNull(.scalar(String.self))),
                              GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var key: String {
                            get {
                              return resultMap["key"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "key")
                            }
                          }

                          public var from: String {
                            get {
                              return resultMap["from"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "from")
                            }
                          }

                          public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
                            get {
                              return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "as")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var apiVariablesFragment: ApiVariablesFragment {
                              get {
                                return ApiVariablesFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiSingleVariableFragment: ApiSingleVariableFragment {
                              get {
                                return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                              get {
                                if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment? {
                              get {
                                if !ApiMultiActionVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }
                          }
                        }

                        public var asEmbarkApiGraphQlGeneratedVariable: AsEmbarkApiGraphQlGeneratedVariable? {
                          get {
                            if !AsEmbarkApiGraphQlGeneratedVariable.possibleTypes.contains(__typename) { return nil }
                            return AsEmbarkApiGraphQlGeneratedVariable(unsafeResultMap: resultMap)
                          }
                          set {
                            guard let newValue = newValue else { return }
                            resultMap = newValue.resultMap
                          }
                        }

                        public struct AsEmbarkApiGraphQlGeneratedVariable: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("key", type: .nonNull(.scalar(String.self))),
                              GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
                              GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var key: String {
                            get {
                              return resultMap["key"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "key")
                            }
                          }

                          public var storeAs: String {
                            get {
                              return resultMap["storeAs"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "storeAs")
                            }
                          }

                          public var type: EmbarkAPIGraphQLVariableGeneratedType {
                            get {
                              return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "type")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var apiVariablesFragment: ApiVariablesFragment {
                              get {
                                return ApiVariablesFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                              get {
                                if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment {
                              get {
                                return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment? {
                              get {
                                if !ApiMultiActionVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }
                          }
                        }

                        public var asEmbarkApiGraphQlMultiActionVariable: AsEmbarkApiGraphQlMultiActionVariable? {
                          get {
                            if !AsEmbarkApiGraphQlMultiActionVariable.possibleTypes.contains(__typename) { return nil }
                            return AsEmbarkApiGraphQlMultiActionVariable(unsafeResultMap: resultMap)
                          }
                          set {
                            guard let newValue = newValue else { return }
                            resultMap = newValue.resultMap
                          }
                        }

                        public struct AsEmbarkApiGraphQlMultiActionVariable: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkAPIGraphQLMultiActionVariable"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("key", type: .nonNull(.scalar(String.self))),
                              GraphQLField("variables", type: .nonNull(.list(.nonNull(.object(Variable.selections))))),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(key: String, variables: [Variable]) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: Variable) -> ResultMap in value.resultMap }])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var key: String {
                            get {
                              return resultMap["key"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "key")
                            }
                          }

                          public var variables: [Variable] {
                            get {
                              return (resultMap["variables"] as! [ResultMap]).map { (value: ResultMap) -> Variable in Variable(unsafeResultMap: value) }
                            }
                            set {
                              resultMap.updateValue(newValue.map { (value: Variable) -> ResultMap in value.resultMap }, forKey: "variables")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var apiVariablesFragment: ApiVariablesFragment {
                              get {
                                return ApiVariablesFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                              get {
                                if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                              get {
                                if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment {
                              get {
                                return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }
                          }

                          public struct Variable: GraphQLSelectionSet {
                            public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable", "EmbarkAPIGraphQLGeneratedVariable", "EmbarkAPIGraphQLMultiActionVariable", "EmbarkAPIGraphQLConstantVariable"]

                            public static var selections: [GraphQLSelection] {
                              return [
                                GraphQLTypeCase(
                                  variants: ["EmbarkAPIGraphQLSingleVariable": AsEmbarkApiGraphQlSingleVariable.selections, "EmbarkAPIGraphQLGeneratedVariable": AsEmbarkApiGraphQlGeneratedVariable.selections, "EmbarkAPIGraphQLMultiActionVariable": AsEmbarkApiGraphQlMultiActionVariable.selections],
                                  default: [
                                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  ]
                                )
                              ]
                            }

                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public static func makeEmbarkAPIGraphQLConstantVariable() -> Variable {
                              return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLConstantVariable"])
                            }

                            public static func makeEmbarkAPIGraphQLSingleVariable(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) -> Variable {
                              return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                            }

                            public static func makeEmbarkAPIGraphQLGeneratedVariable(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) -> Variable {
                              return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                            }

                            public static func makeEmbarkAPIGraphQLMultiActionVariable(key: String, variables: [AsEmbarkApiGraphQlMultiActionVariable.Variable]) -> Variable {
                              return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: AsEmbarkApiGraphQlMultiActionVariable.Variable) -> ResultMap in value.resultMap }])
                            }

                            public var __typename: String {
                              get {
                                return resultMap["__typename"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "__typename")
                              }
                            }

                            public var fragments: Fragments {
                              get {
                                return Fragments(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public struct Fragments {
                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                get {
                                  if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                  return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  guard let newValue = newValue else { return }
                                  resultMap += newValue.resultMap
                                }
                              }

                              public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                get {
                                  if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                  return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  guard let newValue = newValue else { return }
                                  resultMap += newValue.resultMap
                                }
                              }
                            }

                            public var asEmbarkApiGraphQlSingleVariable: AsEmbarkApiGraphQlSingleVariable? {
                              get {
                                if !AsEmbarkApiGraphQlSingleVariable.possibleTypes.contains(__typename) { return nil }
                                return AsEmbarkApiGraphQlSingleVariable(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap = newValue.resultMap
                              }
                            }

                            public struct AsEmbarkApiGraphQlSingleVariable: GraphQLSelectionSet {
                              public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

                              public static var selections: [GraphQLSelection] {
                                return [
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("from", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
                                ]
                              }

                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
                                self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                              }

                              public var __typename: String {
                                get {
                                  return resultMap["__typename"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "__typename")
                                }
                              }

                              public var key: String {
                                get {
                                  return resultMap["key"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "key")
                                }
                              }

                              public var from: String {
                                get {
                                  return resultMap["from"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "from")
                                }
                              }

                              public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
                                get {
                                  return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "as")
                                }
                              }

                              public var fragments: Fragments {
                                get {
                                  return Fragments(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public struct Fragments {
                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public var apiSingleVariableFragment: ApiSingleVariableFragment {
                                  get {
                                    return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    resultMap += newValue.resultMap
                                  }
                                }

                                public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                  get {
                                    if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                    return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap += newValue.resultMap
                                  }
                                }
                              }
                            }

                            public var asEmbarkApiGraphQlGeneratedVariable: AsEmbarkApiGraphQlGeneratedVariable? {
                              get {
                                if !AsEmbarkApiGraphQlGeneratedVariable.possibleTypes.contains(__typename) { return nil }
                                return AsEmbarkApiGraphQlGeneratedVariable(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap = newValue.resultMap
                              }
                            }

                            public struct AsEmbarkApiGraphQlGeneratedVariable: GraphQLSelectionSet {
                              public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

                              public static var selections: [GraphQLSelection] {
                                return [
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
                                ]
                              }

                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
                                self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                              }

                              public var __typename: String {
                                get {
                                  return resultMap["__typename"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "__typename")
                                }
                              }

                              public var key: String {
                                get {
                                  return resultMap["key"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "key")
                                }
                              }

                              public var storeAs: String {
                                get {
                                  return resultMap["storeAs"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "storeAs")
                                }
                              }

                              public var type: EmbarkAPIGraphQLVariableGeneratedType {
                                get {
                                  return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "type")
                                }
                              }

                              public var fragments: Fragments {
                                get {
                                  return Fragments(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public struct Fragments {
                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                  get {
                                    if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                    return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap += newValue.resultMap
                                  }
                                }

                                public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment {
                                  get {
                                    return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    resultMap += newValue.resultMap
                                  }
                                }
                              }
                            }

                            public var asEmbarkApiGraphQlMultiActionVariable: AsEmbarkApiGraphQlMultiActionVariable? {
                              get {
                                if !AsEmbarkApiGraphQlMultiActionVariable.possibleTypes.contains(__typename) { return nil }
                                return AsEmbarkApiGraphQlMultiActionVariable(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap = newValue.resultMap
                              }
                            }

                            public struct AsEmbarkApiGraphQlMultiActionVariable: GraphQLSelectionSet {
                              public static let possibleTypes: [String] = ["EmbarkAPIGraphQLMultiActionVariable"]

                              public static var selections: [GraphQLSelection] {
                                return [
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("variables", type: .nonNull(.list(.nonNull(.object(Variable.selections))))),
                                ]
                              }

                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public init(key: String, variables: [Variable]) {
                                self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: Variable) -> ResultMap in value.resultMap }])
                              }

                              public var __typename: String {
                                get {
                                  return resultMap["__typename"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "__typename")
                                }
                              }

                              public var key: String {
                                get {
                                  return resultMap["key"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "key")
                                }
                              }

                              public var variables: [Variable] {
                                get {
                                  return (resultMap["variables"] as! [ResultMap]).map { (value: ResultMap) -> Variable in Variable(unsafeResultMap: value) }
                                }
                                set {
                                  resultMap.updateValue(newValue.map { (value: Variable) -> ResultMap in value.resultMap }, forKey: "variables")
                                }
                              }

                              public var fragments: Fragments {
                                get {
                                  return Fragments(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public struct Fragments {
                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                  get {
                                    if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                    return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap += newValue.resultMap
                                  }
                                }

                                public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                  get {
                                    if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                    return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap += newValue.resultMap
                                  }
                                }
                              }

                              public struct Variable: GraphQLSelectionSet {
                                public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable", "EmbarkAPIGraphQLGeneratedVariable", "EmbarkAPIGraphQLMultiActionVariable", "EmbarkAPIGraphQLConstantVariable"]

                                public static var selections: [GraphQLSelection] {
                                  return [
                                    GraphQLTypeCase(
                                      variants: ["EmbarkAPIGraphQLSingleVariable": AsEmbarkApiGraphQlSingleVariable.selections, "EmbarkAPIGraphQLGeneratedVariable": AsEmbarkApiGraphQlGeneratedVariable.selections],
                                      default: [
                                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                      ]
                                    )
                                  ]
                                }

                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public static func makeEmbarkAPIGraphQLMultiActionVariable() -> Variable {
                                  return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable"])
                                }

                                public static func makeEmbarkAPIGraphQLConstantVariable() -> Variable {
                                  return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLConstantVariable"])
                                }

                                public static func makeEmbarkAPIGraphQLSingleVariable(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) -> Variable {
                                  return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                                }

                                public static func makeEmbarkAPIGraphQLGeneratedVariable(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) -> Variable {
                                  return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                                }

                                public var __typename: String {
                                  get {
                                    return resultMap["__typename"]! as! String
                                  }
                                  set {
                                    resultMap.updateValue(newValue, forKey: "__typename")
                                  }
                                }

                                public var fragments: Fragments {
                                  get {
                                    return Fragments(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    resultMap += newValue.resultMap
                                  }
                                }

                                public struct Fragments {
                                  public private(set) var resultMap: ResultMap

                                  public init(unsafeResultMap: ResultMap) {
                                    self.resultMap = unsafeResultMap
                                  }

                                  public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                    get {
                                      if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                      return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      guard let newValue = newValue else { return }
                                      resultMap += newValue.resultMap
                                    }
                                  }

                                  public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                    get {
                                      if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                      return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      guard let newValue = newValue else { return }
                                      resultMap += newValue.resultMap
                                    }
                                  }
                                }

                                public var asEmbarkApiGraphQlSingleVariable: AsEmbarkApiGraphQlSingleVariable? {
                                  get {
                                    if !AsEmbarkApiGraphQlSingleVariable.possibleTypes.contains(__typename) { return nil }
                                    return AsEmbarkApiGraphQlSingleVariable(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap = newValue.resultMap
                                  }
                                }

                                public struct AsEmbarkApiGraphQlSingleVariable: GraphQLSelectionSet {
                                  public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

                                  public static var selections: [GraphQLSelection] {
                                    return [
                                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("from", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
                                    ]
                                  }

                                  public private(set) var resultMap: ResultMap

                                  public init(unsafeResultMap: ResultMap) {
                                    self.resultMap = unsafeResultMap
                                  }

                                  public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
                                    self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                                  }

                                  public var __typename: String {
                                    get {
                                      return resultMap["__typename"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "__typename")
                                    }
                                  }

                                  public var key: String {
                                    get {
                                      return resultMap["key"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "key")
                                    }
                                  }

                                  public var from: String {
                                    get {
                                      return resultMap["from"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "from")
                                    }
                                  }

                                  public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
                                    get {
                                      return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "as")
                                    }
                                  }

                                  public var fragments: Fragments {
                                    get {
                                      return Fragments(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      resultMap += newValue.resultMap
                                    }
                                  }

                                  public struct Fragments {
                                    public private(set) var resultMap: ResultMap

                                    public init(unsafeResultMap: ResultMap) {
                                      self.resultMap = unsafeResultMap
                                    }

                                    public var apiSingleVariableFragment: ApiSingleVariableFragment {
                                      get {
                                        return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                      }
                                      set {
                                        resultMap += newValue.resultMap
                                      }
                                    }

                                    public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                      get {
                                        if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                        return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                      }
                                      set {
                                        guard let newValue = newValue else { return }
                                        resultMap += newValue.resultMap
                                      }
                                    }
                                  }
                                }

                                public var asEmbarkApiGraphQlGeneratedVariable: AsEmbarkApiGraphQlGeneratedVariable? {
                                  get {
                                    if !AsEmbarkApiGraphQlGeneratedVariable.possibleTypes.contains(__typename) { return nil }
                                    return AsEmbarkApiGraphQlGeneratedVariable(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap = newValue.resultMap
                                  }
                                }

                                public struct AsEmbarkApiGraphQlGeneratedVariable: GraphQLSelectionSet {
                                  public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

                                  public static var selections: [GraphQLSelection] {
                                    return [
                                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
                                      GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
                                    ]
                                  }

                                  public private(set) var resultMap: ResultMap

                                  public init(unsafeResultMap: ResultMap) {
                                    self.resultMap = unsafeResultMap
                                  }

                                  public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
                                    self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                                  }

                                  public var __typename: String {
                                    get {
                                      return resultMap["__typename"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "__typename")
                                    }
                                  }

                                  public var key: String {
                                    get {
                                      return resultMap["key"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "key")
                                    }
                                  }

                                  public var storeAs: String {
                                    get {
                                      return resultMap["storeAs"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "storeAs")
                                    }
                                  }

                                  public var type: EmbarkAPIGraphQLVariableGeneratedType {
                                    get {
                                      return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "type")
                                    }
                                  }

                                  public var fragments: Fragments {
                                    get {
                                      return Fragments(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      resultMap += newValue.resultMap
                                    }
                                  }

                                  public struct Fragments {
                                    public private(set) var resultMap: ResultMap

                                    public init(unsafeResultMap: ResultMap) {
                                      self.resultMap = unsafeResultMap
                                    }

                                    public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                      get {
                                        if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                        return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                      }
                                      set {
                                        guard let newValue = newValue else { return }
                                        resultMap += newValue.resultMap
                                      }
                                    }

                                    public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment {
                                      get {
                                        return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                      }
                                      set {
                                        resultMap += newValue.resultMap
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }

                      public struct MutationResult: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkAPIGraphQLResult"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("key", type: .nonNull(.scalar(String.self))),
                            GraphQLField("as", type: .nonNull(.scalar(String.self))),
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public init(key: String, `as`: String) {
                          self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLResult", "key": key, "as": `as`])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var key: String {
                          get {
                            return resultMap["key"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "key")
                          }
                        }

                        public var `as`: String {
                          get {
                            return resultMap["as"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "as")
                          }
                        }
                      }

                      public struct MutationError: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkAPIGraphQLError"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("contains", type: .scalar(String.self)),
                            GraphQLField("next", type: .nonNull(.object(Next.selections))),
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public init(contains: String? = nil, next: Next) {
                          self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLError", "contains": contains, "next": next.resultMap])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var contains: String? {
                          get {
                            return resultMap["contains"] as? String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "contains")
                          }
                        }

                        public var next: Next {
                          get {
                            return Next(unsafeResultMap: resultMap["next"]! as! ResultMap)
                          }
                          set {
                            resultMap.updateValue(newValue.resultMap, forKey: "next")
                          }
                        }

                        public struct Next: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkLink"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("name", type: .nonNull(.scalar(String.self))),
                              GraphQLField("label", type: .nonNull(.scalar(String.self))),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(name: String, label: String) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkLink", "name": name, "label": label])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var name: String {
                            get {
                              return resultMap["name"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "name")
                            }
                          }

                          public var label: String {
                            get {
                              return resultMap["label"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "label")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var embarkLinkFragment: EmbarkLinkFragment {
                              get {
                                return EmbarkLinkFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }

                public struct TextAction: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkTextActionSetTextAction"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("data", type: .object(Datum.selections)),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(data: Datum? = nil) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkTextActionSetTextAction", "data": data.flatMap { (value: Datum) -> ResultMap in value.resultMap }])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var data: Datum? {
                    get {
                      return (resultMap["data"] as? ResultMap).flatMap { Datum(unsafeResultMap: $0) }
                    }
                    set {
                      resultMap.updateValue(newValue?.resultMap, forKey: "data")
                    }
                  }

                  public struct Datum: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkTextActionSetTextActionData"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("title", type: .nonNull(.scalar(String.self))),
                        GraphQLField("key", type: .nonNull(.scalar(String.self))),
                        GraphQLField("placeholder", type: .nonNull(.scalar(String.self))),
                        GraphQLField("mask", type: .scalar(String.self)),
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public init(title: String, key: String, placeholder: String, mask: String? = nil) {
                      self.init(unsafeResultMap: ["__typename": "EmbarkTextActionSetTextActionData", "title": title, "key": key, "placeholder": placeholder, "mask": mask])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var title: String {
                      get {
                        return resultMap["title"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "title")
                      }
                    }

                    public var key: String {
                      get {
                        return resultMap["key"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "key")
                      }
                    }

                    public var placeholder: String {
                      get {
                        return resultMap["placeholder"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "placeholder")
                      }
                    }

                    public var mask: String? {
                      get {
                        return resultMap["mask"] as? String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "mask")
                      }
                    }
                  }
                }
              }
            }

            public var asEmbarkSelectAction: AsEmbarkSelectAction? {
              get {
                if !AsEmbarkSelectAction.possibleTypes.contains(__typename) { return nil }
                return AsEmbarkSelectAction(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap = newValue.resultMap
              }
            }

            public struct AsEmbarkSelectAction: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkSelectAction"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("component", type: .nonNull(.scalar(String.self))),
                  GraphQLField("component", type: .nonNull(.scalar(String.self))),
                  GraphQLField("data", alias: "selectActionData", type: .nonNull(.object(SelectActionDatum.selections))),
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public init(component: String, selectActionData: SelectActionDatum) {
                self.init(unsafeResultMap: ["__typename": "EmbarkSelectAction", "component": component, "selectActionData": selectActionData.resultMap])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var component: String {
                get {
                  return resultMap["component"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "component")
                }
              }

              public var selectActionData: SelectActionDatum {
                get {
                  return SelectActionDatum(unsafeResultMap: resultMap["selectActionData"]! as! ResultMap)
                }
                set {
                  resultMap.updateValue(newValue.resultMap, forKey: "selectActionData")
                }
              }

              public struct SelectActionDatum: GraphQLSelectionSet {
                public static let possibleTypes: [String] = ["EmbarkSelectActionData"]

                public static var selections: [GraphQLSelection] {
                  return [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("options", type: .nonNull(.list(.nonNull(.object(Option.selections))))),
                  ]
                }

                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public init(options: [Option]) {
                  self.init(unsafeResultMap: ["__typename": "EmbarkSelectActionData", "options": options.map { (value: Option) -> ResultMap in value.resultMap }])
                }

                public var __typename: String {
                  get {
                    return resultMap["__typename"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "__typename")
                  }
                }

                public var options: [Option] {
                  get {
                    return (resultMap["options"] as! [ResultMap]).map { (value: ResultMap) -> Option in Option(unsafeResultMap: value) }
                  }
                  set {
                    resultMap.updateValue(newValue.map { (value: Option) -> ResultMap in value.resultMap }, forKey: "options")
                  }
                }

                public struct Option: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkSelectActionOption"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("keys", type: .nonNull(.list(.nonNull(.scalar(String.self))))),
                      GraphQLField("values", type: .nonNull(.list(.nonNull(.scalar(String.self))))),
                      GraphQLField("link", type: .nonNull(.object(Link.selections))),
                      GraphQLField("api", type: .object(Api.selections)),
                      GraphQLField("badge", type: .scalar(String.self)),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(keys: [String], values: [String], link: Link, api: Api? = nil, badge: String? = nil) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkSelectActionOption", "keys": keys, "values": values, "link": link.resultMap, "api": api.flatMap { (value: Api) -> ResultMap in value.resultMap }, "badge": badge])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var keys: [String] {
                    get {
                      return resultMap["keys"]! as! [String]
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "keys")
                    }
                  }

                  public var values: [String] {
                    get {
                      return resultMap["values"]! as! [String]
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "values")
                    }
                  }

                  public var link: Link {
                    get {
                      return Link(unsafeResultMap: resultMap["link"]! as! ResultMap)
                    }
                    set {
                      resultMap.updateValue(newValue.resultMap, forKey: "link")
                    }
                  }

                  public var api: Api? {
                    get {
                      return (resultMap["api"] as? ResultMap).flatMap { Api(unsafeResultMap: $0) }
                    }
                    set {
                      resultMap.updateValue(newValue?.resultMap, forKey: "api")
                    }
                  }

                  public var badge: String? {
                    get {
                      return resultMap["badge"] as? String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "badge")
                    }
                  }

                  public struct Link: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkLink"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("name", type: .nonNull(.scalar(String.self))),
                        GraphQLField("label", type: .nonNull(.scalar(String.self))),
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public init(name: String, label: String) {
                      self.init(unsafeResultMap: ["__typename": "EmbarkLink", "name": name, "label": label])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var name: String {
                      get {
                        return resultMap["name"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "name")
                      }
                    }

                    public var label: String {
                      get {
                        return resultMap["label"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "label")
                      }
                    }

                    public var fragments: Fragments {
                      get {
                        return Fragments(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public struct Fragments {
                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public var embarkLinkFragment: EmbarkLinkFragment {
                        get {
                          return EmbarkLinkFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }
                    }
                  }

                  public struct Api: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkApiPersonalInformation", "EmbarkApiHouseInformation", "EmbarkApiCreateQuote", "EmbarkApiGraphQLQuery", "EmbarkApiGraphQLMutation"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLTypeCase(
                          variants: ["EmbarkApiGraphQLQuery": AsEmbarkApiGraphQlQuery.selections, "EmbarkApiGraphQLMutation": AsEmbarkApiGraphQlMutation.selections],
                          default: [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          ]
                        )
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public static func makeEmbarkApiPersonalInformation() -> Api {
                      return Api(unsafeResultMap: ["__typename": "EmbarkApiPersonalInformation"])
                    }

                    public static func makeEmbarkApiHouseInformation() -> Api {
                      return Api(unsafeResultMap: ["__typename": "EmbarkApiHouseInformation"])
                    }

                    public static func makeEmbarkApiCreateQuote() -> Api {
                      return Api(unsafeResultMap: ["__typename": "EmbarkApiCreateQuote"])
                    }

                    public static func makeEmbarkApiGraphQLQuery(data: AsEmbarkApiGraphQlQuery.Datum) -> Api {
                      return Api(unsafeResultMap: ["__typename": "EmbarkApiGraphQLQuery", "data": data.resultMap])
                    }

                    public static func makeEmbarkApiGraphQLMutation(data: AsEmbarkApiGraphQlMutation.Datum) -> Api {
                      return Api(unsafeResultMap: ["__typename": "EmbarkApiGraphQLMutation", "data": data.resultMap])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var fragments: Fragments {
                      get {
                        return Fragments(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public struct Fragments {
                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public var apiFragment: ApiFragment {
                        get {
                          return ApiFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }
                    }

                    public var asEmbarkApiGraphQlQuery: AsEmbarkApiGraphQlQuery? {
                      get {
                        if !AsEmbarkApiGraphQlQuery.possibleTypes.contains(__typename) { return nil }
                        return AsEmbarkApiGraphQlQuery(unsafeResultMap: resultMap)
                      }
                      set {
                        guard let newValue = newValue else { return }
                        resultMap = newValue.resultMap
                      }
                    }

                    public struct AsEmbarkApiGraphQlQuery: GraphQLSelectionSet {
                      public static let possibleTypes: [String] = ["EmbarkApiGraphQLQuery"]

                      public static var selections: [GraphQLSelection] {
                        return [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("data", type: .nonNull(.object(Datum.selections))),
                        ]
                      }

                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public init(data: Datum) {
                        self.init(unsafeResultMap: ["__typename": "EmbarkApiGraphQLQuery", "data": data.resultMap])
                      }

                      public var __typename: String {
                        get {
                          return resultMap["__typename"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "__typename")
                        }
                      }

                      public var data: Datum {
                        get {
                          return Datum(unsafeResultMap: resultMap["data"]! as! ResultMap)
                        }
                        set {
                          resultMap.updateValue(newValue.resultMap, forKey: "data")
                        }
                      }

                      public var fragments: Fragments {
                        get {
                          return Fragments(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public struct Fragments {
                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public var apiFragment: ApiFragment {
                          get {
                            return ApiFragment(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }
                      }

                      public struct Datum: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkApiGraphQLQueryData"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("next", type: .object(Next.selections)),
                            GraphQLField("query", type: .nonNull(.scalar(String.self))),
                            GraphQLField("variables", type: .nonNull(.list(.nonNull(.object(Variable.selections))))),
                            GraphQLField("results", alias: "queryResults", type: .nonNull(.list(.nonNull(.object(QueryResult.selections))))),
                            GraphQLField("errors", alias: "queryErrors", type: .nonNull(.list(.nonNull(.object(QueryError.selections))))),
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public init(next: Next? = nil, query: String, variables: [Variable], queryResults: [QueryResult], queryErrors: [QueryError]) {
                          self.init(unsafeResultMap: ["__typename": "EmbarkApiGraphQLQueryData", "next": next.flatMap { (value: Next) -> ResultMap in value.resultMap }, "query": query, "variables": variables.map { (value: Variable) -> ResultMap in value.resultMap }, "queryResults": queryResults.map { (value: QueryResult) -> ResultMap in value.resultMap }, "queryErrors": queryErrors.map { (value: QueryError) -> ResultMap in value.resultMap }])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var next: Next? {
                          get {
                            return (resultMap["next"] as? ResultMap).flatMap { Next(unsafeResultMap: $0) }
                          }
                          set {
                            resultMap.updateValue(newValue?.resultMap, forKey: "next")
                          }
                        }

                        public var query: String {
                          get {
                            return resultMap["query"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "query")
                          }
                        }

                        public var variables: [Variable] {
                          get {
                            return (resultMap["variables"] as! [ResultMap]).map { (value: ResultMap) -> Variable in Variable(unsafeResultMap: value) }
                          }
                          set {
                            resultMap.updateValue(newValue.map { (value: Variable) -> ResultMap in value.resultMap }, forKey: "variables")
                          }
                        }

                        public var queryResults: [QueryResult] {
                          get {
                            return (resultMap["queryResults"] as! [ResultMap]).map { (value: ResultMap) -> QueryResult in QueryResult(unsafeResultMap: value) }
                          }
                          set {
                            resultMap.updateValue(newValue.map { (value: QueryResult) -> ResultMap in value.resultMap }, forKey: "queryResults")
                          }
                        }

                        public var queryErrors: [QueryError] {
                          get {
                            return (resultMap["queryErrors"] as! [ResultMap]).map { (value: ResultMap) -> QueryError in QueryError(unsafeResultMap: value) }
                          }
                          set {
                            resultMap.updateValue(newValue.map { (value: QueryError) -> ResultMap in value.resultMap }, forKey: "queryErrors")
                          }
                        }

                        public struct Next: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkLink"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("name", type: .nonNull(.scalar(String.self))),
                              GraphQLField("label", type: .nonNull(.scalar(String.self))),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(name: String, label: String) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkLink", "name": name, "label": label])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var name: String {
                            get {
                              return resultMap["name"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "name")
                            }
                          }

                          public var label: String {
                            get {
                              return resultMap["label"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "label")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var embarkLinkFragment: EmbarkLinkFragment {
                              get {
                                return EmbarkLinkFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }
                          }
                        }

                        public struct Variable: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable", "EmbarkAPIGraphQLGeneratedVariable", "EmbarkAPIGraphQLMultiActionVariable", "EmbarkAPIGraphQLConstantVariable"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLTypeCase(
                                variants: ["EmbarkAPIGraphQLSingleVariable": AsEmbarkApiGraphQlSingleVariable.selections, "EmbarkAPIGraphQLGeneratedVariable": AsEmbarkApiGraphQlGeneratedVariable.selections, "EmbarkAPIGraphQLMultiActionVariable": AsEmbarkApiGraphQlMultiActionVariable.selections],
                                default: [
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                ]
                              )
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public static func makeEmbarkAPIGraphQLConstantVariable() -> Variable {
                            return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLConstantVariable"])
                          }

                          public static func makeEmbarkAPIGraphQLSingleVariable(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) -> Variable {
                            return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                          }

                          public static func makeEmbarkAPIGraphQLGeneratedVariable(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) -> Variable {
                            return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                          }

                          public static func makeEmbarkAPIGraphQLMultiActionVariable(key: String, variables: [AsEmbarkApiGraphQlMultiActionVariable.Variable]) -> Variable {
                            return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: AsEmbarkApiGraphQlMultiActionVariable.Variable) -> ResultMap in value.resultMap }])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var apiVariablesFragment: ApiVariablesFragment {
                              get {
                                return ApiVariablesFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                              get {
                                if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                              get {
                                if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment? {
                              get {
                                if !ApiMultiActionVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }
                          }

                          public var asEmbarkApiGraphQlSingleVariable: AsEmbarkApiGraphQlSingleVariable? {
                            get {
                              if !AsEmbarkApiGraphQlSingleVariable.possibleTypes.contains(__typename) { return nil }
                              return AsEmbarkApiGraphQlSingleVariable(unsafeResultMap: resultMap)
                            }
                            set {
                              guard let newValue = newValue else { return }
                              resultMap = newValue.resultMap
                            }
                          }

                          public struct AsEmbarkApiGraphQlSingleVariable: GraphQLSelectionSet {
                            public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

                            public static var selections: [GraphQLSelection] {
                              return [
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                GraphQLField("from", type: .nonNull(.scalar(String.self))),
                                GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
                              ]
                            }

                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
                              self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                            }

                            public var __typename: String {
                              get {
                                return resultMap["__typename"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "__typename")
                              }
                            }

                            public var key: String {
                              get {
                                return resultMap["key"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "key")
                              }
                            }

                            public var from: String {
                              get {
                                return resultMap["from"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "from")
                              }
                            }

                            public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
                              get {
                                return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "as")
                              }
                            }

                            public var fragments: Fragments {
                              get {
                                return Fragments(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public struct Fragments {
                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public var apiVariablesFragment: ApiVariablesFragment {
                                get {
                                  return ApiVariablesFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public var apiSingleVariableFragment: ApiSingleVariableFragment {
                                get {
                                  return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                get {
                                  if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                  return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  guard let newValue = newValue else { return }
                                  resultMap += newValue.resultMap
                                }
                              }

                              public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment? {
                                get {
                                  if !ApiMultiActionVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                  return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  guard let newValue = newValue else { return }
                                  resultMap += newValue.resultMap
                                }
                              }
                            }
                          }

                          public var asEmbarkApiGraphQlGeneratedVariable: AsEmbarkApiGraphQlGeneratedVariable? {
                            get {
                              if !AsEmbarkApiGraphQlGeneratedVariable.possibleTypes.contains(__typename) { return nil }
                              return AsEmbarkApiGraphQlGeneratedVariable(unsafeResultMap: resultMap)
                            }
                            set {
                              guard let newValue = newValue else { return }
                              resultMap = newValue.resultMap
                            }
                          }

                          public struct AsEmbarkApiGraphQlGeneratedVariable: GraphQLSelectionSet {
                            public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

                            public static var selections: [GraphQLSelection] {
                              return [
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
                                GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
                              ]
                            }

                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
                              self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                            }

                            public var __typename: String {
                              get {
                                return resultMap["__typename"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "__typename")
                              }
                            }

                            public var key: String {
                              get {
                                return resultMap["key"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "key")
                              }
                            }

                            public var storeAs: String {
                              get {
                                return resultMap["storeAs"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "storeAs")
                              }
                            }

                            public var type: EmbarkAPIGraphQLVariableGeneratedType {
                              get {
                                return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "type")
                              }
                            }

                            public var fragments: Fragments {
                              get {
                                return Fragments(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public struct Fragments {
                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public var apiVariablesFragment: ApiVariablesFragment {
                                get {
                                  return ApiVariablesFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                get {
                                  if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                  return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  guard let newValue = newValue else { return }
                                  resultMap += newValue.resultMap
                                }
                              }

                              public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment {
                                get {
                                  return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment? {
                                get {
                                  if !ApiMultiActionVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                  return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  guard let newValue = newValue else { return }
                                  resultMap += newValue.resultMap
                                }
                              }
                            }
                          }

                          public var asEmbarkApiGraphQlMultiActionVariable: AsEmbarkApiGraphQlMultiActionVariable? {
                            get {
                              if !AsEmbarkApiGraphQlMultiActionVariable.possibleTypes.contains(__typename) { return nil }
                              return AsEmbarkApiGraphQlMultiActionVariable(unsafeResultMap: resultMap)
                            }
                            set {
                              guard let newValue = newValue else { return }
                              resultMap = newValue.resultMap
                            }
                          }

                          public struct AsEmbarkApiGraphQlMultiActionVariable: GraphQLSelectionSet {
                            public static let possibleTypes: [String] = ["EmbarkAPIGraphQLMultiActionVariable"]

                            public static var selections: [GraphQLSelection] {
                              return [
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                GraphQLField("variables", type: .nonNull(.list(.nonNull(.object(Variable.selections))))),
                              ]
                            }

                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public init(key: String, variables: [Variable]) {
                              self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: Variable) -> ResultMap in value.resultMap }])
                            }

                            public var __typename: String {
                              get {
                                return resultMap["__typename"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "__typename")
                              }
                            }

                            public var key: String {
                              get {
                                return resultMap["key"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "key")
                              }
                            }

                            public var variables: [Variable] {
                              get {
                                return (resultMap["variables"] as! [ResultMap]).map { (value: ResultMap) -> Variable in Variable(unsafeResultMap: value) }
                              }
                              set {
                                resultMap.updateValue(newValue.map { (value: Variable) -> ResultMap in value.resultMap }, forKey: "variables")
                              }
                            }

                            public var fragments: Fragments {
                              get {
                                return Fragments(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public struct Fragments {
                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public var apiVariablesFragment: ApiVariablesFragment {
                                get {
                                  return ApiVariablesFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                get {
                                  if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                  return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  guard let newValue = newValue else { return }
                                  resultMap += newValue.resultMap
                                }
                              }

                              public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                get {
                                  if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                  return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  guard let newValue = newValue else { return }
                                  resultMap += newValue.resultMap
                                }
                              }

                              public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment {
                                get {
                                  return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }
                            }

                            public struct Variable: GraphQLSelectionSet {
                              public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable", "EmbarkAPIGraphQLGeneratedVariable", "EmbarkAPIGraphQLMultiActionVariable", "EmbarkAPIGraphQLConstantVariable"]

                              public static var selections: [GraphQLSelection] {
                                return [
                                  GraphQLTypeCase(
                                    variants: ["EmbarkAPIGraphQLSingleVariable": AsEmbarkApiGraphQlSingleVariable.selections, "EmbarkAPIGraphQLGeneratedVariable": AsEmbarkApiGraphQlGeneratedVariable.selections, "EmbarkAPIGraphQLMultiActionVariable": AsEmbarkApiGraphQlMultiActionVariable.selections],
                                    default: [
                                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                    ]
                                  )
                                ]
                              }

                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public static func makeEmbarkAPIGraphQLConstantVariable() -> Variable {
                                return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLConstantVariable"])
                              }

                              public static func makeEmbarkAPIGraphQLSingleVariable(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) -> Variable {
                                return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                              }

                              public static func makeEmbarkAPIGraphQLGeneratedVariable(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) -> Variable {
                                return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                              }

                              public static func makeEmbarkAPIGraphQLMultiActionVariable(key: String, variables: [AsEmbarkApiGraphQlMultiActionVariable.Variable]) -> Variable {
                                return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: AsEmbarkApiGraphQlMultiActionVariable.Variable) -> ResultMap in value.resultMap }])
                              }

                              public var __typename: String {
                                get {
                                  return resultMap["__typename"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "__typename")
                                }
                              }

                              public var fragments: Fragments {
                                get {
                                  return Fragments(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public struct Fragments {
                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                  get {
                                    if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                    return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap += newValue.resultMap
                                  }
                                }

                                public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                  get {
                                    if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                    return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap += newValue.resultMap
                                  }
                                }
                              }

                              public var asEmbarkApiGraphQlSingleVariable: AsEmbarkApiGraphQlSingleVariable? {
                                get {
                                  if !AsEmbarkApiGraphQlSingleVariable.possibleTypes.contains(__typename) { return nil }
                                  return AsEmbarkApiGraphQlSingleVariable(unsafeResultMap: resultMap)
                                }
                                set {
                                  guard let newValue = newValue else { return }
                                  resultMap = newValue.resultMap
                                }
                              }

                              public struct AsEmbarkApiGraphQlSingleVariable: GraphQLSelectionSet {
                                public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

                                public static var selections: [GraphQLSelection] {
                                  return [
                                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                    GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                    GraphQLField("from", type: .nonNull(.scalar(String.self))),
                                    GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
                                  ]
                                }

                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
                                  self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                                }

                                public var __typename: String {
                                  get {
                                    return resultMap["__typename"]! as! String
                                  }
                                  set {
                                    resultMap.updateValue(newValue, forKey: "__typename")
                                  }
                                }

                                public var key: String {
                                  get {
                                    return resultMap["key"]! as! String
                                  }
                                  set {
                                    resultMap.updateValue(newValue, forKey: "key")
                                  }
                                }

                                public var from: String {
                                  get {
                                    return resultMap["from"]! as! String
                                  }
                                  set {
                                    resultMap.updateValue(newValue, forKey: "from")
                                  }
                                }

                                public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
                                  get {
                                    return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
                                  }
                                  set {
                                    resultMap.updateValue(newValue, forKey: "as")
                                  }
                                }

                                public var fragments: Fragments {
                                  get {
                                    return Fragments(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    resultMap += newValue.resultMap
                                  }
                                }

                                public struct Fragments {
                                  public private(set) var resultMap: ResultMap

                                  public init(unsafeResultMap: ResultMap) {
                                    self.resultMap = unsafeResultMap
                                  }

                                  public var apiSingleVariableFragment: ApiSingleVariableFragment {
                                    get {
                                      return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      resultMap += newValue.resultMap
                                    }
                                  }

                                  public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                    get {
                                      if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                      return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      guard let newValue = newValue else { return }
                                      resultMap += newValue.resultMap
                                    }
                                  }
                                }
                              }

                              public var asEmbarkApiGraphQlGeneratedVariable: AsEmbarkApiGraphQlGeneratedVariable? {
                                get {
                                  if !AsEmbarkApiGraphQlGeneratedVariable.possibleTypes.contains(__typename) { return nil }
                                  return AsEmbarkApiGraphQlGeneratedVariable(unsafeResultMap: resultMap)
                                }
                                set {
                                  guard let newValue = newValue else { return }
                                  resultMap = newValue.resultMap
                                }
                              }

                              public struct AsEmbarkApiGraphQlGeneratedVariable: GraphQLSelectionSet {
                                public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

                                public static var selections: [GraphQLSelection] {
                                  return [
                                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                    GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                    GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
                                    GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
                                  ]
                                }

                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
                                  self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                                }

                                public var __typename: String {
                                  get {
                                    return resultMap["__typename"]! as! String
                                  }
                                  set {
                                    resultMap.updateValue(newValue, forKey: "__typename")
                                  }
                                }

                                public var key: String {
                                  get {
                                    return resultMap["key"]! as! String
                                  }
                                  set {
                                    resultMap.updateValue(newValue, forKey: "key")
                                  }
                                }

                                public var storeAs: String {
                                  get {
                                    return resultMap["storeAs"]! as! String
                                  }
                                  set {
                                    resultMap.updateValue(newValue, forKey: "storeAs")
                                  }
                                }

                                public var type: EmbarkAPIGraphQLVariableGeneratedType {
                                  get {
                                    return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
                                  }
                                  set {
                                    resultMap.updateValue(newValue, forKey: "type")
                                  }
                                }

                                public var fragments: Fragments {
                                  get {
                                    return Fragments(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    resultMap += newValue.resultMap
                                  }
                                }

                                public struct Fragments {
                                  public private(set) var resultMap: ResultMap

                                  public init(unsafeResultMap: ResultMap) {
                                    self.resultMap = unsafeResultMap
                                  }

                                  public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                    get {
                                      if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                      return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      guard let newValue = newValue else { return }
                                      resultMap += newValue.resultMap
                                    }
                                  }

                                  public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment {
                                    get {
                                      return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      resultMap += newValue.resultMap
                                    }
                                  }
                                }
                              }

                              public var asEmbarkApiGraphQlMultiActionVariable: AsEmbarkApiGraphQlMultiActionVariable? {
                                get {
                                  if !AsEmbarkApiGraphQlMultiActionVariable.possibleTypes.contains(__typename) { return nil }
                                  return AsEmbarkApiGraphQlMultiActionVariable(unsafeResultMap: resultMap)
                                }
                                set {
                                  guard let newValue = newValue else { return }
                                  resultMap = newValue.resultMap
                                }
                              }

                              public struct AsEmbarkApiGraphQlMultiActionVariable: GraphQLSelectionSet {
                                public static let possibleTypes: [String] = ["EmbarkAPIGraphQLMultiActionVariable"]

                                public static var selections: [GraphQLSelection] {
                                  return [
                                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                    GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                    GraphQLField("variables", type: .nonNull(.list(.nonNull(.object(Variable.selections))))),
                                  ]
                                }

                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public init(key: String, variables: [Variable]) {
                                  self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: Variable) -> ResultMap in value.resultMap }])
                                }

                                public var __typename: String {
                                  get {
                                    return resultMap["__typename"]! as! String
                                  }
                                  set {
                                    resultMap.updateValue(newValue, forKey: "__typename")
                                  }
                                }

                                public var key: String {
                                  get {
                                    return resultMap["key"]! as! String
                                  }
                                  set {
                                    resultMap.updateValue(newValue, forKey: "key")
                                  }
                                }

                                public var variables: [Variable] {
                                  get {
                                    return (resultMap["variables"] as! [ResultMap]).map { (value: ResultMap) -> Variable in Variable(unsafeResultMap: value) }
                                  }
                                  set {
                                    resultMap.updateValue(newValue.map { (value: Variable) -> ResultMap in value.resultMap }, forKey: "variables")
                                  }
                                }

                                public var fragments: Fragments {
                                  get {
                                    return Fragments(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    resultMap += newValue.resultMap
                                  }
                                }

                                public struct Fragments {
                                  public private(set) var resultMap: ResultMap

                                  public init(unsafeResultMap: ResultMap) {
                                    self.resultMap = unsafeResultMap
                                  }

                                  public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                    get {
                                      if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                      return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      guard let newValue = newValue else { return }
                                      resultMap += newValue.resultMap
                                    }
                                  }

                                  public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                    get {
                                      if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                      return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      guard let newValue = newValue else { return }
                                      resultMap += newValue.resultMap
                                    }
                                  }
                                }

                                public struct Variable: GraphQLSelectionSet {
                                  public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable", "EmbarkAPIGraphQLGeneratedVariable", "EmbarkAPIGraphQLMultiActionVariable", "EmbarkAPIGraphQLConstantVariable"]

                                  public static var selections: [GraphQLSelection] {
                                    return [
                                      GraphQLTypeCase(
                                        variants: ["EmbarkAPIGraphQLSingleVariable": AsEmbarkApiGraphQlSingleVariable.selections, "EmbarkAPIGraphQLGeneratedVariable": AsEmbarkApiGraphQlGeneratedVariable.selections],
                                        default: [
                                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                        ]
                                      )
                                    ]
                                  }

                                  public private(set) var resultMap: ResultMap

                                  public init(unsafeResultMap: ResultMap) {
                                    self.resultMap = unsafeResultMap
                                  }

                                  public static func makeEmbarkAPIGraphQLMultiActionVariable() -> Variable {
                                    return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable"])
                                  }

                                  public static func makeEmbarkAPIGraphQLConstantVariable() -> Variable {
                                    return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLConstantVariable"])
                                  }

                                  public static func makeEmbarkAPIGraphQLSingleVariable(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) -> Variable {
                                    return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                                  }

                                  public static func makeEmbarkAPIGraphQLGeneratedVariable(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) -> Variable {
                                    return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                                  }

                                  public var __typename: String {
                                    get {
                                      return resultMap["__typename"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "__typename")
                                    }
                                  }

                                  public var fragments: Fragments {
                                    get {
                                      return Fragments(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      resultMap += newValue.resultMap
                                    }
                                  }

                                  public struct Fragments {
                                    public private(set) var resultMap: ResultMap

                                    public init(unsafeResultMap: ResultMap) {
                                      self.resultMap = unsafeResultMap
                                    }

                                    public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                      get {
                                        if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                        return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                      }
                                      set {
                                        guard let newValue = newValue else { return }
                                        resultMap += newValue.resultMap
                                      }
                                    }

                                    public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                      get {
                                        if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                        return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                      }
                                      set {
                                        guard let newValue = newValue else { return }
                                        resultMap += newValue.resultMap
                                      }
                                    }
                                  }

                                  public var asEmbarkApiGraphQlSingleVariable: AsEmbarkApiGraphQlSingleVariable? {
                                    get {
                                      if !AsEmbarkApiGraphQlSingleVariable.possibleTypes.contains(__typename) { return nil }
                                      return AsEmbarkApiGraphQlSingleVariable(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      guard let newValue = newValue else { return }
                                      resultMap = newValue.resultMap
                                    }
                                  }

                                  public struct AsEmbarkApiGraphQlSingleVariable: GraphQLSelectionSet {
                                    public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

                                    public static var selections: [GraphQLSelection] {
                                      return [
                                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                        GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                        GraphQLField("from", type: .nonNull(.scalar(String.self))),
                                        GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
                                      ]
                                    }

                                    public private(set) var resultMap: ResultMap

                                    public init(unsafeResultMap: ResultMap) {
                                      self.resultMap = unsafeResultMap
                                    }

                                    public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
                                      self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                                    }

                                    public var __typename: String {
                                      get {
                                        return resultMap["__typename"]! as! String
                                      }
                                      set {
                                        resultMap.updateValue(newValue, forKey: "__typename")
                                      }
                                    }

                                    public var key: String {
                                      get {
                                        return resultMap["key"]! as! String
                                      }
                                      set {
                                        resultMap.updateValue(newValue, forKey: "key")
                                      }
                                    }

                                    public var from: String {
                                      get {
                                        return resultMap["from"]! as! String
                                      }
                                      set {
                                        resultMap.updateValue(newValue, forKey: "from")
                                      }
                                    }

                                    public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
                                      get {
                                        return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
                                      }
                                      set {
                                        resultMap.updateValue(newValue, forKey: "as")
                                      }
                                    }

                                    public var fragments: Fragments {
                                      get {
                                        return Fragments(unsafeResultMap: resultMap)
                                      }
                                      set {
                                        resultMap += newValue.resultMap
                                      }
                                    }

                                    public struct Fragments {
                                      public private(set) var resultMap: ResultMap

                                      public init(unsafeResultMap: ResultMap) {
                                        self.resultMap = unsafeResultMap
                                      }

                                      public var apiSingleVariableFragment: ApiSingleVariableFragment {
                                        get {
                                          return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                        }
                                        set {
                                          resultMap += newValue.resultMap
                                        }
                                      }

                                      public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                        get {
                                          if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                          return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                        }
                                        set {
                                          guard let newValue = newValue else { return }
                                          resultMap += newValue.resultMap
                                        }
                                      }
                                    }
                                  }

                                  public var asEmbarkApiGraphQlGeneratedVariable: AsEmbarkApiGraphQlGeneratedVariable? {
                                    get {
                                      if !AsEmbarkApiGraphQlGeneratedVariable.possibleTypes.contains(__typename) { return nil }
                                      return AsEmbarkApiGraphQlGeneratedVariable(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      guard let newValue = newValue else { return }
                                      resultMap = newValue.resultMap
                                    }
                                  }

                                  public struct AsEmbarkApiGraphQlGeneratedVariable: GraphQLSelectionSet {
                                    public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

                                    public static var selections: [GraphQLSelection] {
                                      return [
                                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                        GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                        GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
                                        GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
                                      ]
                                    }

                                    public private(set) var resultMap: ResultMap

                                    public init(unsafeResultMap: ResultMap) {
                                      self.resultMap = unsafeResultMap
                                    }

                                    public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
                                      self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                                    }

                                    public var __typename: String {
                                      get {
                                        return resultMap["__typename"]! as! String
                                      }
                                      set {
                                        resultMap.updateValue(newValue, forKey: "__typename")
                                      }
                                    }

                                    public var key: String {
                                      get {
                                        return resultMap["key"]! as! String
                                      }
                                      set {
                                        resultMap.updateValue(newValue, forKey: "key")
                                      }
                                    }

                                    public var storeAs: String {
                                      get {
                                        return resultMap["storeAs"]! as! String
                                      }
                                      set {
                                        resultMap.updateValue(newValue, forKey: "storeAs")
                                      }
                                    }

                                    public var type: EmbarkAPIGraphQLVariableGeneratedType {
                                      get {
                                        return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
                                      }
                                      set {
                                        resultMap.updateValue(newValue, forKey: "type")
                                      }
                                    }

                                    public var fragments: Fragments {
                                      get {
                                        return Fragments(unsafeResultMap: resultMap)
                                      }
                                      set {
                                        resultMap += newValue.resultMap
                                      }
                                    }

                                    public struct Fragments {
                                      public private(set) var resultMap: ResultMap

                                      public init(unsafeResultMap: ResultMap) {
                                        self.resultMap = unsafeResultMap
                                      }

                                      public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                        get {
                                          if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                          return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                        }
                                        set {
                                          guard let newValue = newValue else { return }
                                          resultMap += newValue.resultMap
                                        }
                                      }

                                      public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment {
                                        get {
                                          return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                        }
                                        set {
                                          resultMap += newValue.resultMap
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }

                        public struct QueryResult: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkAPIGraphQLResult"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("key", type: .nonNull(.scalar(String.self))),
                              GraphQLField("as", type: .nonNull(.scalar(String.self))),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(key: String, `as`: String) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLResult", "key": key, "as": `as`])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var key: String {
                            get {
                              return resultMap["key"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "key")
                            }
                          }

                          public var `as`: String {
                            get {
                              return resultMap["as"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "as")
                            }
                          }
                        }

                        public struct QueryError: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkAPIGraphQLError"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("contains", type: .scalar(String.self)),
                              GraphQLField("next", type: .nonNull(.object(Next.selections))),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(contains: String? = nil, next: Next) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLError", "contains": contains, "next": next.resultMap])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var contains: String? {
                            get {
                              return resultMap["contains"] as? String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "contains")
                            }
                          }

                          public var next: Next {
                            get {
                              return Next(unsafeResultMap: resultMap["next"]! as! ResultMap)
                            }
                            set {
                              resultMap.updateValue(newValue.resultMap, forKey: "next")
                            }
                          }

                          public struct Next: GraphQLSelectionSet {
                            public static let possibleTypes: [String] = ["EmbarkLink"]

                            public static var selections: [GraphQLSelection] {
                              return [
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("name", type: .nonNull(.scalar(String.self))),
                                GraphQLField("label", type: .nonNull(.scalar(String.self))),
                              ]
                            }

                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public init(name: String, label: String) {
                              self.init(unsafeResultMap: ["__typename": "EmbarkLink", "name": name, "label": label])
                            }

                            public var __typename: String {
                              get {
                                return resultMap["__typename"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "__typename")
                              }
                            }

                            public var name: String {
                              get {
                                return resultMap["name"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "name")
                              }
                            }

                            public var label: String {
                              get {
                                return resultMap["label"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "label")
                              }
                            }

                            public var fragments: Fragments {
                              get {
                                return Fragments(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public struct Fragments {
                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public var embarkLinkFragment: EmbarkLinkFragment {
                                get {
                                  return EmbarkLinkFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }
                            }
                          }
                        }
                      }
                    }

                    public var asEmbarkApiGraphQlMutation: AsEmbarkApiGraphQlMutation? {
                      get {
                        if !AsEmbarkApiGraphQlMutation.possibleTypes.contains(__typename) { return nil }
                        return AsEmbarkApiGraphQlMutation(unsafeResultMap: resultMap)
                      }
                      set {
                        guard let newValue = newValue else { return }
                        resultMap = newValue.resultMap
                      }
                    }

                    public struct AsEmbarkApiGraphQlMutation: GraphQLSelectionSet {
                      public static let possibleTypes: [String] = ["EmbarkApiGraphQLMutation"]

                      public static var selections: [GraphQLSelection] {
                        return [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("data", type: .nonNull(.object(Datum.selections))),
                        ]
                      }

                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public init(data: Datum) {
                        self.init(unsafeResultMap: ["__typename": "EmbarkApiGraphQLMutation", "data": data.resultMap])
                      }

                      public var __typename: String {
                        get {
                          return resultMap["__typename"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "__typename")
                        }
                      }

                      public var data: Datum {
                        get {
                          return Datum(unsafeResultMap: resultMap["data"]! as! ResultMap)
                        }
                        set {
                          resultMap.updateValue(newValue.resultMap, forKey: "data")
                        }
                      }

                      public var fragments: Fragments {
                        get {
                          return Fragments(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public struct Fragments {
                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public var apiFragment: ApiFragment {
                          get {
                            return ApiFragment(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }
                      }

                      public struct Datum: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkApiGraphQLMutationData"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("next", type: .object(Next.selections)),
                            GraphQLField("mutation", type: .nonNull(.scalar(String.self))),
                            GraphQLField("variables", type: .nonNull(.list(.nonNull(.object(Variable.selections))))),
                            GraphQLField("results", alias: "mutationResults", type: .nonNull(.list(.object(MutationResult.selections)))),
                            GraphQLField("errors", alias: "mutationErrors", type: .nonNull(.list(.nonNull(.object(MutationError.selections))))),
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public init(next: Next? = nil, mutation: String, variables: [Variable], mutationResults: [MutationResult?], mutationErrors: [MutationError]) {
                          self.init(unsafeResultMap: ["__typename": "EmbarkApiGraphQLMutationData", "next": next.flatMap { (value: Next) -> ResultMap in value.resultMap }, "mutation": mutation, "variables": variables.map { (value: Variable) -> ResultMap in value.resultMap }, "mutationResults": mutationResults.map { (value: MutationResult?) -> ResultMap? in value.flatMap { (value: MutationResult) -> ResultMap in value.resultMap } }, "mutationErrors": mutationErrors.map { (value: MutationError) -> ResultMap in value.resultMap }])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var next: Next? {
                          get {
                            return (resultMap["next"] as? ResultMap).flatMap { Next(unsafeResultMap: $0) }
                          }
                          set {
                            resultMap.updateValue(newValue?.resultMap, forKey: "next")
                          }
                        }

                        public var mutation: String {
                          get {
                            return resultMap["mutation"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "mutation")
                          }
                        }

                        public var variables: [Variable] {
                          get {
                            return (resultMap["variables"] as! [ResultMap]).map { (value: ResultMap) -> Variable in Variable(unsafeResultMap: value) }
                          }
                          set {
                            resultMap.updateValue(newValue.map { (value: Variable) -> ResultMap in value.resultMap }, forKey: "variables")
                          }
                        }

                        public var mutationResults: [MutationResult?] {
                          get {
                            return (resultMap["mutationResults"] as! [ResultMap?]).map { (value: ResultMap?) -> MutationResult? in value.flatMap { (value: ResultMap) -> MutationResult in MutationResult(unsafeResultMap: value) } }
                          }
                          set {
                            resultMap.updateValue(newValue.map { (value: MutationResult?) -> ResultMap? in value.flatMap { (value: MutationResult) -> ResultMap in value.resultMap } }, forKey: "mutationResults")
                          }
                        }

                        public var mutationErrors: [MutationError] {
                          get {
                            return (resultMap["mutationErrors"] as! [ResultMap]).map { (value: ResultMap) -> MutationError in MutationError(unsafeResultMap: value) }
                          }
                          set {
                            resultMap.updateValue(newValue.map { (value: MutationError) -> ResultMap in value.resultMap }, forKey: "mutationErrors")
                          }
                        }

                        public struct Next: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkLink"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("name", type: .nonNull(.scalar(String.self))),
                              GraphQLField("label", type: .nonNull(.scalar(String.self))),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(name: String, label: String) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkLink", "name": name, "label": label])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var name: String {
                            get {
                              return resultMap["name"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "name")
                            }
                          }

                          public var label: String {
                            get {
                              return resultMap["label"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "label")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var embarkLinkFragment: EmbarkLinkFragment {
                              get {
                                return EmbarkLinkFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }
                          }
                        }

                        public struct Variable: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable", "EmbarkAPIGraphQLGeneratedVariable", "EmbarkAPIGraphQLMultiActionVariable", "EmbarkAPIGraphQLConstantVariable"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLTypeCase(
                                variants: ["EmbarkAPIGraphQLSingleVariable": AsEmbarkApiGraphQlSingleVariable.selections, "EmbarkAPIGraphQLGeneratedVariable": AsEmbarkApiGraphQlGeneratedVariable.selections, "EmbarkAPIGraphQLMultiActionVariable": AsEmbarkApiGraphQlMultiActionVariable.selections],
                                default: [
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                ]
                              )
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public static func makeEmbarkAPIGraphQLConstantVariable() -> Variable {
                            return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLConstantVariable"])
                          }

                          public static func makeEmbarkAPIGraphQLSingleVariable(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) -> Variable {
                            return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                          }

                          public static func makeEmbarkAPIGraphQLGeneratedVariable(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) -> Variable {
                            return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                          }

                          public static func makeEmbarkAPIGraphQLMultiActionVariable(key: String, variables: [AsEmbarkApiGraphQlMultiActionVariable.Variable]) -> Variable {
                            return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: AsEmbarkApiGraphQlMultiActionVariable.Variable) -> ResultMap in value.resultMap }])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var apiVariablesFragment: ApiVariablesFragment {
                              get {
                                return ApiVariablesFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                              get {
                                if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                              get {
                                if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }

                            public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment? {
                              get {
                                if !ApiMultiActionVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                guard let newValue = newValue else { return }
                                resultMap += newValue.resultMap
                              }
                            }
                          }

                          public var asEmbarkApiGraphQlSingleVariable: AsEmbarkApiGraphQlSingleVariable? {
                            get {
                              if !AsEmbarkApiGraphQlSingleVariable.possibleTypes.contains(__typename) { return nil }
                              return AsEmbarkApiGraphQlSingleVariable(unsafeResultMap: resultMap)
                            }
                            set {
                              guard let newValue = newValue else { return }
                              resultMap = newValue.resultMap
                            }
                          }

                          public struct AsEmbarkApiGraphQlSingleVariable: GraphQLSelectionSet {
                            public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

                            public static var selections: [GraphQLSelection] {
                              return [
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                GraphQLField("from", type: .nonNull(.scalar(String.self))),
                                GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
                              ]
                            }

                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
                              self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                            }

                            public var __typename: String {
                              get {
                                return resultMap["__typename"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "__typename")
                              }
                            }

                            public var key: String {
                              get {
                                return resultMap["key"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "key")
                              }
                            }

                            public var from: String {
                              get {
                                return resultMap["from"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "from")
                              }
                            }

                            public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
                              get {
                                return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "as")
                              }
                            }

                            public var fragments: Fragments {
                              get {
                                return Fragments(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public struct Fragments {
                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public var apiVariablesFragment: ApiVariablesFragment {
                                get {
                                  return ApiVariablesFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public var apiSingleVariableFragment: ApiSingleVariableFragment {
                                get {
                                  return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                get {
                                  if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                  return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  guard let newValue = newValue else { return }
                                  resultMap += newValue.resultMap
                                }
                              }

                              public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment? {
                                get {
                                  if !ApiMultiActionVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                  return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  guard let newValue = newValue else { return }
                                  resultMap += newValue.resultMap
                                }
                              }
                            }
                          }

                          public var asEmbarkApiGraphQlGeneratedVariable: AsEmbarkApiGraphQlGeneratedVariable? {
                            get {
                              if !AsEmbarkApiGraphQlGeneratedVariable.possibleTypes.contains(__typename) { return nil }
                              return AsEmbarkApiGraphQlGeneratedVariable(unsafeResultMap: resultMap)
                            }
                            set {
                              guard let newValue = newValue else { return }
                              resultMap = newValue.resultMap
                            }
                          }

                          public struct AsEmbarkApiGraphQlGeneratedVariable: GraphQLSelectionSet {
                            public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

                            public static var selections: [GraphQLSelection] {
                              return [
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
                                GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
                              ]
                            }

                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
                              self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                            }

                            public var __typename: String {
                              get {
                                return resultMap["__typename"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "__typename")
                              }
                            }

                            public var key: String {
                              get {
                                return resultMap["key"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "key")
                              }
                            }

                            public var storeAs: String {
                              get {
                                return resultMap["storeAs"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "storeAs")
                              }
                            }

                            public var type: EmbarkAPIGraphQLVariableGeneratedType {
                              get {
                                return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "type")
                              }
                            }

                            public var fragments: Fragments {
                              get {
                                return Fragments(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public struct Fragments {
                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public var apiVariablesFragment: ApiVariablesFragment {
                                get {
                                  return ApiVariablesFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                get {
                                  if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                  return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  guard let newValue = newValue else { return }
                                  resultMap += newValue.resultMap
                                }
                              }

                              public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment {
                                get {
                                  return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment? {
                                get {
                                  if !ApiMultiActionVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                  return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  guard let newValue = newValue else { return }
                                  resultMap += newValue.resultMap
                                }
                              }
                            }
                          }

                          public var asEmbarkApiGraphQlMultiActionVariable: AsEmbarkApiGraphQlMultiActionVariable? {
                            get {
                              if !AsEmbarkApiGraphQlMultiActionVariable.possibleTypes.contains(__typename) { return nil }
                              return AsEmbarkApiGraphQlMultiActionVariable(unsafeResultMap: resultMap)
                            }
                            set {
                              guard let newValue = newValue else { return }
                              resultMap = newValue.resultMap
                            }
                          }

                          public struct AsEmbarkApiGraphQlMultiActionVariable: GraphQLSelectionSet {
                            public static let possibleTypes: [String] = ["EmbarkAPIGraphQLMultiActionVariable"]

                            public static var selections: [GraphQLSelection] {
                              return [
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                GraphQLField("variables", type: .nonNull(.list(.nonNull(.object(Variable.selections))))),
                              ]
                            }

                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public init(key: String, variables: [Variable]) {
                              self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: Variable) -> ResultMap in value.resultMap }])
                            }

                            public var __typename: String {
                              get {
                                return resultMap["__typename"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "__typename")
                              }
                            }

                            public var key: String {
                              get {
                                return resultMap["key"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "key")
                              }
                            }

                            public var variables: [Variable] {
                              get {
                                return (resultMap["variables"] as! [ResultMap]).map { (value: ResultMap) -> Variable in Variable(unsafeResultMap: value) }
                              }
                              set {
                                resultMap.updateValue(newValue.map { (value: Variable) -> ResultMap in value.resultMap }, forKey: "variables")
                              }
                            }

                            public var fragments: Fragments {
                              get {
                                return Fragments(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public struct Fragments {
                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public var apiVariablesFragment: ApiVariablesFragment {
                                get {
                                  return ApiVariablesFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                get {
                                  if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                  return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  guard let newValue = newValue else { return }
                                  resultMap += newValue.resultMap
                                }
                              }

                              public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                get {
                                  if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                  return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  guard let newValue = newValue else { return }
                                  resultMap += newValue.resultMap
                                }
                              }

                              public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment {
                                get {
                                  return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }
                            }

                            public struct Variable: GraphQLSelectionSet {
                              public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable", "EmbarkAPIGraphQLGeneratedVariable", "EmbarkAPIGraphQLMultiActionVariable", "EmbarkAPIGraphQLConstantVariable"]

                              public static var selections: [GraphQLSelection] {
                                return [
                                  GraphQLTypeCase(
                                    variants: ["EmbarkAPIGraphQLSingleVariable": AsEmbarkApiGraphQlSingleVariable.selections, "EmbarkAPIGraphQLGeneratedVariable": AsEmbarkApiGraphQlGeneratedVariable.selections, "EmbarkAPIGraphQLMultiActionVariable": AsEmbarkApiGraphQlMultiActionVariable.selections],
                                    default: [
                                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                    ]
                                  )
                                ]
                              }

                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public static func makeEmbarkAPIGraphQLConstantVariable() -> Variable {
                                return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLConstantVariable"])
                              }

                              public static func makeEmbarkAPIGraphQLSingleVariable(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) -> Variable {
                                return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                              }

                              public static func makeEmbarkAPIGraphQLGeneratedVariable(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) -> Variable {
                                return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                              }

                              public static func makeEmbarkAPIGraphQLMultiActionVariable(key: String, variables: [AsEmbarkApiGraphQlMultiActionVariable.Variable]) -> Variable {
                                return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: AsEmbarkApiGraphQlMultiActionVariable.Variable) -> ResultMap in value.resultMap }])
                              }

                              public var __typename: String {
                                get {
                                  return resultMap["__typename"]! as! String
                                }
                                set {
                                  resultMap.updateValue(newValue, forKey: "__typename")
                                }
                              }

                              public var fragments: Fragments {
                                get {
                                  return Fragments(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }

                              public struct Fragments {
                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                  get {
                                    if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                    return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap += newValue.resultMap
                                  }
                                }

                                public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                  get {
                                    if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                    return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    guard let newValue = newValue else { return }
                                    resultMap += newValue.resultMap
                                  }
                                }
                              }

                              public var asEmbarkApiGraphQlSingleVariable: AsEmbarkApiGraphQlSingleVariable? {
                                get {
                                  if !AsEmbarkApiGraphQlSingleVariable.possibleTypes.contains(__typename) { return nil }
                                  return AsEmbarkApiGraphQlSingleVariable(unsafeResultMap: resultMap)
                                }
                                set {
                                  guard let newValue = newValue else { return }
                                  resultMap = newValue.resultMap
                                }
                              }

                              public struct AsEmbarkApiGraphQlSingleVariable: GraphQLSelectionSet {
                                public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

                                public static var selections: [GraphQLSelection] {
                                  return [
                                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                    GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                    GraphQLField("from", type: .nonNull(.scalar(String.self))),
                                    GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
                                  ]
                                }

                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
                                  self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                                }

                                public var __typename: String {
                                  get {
                                    return resultMap["__typename"]! as! String
                                  }
                                  set {
                                    resultMap.updateValue(newValue, forKey: "__typename")
                                  }
                                }

                                public var key: String {
                                  get {
                                    return resultMap["key"]! as! String
                                  }
                                  set {
                                    resultMap.updateValue(newValue, forKey: "key")
                                  }
                                }

                                public var from: String {
                                  get {
                                    return resultMap["from"]! as! String
                                  }
                                  set {
                                    resultMap.updateValue(newValue, forKey: "from")
                                  }
                                }

                                public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
                                  get {
                                    return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
                                  }
                                  set {
                                    resultMap.updateValue(newValue, forKey: "as")
                                  }
                                }

                                public var fragments: Fragments {
                                  get {
                                    return Fragments(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    resultMap += newValue.resultMap
                                  }
                                }

                                public struct Fragments {
                                  public private(set) var resultMap: ResultMap

                                  public init(unsafeResultMap: ResultMap) {
                                    self.resultMap = unsafeResultMap
                                  }

                                  public var apiSingleVariableFragment: ApiSingleVariableFragment {
                                    get {
                                      return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      resultMap += newValue.resultMap
                                    }
                                  }

                                  public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                    get {
                                      if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                      return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      guard let newValue = newValue else { return }
                                      resultMap += newValue.resultMap
                                    }
                                  }
                                }
                              }

                              public var asEmbarkApiGraphQlGeneratedVariable: AsEmbarkApiGraphQlGeneratedVariable? {
                                get {
                                  if !AsEmbarkApiGraphQlGeneratedVariable.possibleTypes.contains(__typename) { return nil }
                                  return AsEmbarkApiGraphQlGeneratedVariable(unsafeResultMap: resultMap)
                                }
                                set {
                                  guard let newValue = newValue else { return }
                                  resultMap = newValue.resultMap
                                }
                              }

                              public struct AsEmbarkApiGraphQlGeneratedVariable: GraphQLSelectionSet {
                                public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

                                public static var selections: [GraphQLSelection] {
                                  return [
                                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                    GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                    GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
                                    GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
                                  ]
                                }

                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
                                  self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                                }

                                public var __typename: String {
                                  get {
                                    return resultMap["__typename"]! as! String
                                  }
                                  set {
                                    resultMap.updateValue(newValue, forKey: "__typename")
                                  }
                                }

                                public var key: String {
                                  get {
                                    return resultMap["key"]! as! String
                                  }
                                  set {
                                    resultMap.updateValue(newValue, forKey: "key")
                                  }
                                }

                                public var storeAs: String {
                                  get {
                                    return resultMap["storeAs"]! as! String
                                  }
                                  set {
                                    resultMap.updateValue(newValue, forKey: "storeAs")
                                  }
                                }

                                public var type: EmbarkAPIGraphQLVariableGeneratedType {
                                  get {
                                    return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
                                  }
                                  set {
                                    resultMap.updateValue(newValue, forKey: "type")
                                  }
                                }

                                public var fragments: Fragments {
                                  get {
                                    return Fragments(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    resultMap += newValue.resultMap
                                  }
                                }

                                public struct Fragments {
                                  public private(set) var resultMap: ResultMap

                                  public init(unsafeResultMap: ResultMap) {
                                    self.resultMap = unsafeResultMap
                                  }

                                  public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                    get {
                                      if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                      return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      guard let newValue = newValue else { return }
                                      resultMap += newValue.resultMap
                                    }
                                  }

                                  public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment {
                                    get {
                                      return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      resultMap += newValue.resultMap
                                    }
                                  }
                                }
                              }

                              public var asEmbarkApiGraphQlMultiActionVariable: AsEmbarkApiGraphQlMultiActionVariable? {
                                get {
                                  if !AsEmbarkApiGraphQlMultiActionVariable.possibleTypes.contains(__typename) { return nil }
                                  return AsEmbarkApiGraphQlMultiActionVariable(unsafeResultMap: resultMap)
                                }
                                set {
                                  guard let newValue = newValue else { return }
                                  resultMap = newValue.resultMap
                                }
                              }

                              public struct AsEmbarkApiGraphQlMultiActionVariable: GraphQLSelectionSet {
                                public static let possibleTypes: [String] = ["EmbarkAPIGraphQLMultiActionVariable"]

                                public static var selections: [GraphQLSelection] {
                                  return [
                                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                    GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                    GraphQLField("variables", type: .nonNull(.list(.nonNull(.object(Variable.selections))))),
                                  ]
                                }

                                public private(set) var resultMap: ResultMap

                                public init(unsafeResultMap: ResultMap) {
                                  self.resultMap = unsafeResultMap
                                }

                                public init(key: String, variables: [Variable]) {
                                  self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: Variable) -> ResultMap in value.resultMap }])
                                }

                                public var __typename: String {
                                  get {
                                    return resultMap["__typename"]! as! String
                                  }
                                  set {
                                    resultMap.updateValue(newValue, forKey: "__typename")
                                  }
                                }

                                public var key: String {
                                  get {
                                    return resultMap["key"]! as! String
                                  }
                                  set {
                                    resultMap.updateValue(newValue, forKey: "key")
                                  }
                                }

                                public var variables: [Variable] {
                                  get {
                                    return (resultMap["variables"] as! [ResultMap]).map { (value: ResultMap) -> Variable in Variable(unsafeResultMap: value) }
                                  }
                                  set {
                                    resultMap.updateValue(newValue.map { (value: Variable) -> ResultMap in value.resultMap }, forKey: "variables")
                                  }
                                }

                                public var fragments: Fragments {
                                  get {
                                    return Fragments(unsafeResultMap: resultMap)
                                  }
                                  set {
                                    resultMap += newValue.resultMap
                                  }
                                }

                                public struct Fragments {
                                  public private(set) var resultMap: ResultMap

                                  public init(unsafeResultMap: ResultMap) {
                                    self.resultMap = unsafeResultMap
                                  }

                                  public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                    get {
                                      if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                      return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      guard let newValue = newValue else { return }
                                      resultMap += newValue.resultMap
                                    }
                                  }

                                  public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                    get {
                                      if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                      return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      guard let newValue = newValue else { return }
                                      resultMap += newValue.resultMap
                                    }
                                  }
                                }

                                public struct Variable: GraphQLSelectionSet {
                                  public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable", "EmbarkAPIGraphQLGeneratedVariable", "EmbarkAPIGraphQLMultiActionVariable", "EmbarkAPIGraphQLConstantVariable"]

                                  public static var selections: [GraphQLSelection] {
                                    return [
                                      GraphQLTypeCase(
                                        variants: ["EmbarkAPIGraphQLSingleVariable": AsEmbarkApiGraphQlSingleVariable.selections, "EmbarkAPIGraphQLGeneratedVariable": AsEmbarkApiGraphQlGeneratedVariable.selections],
                                        default: [
                                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                        ]
                                      )
                                    ]
                                  }

                                  public private(set) var resultMap: ResultMap

                                  public init(unsafeResultMap: ResultMap) {
                                    self.resultMap = unsafeResultMap
                                  }

                                  public static func makeEmbarkAPIGraphQLMultiActionVariable() -> Variable {
                                    return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable"])
                                  }

                                  public static func makeEmbarkAPIGraphQLConstantVariable() -> Variable {
                                    return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLConstantVariable"])
                                  }

                                  public static func makeEmbarkAPIGraphQLSingleVariable(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) -> Variable {
                                    return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                                  }

                                  public static func makeEmbarkAPIGraphQLGeneratedVariable(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) -> Variable {
                                    return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                                  }

                                  public var __typename: String {
                                    get {
                                      return resultMap["__typename"]! as! String
                                    }
                                    set {
                                      resultMap.updateValue(newValue, forKey: "__typename")
                                    }
                                  }

                                  public var fragments: Fragments {
                                    get {
                                      return Fragments(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      resultMap += newValue.resultMap
                                    }
                                  }

                                  public struct Fragments {
                                    public private(set) var resultMap: ResultMap

                                    public init(unsafeResultMap: ResultMap) {
                                      self.resultMap = unsafeResultMap
                                    }

                                    public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                      get {
                                        if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                        return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                      }
                                      set {
                                        guard let newValue = newValue else { return }
                                        resultMap += newValue.resultMap
                                      }
                                    }

                                    public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                      get {
                                        if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                        return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                      }
                                      set {
                                        guard let newValue = newValue else { return }
                                        resultMap += newValue.resultMap
                                      }
                                    }
                                  }

                                  public var asEmbarkApiGraphQlSingleVariable: AsEmbarkApiGraphQlSingleVariable? {
                                    get {
                                      if !AsEmbarkApiGraphQlSingleVariable.possibleTypes.contains(__typename) { return nil }
                                      return AsEmbarkApiGraphQlSingleVariable(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      guard let newValue = newValue else { return }
                                      resultMap = newValue.resultMap
                                    }
                                  }

                                  public struct AsEmbarkApiGraphQlSingleVariable: GraphQLSelectionSet {
                                    public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

                                    public static var selections: [GraphQLSelection] {
                                      return [
                                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                        GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                        GraphQLField("from", type: .nonNull(.scalar(String.self))),
                                        GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
                                      ]
                                    }

                                    public private(set) var resultMap: ResultMap

                                    public init(unsafeResultMap: ResultMap) {
                                      self.resultMap = unsafeResultMap
                                    }

                                    public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
                                      self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                                    }

                                    public var __typename: String {
                                      get {
                                        return resultMap["__typename"]! as! String
                                      }
                                      set {
                                        resultMap.updateValue(newValue, forKey: "__typename")
                                      }
                                    }

                                    public var key: String {
                                      get {
                                        return resultMap["key"]! as! String
                                      }
                                      set {
                                        resultMap.updateValue(newValue, forKey: "key")
                                      }
                                    }

                                    public var from: String {
                                      get {
                                        return resultMap["from"]! as! String
                                      }
                                      set {
                                        resultMap.updateValue(newValue, forKey: "from")
                                      }
                                    }

                                    public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
                                      get {
                                        return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
                                      }
                                      set {
                                        resultMap.updateValue(newValue, forKey: "as")
                                      }
                                    }

                                    public var fragments: Fragments {
                                      get {
                                        return Fragments(unsafeResultMap: resultMap)
                                      }
                                      set {
                                        resultMap += newValue.resultMap
                                      }
                                    }

                                    public struct Fragments {
                                      public private(set) var resultMap: ResultMap

                                      public init(unsafeResultMap: ResultMap) {
                                        self.resultMap = unsafeResultMap
                                      }

                                      public var apiSingleVariableFragment: ApiSingleVariableFragment {
                                        get {
                                          return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                        }
                                        set {
                                          resultMap += newValue.resultMap
                                        }
                                      }

                                      public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                                        get {
                                          if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                          return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                        }
                                        set {
                                          guard let newValue = newValue else { return }
                                          resultMap += newValue.resultMap
                                        }
                                      }
                                    }
                                  }

                                  public var asEmbarkApiGraphQlGeneratedVariable: AsEmbarkApiGraphQlGeneratedVariable? {
                                    get {
                                      if !AsEmbarkApiGraphQlGeneratedVariable.possibleTypes.contains(__typename) { return nil }
                                      return AsEmbarkApiGraphQlGeneratedVariable(unsafeResultMap: resultMap)
                                    }
                                    set {
                                      guard let newValue = newValue else { return }
                                      resultMap = newValue.resultMap
                                    }
                                  }

                                  public struct AsEmbarkApiGraphQlGeneratedVariable: GraphQLSelectionSet {
                                    public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

                                    public static var selections: [GraphQLSelection] {
                                      return [
                                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                        GraphQLField("key", type: .nonNull(.scalar(String.self))),
                                        GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
                                        GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
                                      ]
                                    }

                                    public private(set) var resultMap: ResultMap

                                    public init(unsafeResultMap: ResultMap) {
                                      self.resultMap = unsafeResultMap
                                    }

                                    public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
                                      self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                                    }

                                    public var __typename: String {
                                      get {
                                        return resultMap["__typename"]! as! String
                                      }
                                      set {
                                        resultMap.updateValue(newValue, forKey: "__typename")
                                      }
                                    }

                                    public var key: String {
                                      get {
                                        return resultMap["key"]! as! String
                                      }
                                      set {
                                        resultMap.updateValue(newValue, forKey: "key")
                                      }
                                    }

                                    public var storeAs: String {
                                      get {
                                        return resultMap["storeAs"]! as! String
                                      }
                                      set {
                                        resultMap.updateValue(newValue, forKey: "storeAs")
                                      }
                                    }

                                    public var type: EmbarkAPIGraphQLVariableGeneratedType {
                                      get {
                                        return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
                                      }
                                      set {
                                        resultMap.updateValue(newValue, forKey: "type")
                                      }
                                    }

                                    public var fragments: Fragments {
                                      get {
                                        return Fragments(unsafeResultMap: resultMap)
                                      }
                                      set {
                                        resultMap += newValue.resultMap
                                      }
                                    }

                                    public struct Fragments {
                                      public private(set) var resultMap: ResultMap

                                      public init(unsafeResultMap: ResultMap) {
                                        self.resultMap = unsafeResultMap
                                      }

                                      public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                                        get {
                                          if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                                          return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                                        }
                                        set {
                                          guard let newValue = newValue else { return }
                                          resultMap += newValue.resultMap
                                        }
                                      }

                                      public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment {
                                        get {
                                          return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                                        }
                                        set {
                                          resultMap += newValue.resultMap
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }

                        public struct MutationResult: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkAPIGraphQLResult"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("key", type: .nonNull(.scalar(String.self))),
                              GraphQLField("as", type: .nonNull(.scalar(String.self))),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(key: String, `as`: String) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLResult", "key": key, "as": `as`])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var key: String {
                            get {
                              return resultMap["key"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "key")
                            }
                          }

                          public var `as`: String {
                            get {
                              return resultMap["as"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "as")
                            }
                          }
                        }

                        public struct MutationError: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkAPIGraphQLError"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("contains", type: .scalar(String.self)),
                              GraphQLField("next", type: .nonNull(.object(Next.selections))),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(contains: String? = nil, next: Next) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLError", "contains": contains, "next": next.resultMap])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var contains: String? {
                            get {
                              return resultMap["contains"] as? String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "contains")
                            }
                          }

                          public var next: Next {
                            get {
                              return Next(unsafeResultMap: resultMap["next"]! as! ResultMap)
                            }
                            set {
                              resultMap.updateValue(newValue.resultMap, forKey: "next")
                            }
                          }

                          public struct Next: GraphQLSelectionSet {
                            public static let possibleTypes: [String] = ["EmbarkLink"]

                            public static var selections: [GraphQLSelection] {
                              return [
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("name", type: .nonNull(.scalar(String.self))),
                                GraphQLField("label", type: .nonNull(.scalar(String.self))),
                              ]
                            }

                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public init(name: String, label: String) {
                              self.init(unsafeResultMap: ["__typename": "EmbarkLink", "name": name, "label": label])
                            }

                            public var __typename: String {
                              get {
                                return resultMap["__typename"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "__typename")
                              }
                            }

                            public var name: String {
                              get {
                                return resultMap["name"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "name")
                              }
                            }

                            public var label: String {
                              get {
                                return resultMap["label"]! as! String
                              }
                              set {
                                resultMap.updateValue(newValue, forKey: "label")
                              }
                            }

                            public var fragments: Fragments {
                              get {
                                return Fragments(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }

                            public struct Fragments {
                              public private(set) var resultMap: ResultMap

                              public init(unsafeResultMap: ResultMap) {
                                self.resultMap = unsafeResultMap
                              }

                              public var embarkLinkFragment: EmbarkLinkFragment {
                                get {
                                  return EmbarkLinkFragment(unsafeResultMap: resultMap)
                                }
                                set {
                                  resultMap += newValue.resultMap
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }

            public var asEmbarkDatePickerAction: AsEmbarkDatePickerAction? {
              get {
                if !AsEmbarkDatePickerAction.possibleTypes.contains(__typename) { return nil }
                return AsEmbarkDatePickerAction(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap = newValue.resultMap
              }
            }

            public struct AsEmbarkDatePickerAction: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkDatePickerAction"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("component", type: .nonNull(.scalar(String.self))),
                  GraphQLField("component", type: .nonNull(.scalar(String.self))),
                  GraphQLField("next", type: .nonNull(.object(Next.selections))),
                  GraphQLField("storeKey", type: .nonNull(.scalar(String.self))),
                  GraphQLField("label", type: .nonNull(.scalar(String.self))),
                  GraphQLField("tooltip", type: .object(Tooltip.selections)),
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public init(component: String, next: Next, storeKey: String, label: String, tooltip: Tooltip? = nil) {
                self.init(unsafeResultMap: ["__typename": "EmbarkDatePickerAction", "component": component, "next": next.resultMap, "storeKey": storeKey, "label": label, "tooltip": tooltip.flatMap { (value: Tooltip) -> ResultMap in value.resultMap }])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var component: String {
                get {
                  return resultMap["component"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "component")
                }
              }

              public var next: Next {
                get {
                  return Next(unsafeResultMap: resultMap["next"]! as! ResultMap)
                }
                set {
                  resultMap.updateValue(newValue.resultMap, forKey: "next")
                }
              }

              public var storeKey: String {
                get {
                  return resultMap["storeKey"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "storeKey")
                }
              }

              public var label: String {
                get {
                  return resultMap["label"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "label")
                }
              }

              public var tooltip: Tooltip? {
                get {
                  return (resultMap["tooltip"] as? ResultMap).flatMap { Tooltip(unsafeResultMap: $0) }
                }
                set {
                  resultMap.updateValue(newValue?.resultMap, forKey: "tooltip")
                }
              }

              public struct Next: GraphQLSelectionSet {
                public static let possibleTypes: [String] = ["EmbarkLink"]

                public static var selections: [GraphQLSelection] {
                  return [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("name", type: .nonNull(.scalar(String.self))),
                    GraphQLField("label", type: .nonNull(.scalar(String.self))),
                  ]
                }

                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public init(name: String, label: String) {
                  self.init(unsafeResultMap: ["__typename": "EmbarkLink", "name": name, "label": label])
                }

                public var __typename: String {
                  get {
                    return resultMap["__typename"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "__typename")
                  }
                }

                public var name: String {
                  get {
                    return resultMap["name"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "name")
                  }
                }

                public var label: String {
                  get {
                    return resultMap["label"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "label")
                  }
                }

                public var fragments: Fragments {
                  get {
                    return Fragments(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }

                public struct Fragments {
                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public var embarkLinkFragment: EmbarkLinkFragment {
                    get {
                      return EmbarkLinkFragment(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }
                }
              }

              public struct Tooltip: GraphQLSelectionSet {
                public static let possibleTypes: [String] = ["EmbarkTooltip"]

                public static var selections: [GraphQLSelection] {
                  return [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("title", type: .nonNull(.scalar(String.self))),
                    GraphQLField("description", type: .nonNull(.scalar(String.self))),
                  ]
                }

                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public init(title: String, description: String) {
                  self.init(unsafeResultMap: ["__typename": "EmbarkTooltip", "title": title, "description": description])
                }

                public var __typename: String {
                  get {
                    return resultMap["__typename"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "__typename")
                  }
                }

                public var title: String {
                  get {
                    return resultMap["title"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "title")
                  }
                }

                public var description: String {
                  get {
                    return resultMap["description"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "description")
                  }
                }
              }
            }

            public var asEmbarkExternalInsuranceProviderAction: AsEmbarkExternalInsuranceProviderAction? {
              get {
                if !AsEmbarkExternalInsuranceProviderAction.possibleTypes.contains(__typename) { return nil }
                return AsEmbarkExternalInsuranceProviderAction(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap = newValue.resultMap
              }
            }

            public struct AsEmbarkExternalInsuranceProviderAction: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkExternalInsuranceProviderAction"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("component", type: .nonNull(.scalar(String.self))),
                  GraphQLField("component", type: .nonNull(.scalar(String.self))),
                  GraphQLField("data", alias: "externalInsuranceProviderData", type: .nonNull(.object(ExternalInsuranceProviderDatum.selections))),
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public init(component: String, externalInsuranceProviderData: ExternalInsuranceProviderDatum) {
                self.init(unsafeResultMap: ["__typename": "EmbarkExternalInsuranceProviderAction", "component": component, "externalInsuranceProviderData": externalInsuranceProviderData.resultMap])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var component: String {
                get {
                  return resultMap["component"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "component")
                }
              }

              public var externalInsuranceProviderData: ExternalInsuranceProviderDatum {
                get {
                  return ExternalInsuranceProviderDatum(unsafeResultMap: resultMap["externalInsuranceProviderData"]! as! ResultMap)
                }
                set {
                  resultMap.updateValue(newValue.resultMap, forKey: "externalInsuranceProviderData")
                }
              }

              public struct ExternalInsuranceProviderDatum: GraphQLSelectionSet {
                public static let possibleTypes: [String] = ["EmbarkExternalInsuranceProviderActionData"]

                public static var selections: [GraphQLSelection] {
                  return [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("storeKey", type: .nonNull(.scalar(String.self))),
                    GraphQLField("next", type: .nonNull(.object(Next.selections))),
                    GraphQLField("skip", type: .nonNull(.object(Skip.selections))),
                  ]
                }

                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public init(storeKey: String, next: Next, skip: Skip) {
                  self.init(unsafeResultMap: ["__typename": "EmbarkExternalInsuranceProviderActionData", "storeKey": storeKey, "next": next.resultMap, "skip": skip.resultMap])
                }

                public var __typename: String {
                  get {
                    return resultMap["__typename"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "__typename")
                  }
                }

                public var storeKey: String {
                  get {
                    return resultMap["storeKey"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "storeKey")
                  }
                }

                public var next: Next {
                  get {
                    return Next(unsafeResultMap: resultMap["next"]! as! ResultMap)
                  }
                  set {
                    resultMap.updateValue(newValue.resultMap, forKey: "next")
                  }
                }

                public var skip: Skip {
                  get {
                    return Skip(unsafeResultMap: resultMap["skip"]! as! ResultMap)
                  }
                  set {
                    resultMap.updateValue(newValue.resultMap, forKey: "skip")
                  }
                }

                public struct Next: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkLink"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("name", type: .nonNull(.scalar(String.self))),
                      GraphQLField("label", type: .nonNull(.scalar(String.self))),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(name: String, label: String) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkLink", "name": name, "label": label])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var name: String {
                    get {
                      return resultMap["name"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "name")
                    }
                  }

                  public var label: String {
                    get {
                      return resultMap["label"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "label")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var embarkLinkFragment: EmbarkLinkFragment {
                      get {
                        return EmbarkLinkFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }
                }

                public struct Skip: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkLink"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("name", type: .nonNull(.scalar(String.self))),
                      GraphQLField("label", type: .nonNull(.scalar(String.self))),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(name: String, label: String) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkLink", "name": name, "label": label])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var name: String {
                    get {
                      return resultMap["name"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "name")
                    }
                  }

                  public var label: String {
                    get {
                      return resultMap["label"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "label")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var embarkLinkFragment: EmbarkLinkFragment {
                      get {
                        return EmbarkLinkFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }
                }
              }
            }

            public var asEmbarkPreviousInsuranceProviderAction: AsEmbarkPreviousInsuranceProviderAction? {
              get {
                if !AsEmbarkPreviousInsuranceProviderAction.possibleTypes.contains(__typename) { return nil }
                return AsEmbarkPreviousInsuranceProviderAction(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap = newValue.resultMap
              }
            }

            public struct AsEmbarkPreviousInsuranceProviderAction: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkPreviousInsuranceProviderAction"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("component", type: .nonNull(.scalar(String.self))),
                  GraphQLField("component", type: .nonNull(.scalar(String.self))),
                  GraphQLField("data", alias: "previousInsuranceProviderData", type: .nonNull(.object(PreviousInsuranceProviderDatum.selections))),
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public init(component: String, previousInsuranceProviderData: PreviousInsuranceProviderDatum) {
                self.init(unsafeResultMap: ["__typename": "EmbarkPreviousInsuranceProviderAction", "component": component, "previousInsuranceProviderData": previousInsuranceProviderData.resultMap])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var component: String {
                get {
                  return resultMap["component"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "component")
                }
              }

              public var previousInsuranceProviderData: PreviousInsuranceProviderDatum {
                get {
                  return PreviousInsuranceProviderDatum(unsafeResultMap: resultMap["previousInsuranceProviderData"]! as! ResultMap)
                }
                set {
                  resultMap.updateValue(newValue.resultMap, forKey: "previousInsuranceProviderData")
                }
              }

              public struct PreviousInsuranceProviderDatum: GraphQLSelectionSet {
                public static let possibleTypes: [String] = ["EmbarkPreviousInsuranceProviderActionData"]

                public static var selections: [GraphQLSelection] {
                  return [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("next", type: .nonNull(.object(Next.selections))),
                    GraphQLField("skip", type: .nonNull(.object(Skip.selections))),
                    GraphQLField("providers", type: .scalar(EmbarkPreviousInsuranceProviderActionDataProviders.self)),
                    GraphQLField("storeKey", type: .nonNull(.scalar(String.self))),
                  ]
                }

                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public init(next: Next, skip: Skip, providers: EmbarkPreviousInsuranceProviderActionDataProviders? = nil, storeKey: String) {
                  self.init(unsafeResultMap: ["__typename": "EmbarkPreviousInsuranceProviderActionData", "next": next.resultMap, "skip": skip.resultMap, "providers": providers, "storeKey": storeKey])
                }

                public var __typename: String {
                  get {
                    return resultMap["__typename"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "__typename")
                  }
                }

                public var next: Next {
                  get {
                    return Next(unsafeResultMap: resultMap["next"]! as! ResultMap)
                  }
                  set {
                    resultMap.updateValue(newValue.resultMap, forKey: "next")
                  }
                }

                public var skip: Skip {
                  get {
                    return Skip(unsafeResultMap: resultMap["skip"]! as! ResultMap)
                  }
                  set {
                    resultMap.updateValue(newValue.resultMap, forKey: "skip")
                  }
                }

                public var providers: EmbarkPreviousInsuranceProviderActionDataProviders? {
                  get {
                    return resultMap["providers"] as? EmbarkPreviousInsuranceProviderActionDataProviders
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "providers")
                  }
                }

                public var storeKey: String {
                  get {
                    return resultMap["storeKey"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "storeKey")
                  }
                }

                public struct Next: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkLink"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("name", type: .nonNull(.scalar(String.self))),
                      GraphQLField("label", type: .nonNull(.scalar(String.self))),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(name: String, label: String) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkLink", "name": name, "label": label])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var name: String {
                    get {
                      return resultMap["name"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "name")
                    }
                  }

                  public var label: String {
                    get {
                      return resultMap["label"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "label")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var embarkLinkFragment: EmbarkLinkFragment {
                      get {
                        return EmbarkLinkFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }
                }

                public struct Skip: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkLink"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("name", type: .nonNull(.scalar(String.self))),
                      GraphQLField("label", type: .nonNull(.scalar(String.self))),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(name: String, label: String) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkLink", "name": name, "label": label])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var name: String {
                    get {
                      return resultMap["name"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "name")
                    }
                  }

                  public var label: String {
                    get {
                      return resultMap["label"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "label")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var embarkLinkFragment: EmbarkLinkFragment {
                      get {
                        return EmbarkLinkFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }
                }
              }
            }

            public var asEmbarkNumberActionSet: AsEmbarkNumberActionSet? {
              get {
                if !AsEmbarkNumberActionSet.possibleTypes.contains(__typename) { return nil }
                return AsEmbarkNumberActionSet(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap = newValue.resultMap
              }
            }

            public struct AsEmbarkNumberActionSet: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkNumberActionSet"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("component", type: .nonNull(.scalar(String.self))),
                  GraphQLField("component", type: .nonNull(.scalar(String.self))),
                  GraphQLField("data", type: .object(Datum.selections)),
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public init(component: String, data: Datum? = nil) {
                self.init(unsafeResultMap: ["__typename": "EmbarkNumberActionSet", "component": component, "data": data.flatMap { (value: Datum) -> ResultMap in value.resultMap }])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var component: String {
                get {
                  return resultMap["component"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "component")
                }
              }

              public var data: Datum? {
                get {
                  return (resultMap["data"] as? ResultMap).flatMap { Datum(unsafeResultMap: $0) }
                }
                set {
                  resultMap.updateValue(newValue?.resultMap, forKey: "data")
                }
              }

              public struct Datum: GraphQLSelectionSet {
                public static let possibleTypes: [String] = ["EmbarkNumberActionSetData"]

                public static var selections: [GraphQLSelection] {
                  return [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("link", type: .nonNull(.object(Link.selections))),
                    GraphQLField("numberActions", type: .nonNull(.list(.nonNull(.object(NumberAction.selections))))),
                  ]
                }

                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public init(link: Link, numberActions: [NumberAction]) {
                  self.init(unsafeResultMap: ["__typename": "EmbarkNumberActionSetData", "link": link.resultMap, "numberActions": numberActions.map { (value: NumberAction) -> ResultMap in value.resultMap }])
                }

                public var __typename: String {
                  get {
                    return resultMap["__typename"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "__typename")
                  }
                }

                public var link: Link {
                  get {
                    return Link(unsafeResultMap: resultMap["link"]! as! ResultMap)
                  }
                  set {
                    resultMap.updateValue(newValue.resultMap, forKey: "link")
                  }
                }

                public var numberActions: [NumberAction] {
                  get {
                    return (resultMap["numberActions"] as! [ResultMap]).map { (value: ResultMap) -> NumberAction in NumberAction(unsafeResultMap: value) }
                  }
                  set {
                    resultMap.updateValue(newValue.map { (value: NumberAction) -> ResultMap in value.resultMap }, forKey: "numberActions")
                  }
                }

                public struct Link: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkLink"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("name", type: .nonNull(.scalar(String.self))),
                      GraphQLField("label", type: .nonNull(.scalar(String.self))),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(name: String, label: String) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkLink", "name": name, "label": label])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var name: String {
                    get {
                      return resultMap["name"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "name")
                    }
                  }

                  public var label: String {
                    get {
                      return resultMap["label"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "label")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var embarkLinkFragment: EmbarkLinkFragment {
                      get {
                        return EmbarkLinkFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }
                }

                public struct NumberAction: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkNumberActionSetNumberAction"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("data", type: .object(Datum.selections)),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(data: Datum? = nil) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkNumberActionSetNumberAction", "data": data.flatMap { (value: Datum) -> ResultMap in value.resultMap }])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var data: Datum? {
                    get {
                      return (resultMap["data"] as? ResultMap).flatMap { Datum(unsafeResultMap: $0) }
                    }
                    set {
                      resultMap.updateValue(newValue?.resultMap, forKey: "data")
                    }
                  }

                  public struct Datum: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkNumberActionSetNumberActionData"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("key", type: .nonNull(.scalar(String.self))),
                        GraphQLField("placeholder", type: .nonNull(.scalar(String.self))),
                        GraphQLField("unit", type: .scalar(String.self)),
                        GraphQLField("label", type: .scalar(String.self)),
                        GraphQLField("maxValue", type: .scalar(Int.self)),
                        GraphQLField("minValue", type: .scalar(Int.self)),
                        GraphQLField("title", type: .nonNull(.scalar(String.self))),
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public init(key: String, placeholder: String, unit: String? = nil, label: String? = nil, maxValue: Int? = nil, minValue: Int? = nil, title: String) {
                      self.init(unsafeResultMap: ["__typename": "EmbarkNumberActionSetNumberActionData", "key": key, "placeholder": placeholder, "unit": unit, "label": label, "maxValue": maxValue, "minValue": minValue, "title": title])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var key: String {
                      get {
                        return resultMap["key"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "key")
                      }
                    }

                    public var placeholder: String {
                      get {
                        return resultMap["placeholder"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "placeholder")
                      }
                    }

                    public var unit: String? {
                      get {
                        return resultMap["unit"] as? String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "unit")
                      }
                    }

                    public var label: String? {
                      get {
                        return resultMap["label"] as? String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "label")
                      }
                    }

                    public var maxValue: Int? {
                      get {
                        return resultMap["maxValue"] as? Int
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "maxValue")
                      }
                    }

                    public var minValue: Int? {
                      get {
                        return resultMap["minValue"] as? Int
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "minValue")
                      }
                    }

                    public var title: String {
                      get {
                        return resultMap["title"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "title")
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  struct EmbarkLinkFragment: GraphQLFragment {
    /// The raw GraphQL definition of this fragment.
    public static let fragmentDefinition: String =
      """
      fragment EmbarkLinkFragment on EmbarkLink {
        __typename
        name
        label
      }
      """

    public static let possibleTypes: [String] = ["EmbarkLink"]

    public static var selections: [GraphQLSelection] {
      return [
        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
        GraphQLField("name", type: .nonNull(.scalar(String.self))),
        GraphQLField("label", type: .nonNull(.scalar(String.self))),
      ]
    }

    public private(set) var resultMap: ResultMap

    public init(unsafeResultMap: ResultMap) {
      self.resultMap = unsafeResultMap
    }

    public init(name: String, label: String) {
      self.init(unsafeResultMap: ["__typename": "EmbarkLink", "name": name, "label": label])
    }

    public var __typename: String {
      get {
        return resultMap["__typename"]! as! String
      }
      set {
        resultMap.updateValue(newValue, forKey: "__typename")
      }
    }

    public var name: String {
      get {
        return resultMap["name"]! as! String
      }
      set {
        resultMap.updateValue(newValue, forKey: "name")
      }
    }

    public var label: String {
      get {
        return resultMap["label"]! as! String
      }
      set {
        resultMap.updateValue(newValue, forKey: "label")
      }
    }
  }

  struct MessageFragment: GraphQLFragment {
    /// The raw GraphQL definition of this fragment.
    public static let fragmentDefinition: String =
      """
      fragment MessageFragment on EmbarkMessage {
        __typename
        text
        expressions {
          __typename
          ...ExpressionFragment
        }
      }
      """

    public static let possibleTypes: [String] = ["EmbarkMessage"]

    public static var selections: [GraphQLSelection] {
      return [
        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
        GraphQLField("text", type: .nonNull(.scalar(String.self))),
        GraphQLField("expressions", type: .nonNull(.list(.nonNull(.object(Expression.selections))))),
      ]
    }

    public private(set) var resultMap: ResultMap

    public init(unsafeResultMap: ResultMap) {
      self.resultMap = unsafeResultMap
    }

    public init(text: String, expressions: [Expression]) {
      self.init(unsafeResultMap: ["__typename": "EmbarkMessage", "text": text, "expressions": expressions.map { (value: Expression) -> ResultMap in value.resultMap }])
    }

    public var __typename: String {
      get {
        return resultMap["__typename"]! as! String
      }
      set {
        resultMap.updateValue(newValue, forKey: "__typename")
      }
    }

    public var text: String {
      get {
        return resultMap["text"]! as! String
      }
      set {
        resultMap.updateValue(newValue, forKey: "text")
      }
    }

    public var expressions: [Expression] {
      get {
        return (resultMap["expressions"] as! [ResultMap]).map { (value: ResultMap) -> Expression in Expression(unsafeResultMap: value) }
      }
      set {
        resultMap.updateValue(newValue.map { (value: Expression) -> ResultMap in value.resultMap }, forKey: "expressions")
      }
    }

    public struct Expression: GraphQLSelectionSet {
      public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

      public static var selections: [GraphQLSelection] {
        return [
          GraphQLTypeCase(
            variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
            default: [
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
            ]
          )
        ]
      }

      public private(set) var resultMap: ResultMap

      public init(unsafeResultMap: ResultMap) {
        self.resultMap = unsafeResultMap
      }

      public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> Expression {
        return Expression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
      }

      public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> Expression {
        return Expression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
      }

      public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> Expression {
        return Expression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
      }

      public var __typename: String {
        get {
          return resultMap["__typename"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "__typename")
        }
      }

      public var fragments: Fragments {
        get {
          return Fragments(unsafeResultMap: resultMap)
        }
        set {
          resultMap += newValue.resultMap
        }
      }

      public struct Fragments {
        public private(set) var resultMap: ResultMap

        public init(unsafeResultMap: ResultMap) {
          self.resultMap = unsafeResultMap
        }

        public var expressionFragment: ExpressionFragment {
          get {
            return ExpressionFragment(unsafeResultMap: resultMap)
          }
          set {
            resultMap += newValue.resultMap
          }
        }

        public var basicExpressionFragment: BasicExpressionFragment {
          get {
            return BasicExpressionFragment(unsafeResultMap: resultMap)
          }
          set {
            resultMap += newValue.resultMap
          }
        }
      }

      public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
        get {
          if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
          return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
        }
        set {
          guard let newValue = newValue else { return }
          resultMap = newValue.resultMap
        }
      }

      public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
        public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

        public static var selections: [GraphQLSelection] {
          return [
            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
            GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
            GraphQLField("text", type: .scalar(String.self)),
          ]
        }

        public private(set) var resultMap: ResultMap

        public init(unsafeResultMap: ResultMap) {
          self.resultMap = unsafeResultMap
        }

        public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
          self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
        }

        public var __typename: String {
          get {
            return resultMap["__typename"]! as! String
          }
          set {
            resultMap.updateValue(newValue, forKey: "__typename")
          }
        }

        public var expressionUnaryType: EmbarkExpressionTypeUnary {
          get {
            return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
          }
          set {
            resultMap.updateValue(newValue, forKey: "expressionUnaryType")
          }
        }

        public var text: String? {
          get {
            return resultMap["text"] as? String
          }
          set {
            resultMap.updateValue(newValue, forKey: "text")
          }
        }

        public var fragments: Fragments {
          get {
            return Fragments(unsafeResultMap: resultMap)
          }
          set {
            resultMap += newValue.resultMap
          }
        }

        public struct Fragments {
          public private(set) var resultMap: ResultMap

          public init(unsafeResultMap: ResultMap) {
            self.resultMap = unsafeResultMap
          }

          public var expressionFragment: ExpressionFragment {
            get {
              return ExpressionFragment(unsafeResultMap: resultMap)
            }
            set {
              resultMap += newValue.resultMap
            }
          }

          public var basicExpressionFragment: BasicExpressionFragment {
            get {
              return BasicExpressionFragment(unsafeResultMap: resultMap)
            }
            set {
              resultMap += newValue.resultMap
            }
          }
        }
      }

      public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
        get {
          if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
          return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
        }
        set {
          guard let newValue = newValue else { return }
          resultMap = newValue.resultMap
        }
      }

      public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
        public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

        public static var selections: [GraphQLSelection] {
          return [
            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
            GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
            GraphQLField("key", type: .nonNull(.scalar(String.self))),
            GraphQLField("value", type: .nonNull(.scalar(String.self))),
            GraphQLField("text", type: .scalar(String.self)),
          ]
        }

        public private(set) var resultMap: ResultMap

        public init(unsafeResultMap: ResultMap) {
          self.resultMap = unsafeResultMap
        }

        public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
          self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
        }

        public var __typename: String {
          get {
            return resultMap["__typename"]! as! String
          }
          set {
            resultMap.updateValue(newValue, forKey: "__typename")
          }
        }

        public var expressionBinaryType: EmbarkExpressionTypeBinary {
          get {
            return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
          }
          set {
            resultMap.updateValue(newValue, forKey: "expressionBinaryType")
          }
        }

        public var key: String {
          get {
            return resultMap["key"]! as! String
          }
          set {
            resultMap.updateValue(newValue, forKey: "key")
          }
        }

        public var value: String {
          get {
            return resultMap["value"]! as! String
          }
          set {
            resultMap.updateValue(newValue, forKey: "value")
          }
        }

        public var text: String? {
          get {
            return resultMap["text"] as? String
          }
          set {
            resultMap.updateValue(newValue, forKey: "text")
          }
        }

        public var fragments: Fragments {
          get {
            return Fragments(unsafeResultMap: resultMap)
          }
          set {
            resultMap += newValue.resultMap
          }
        }

        public struct Fragments {
          public private(set) var resultMap: ResultMap

          public init(unsafeResultMap: ResultMap) {
            self.resultMap = unsafeResultMap
          }

          public var expressionFragment: ExpressionFragment {
            get {
              return ExpressionFragment(unsafeResultMap: resultMap)
            }
            set {
              resultMap += newValue.resultMap
            }
          }

          public var basicExpressionFragment: BasicExpressionFragment {
            get {
              return BasicExpressionFragment(unsafeResultMap: resultMap)
            }
            set {
              resultMap += newValue.resultMap
            }
          }
        }
      }

      public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
        get {
          if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
          return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
        }
        set {
          guard let newValue = newValue else { return }
          resultMap = newValue.resultMap
        }
      }

      public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
        public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

        public static var selections: [GraphQLSelection] {
          return [
            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
            GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
            GraphQLField("text", type: .scalar(String.self)),
            GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
          ]
        }

        public private(set) var resultMap: ResultMap

        public init(unsafeResultMap: ResultMap) {
          self.resultMap = unsafeResultMap
        }

        public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
          self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
        }

        public var __typename: String {
          get {
            return resultMap["__typename"]! as! String
          }
          set {
            resultMap.updateValue(newValue, forKey: "__typename")
          }
        }

        public var expressionMultipleType: EmbarkExpressionTypeMultiple {
          get {
            return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
          }
          set {
            resultMap.updateValue(newValue, forKey: "expressionMultipleType")
          }
        }

        public var text: String? {
          get {
            return resultMap["text"] as? String
          }
          set {
            resultMap.updateValue(newValue, forKey: "text")
          }
        }

        public var subExpressions: [SubExpression] {
          get {
            return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
          }
          set {
            resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
          }
        }

        public var fragments: Fragments {
          get {
            return Fragments(unsafeResultMap: resultMap)
          }
          set {
            resultMap += newValue.resultMap
          }
        }

        public struct Fragments {
          public private(set) var resultMap: ResultMap

          public init(unsafeResultMap: ResultMap) {
            self.resultMap = unsafeResultMap
          }

          public var expressionFragment: ExpressionFragment {
            get {
              return ExpressionFragment(unsafeResultMap: resultMap)
            }
            set {
              resultMap += newValue.resultMap
            }
          }

          public var basicExpressionFragment: BasicExpressionFragment {
            get {
              return BasicExpressionFragment(unsafeResultMap: resultMap)
            }
            set {
              resultMap += newValue.resultMap
            }
          }
        }

        public struct SubExpression: GraphQLSelectionSet {
          public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

          public static var selections: [GraphQLSelection] {
            return [
              GraphQLTypeCase(
                variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
                default: [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                ]
              )
            ]
          }

          public private(set) var resultMap: ResultMap

          public init(unsafeResultMap: ResultMap) {
            self.resultMap = unsafeResultMap
          }

          public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
            return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
          }

          public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
            return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
          }

          public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> SubExpression {
            return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
          }

          public var __typename: String {
            get {
              return resultMap["__typename"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "__typename")
            }
          }

          public var fragments: Fragments {
            get {
              return Fragments(unsafeResultMap: resultMap)
            }
            set {
              resultMap += newValue.resultMap
            }
          }

          public struct Fragments {
            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public var basicExpressionFragment: BasicExpressionFragment {
              get {
                return BasicExpressionFragment(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }
          }

          public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
            get {
              if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
              return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
            }
            set {
              guard let newValue = newValue else { return }
              resultMap = newValue.resultMap
            }
          }

          public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
            public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

            public static var selections: [GraphQLSelection] {
              return [
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                GraphQLField("text", type: .scalar(String.self)),
              ]
            }

            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
              self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
            }

            public var __typename: String {
              get {
                return resultMap["__typename"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "__typename")
              }
            }

            public var expressionUnaryType: EmbarkExpressionTypeUnary {
              get {
                return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
              }
              set {
                resultMap.updateValue(newValue, forKey: "expressionUnaryType")
              }
            }

            public var text: String? {
              get {
                return resultMap["text"] as? String
              }
              set {
                resultMap.updateValue(newValue, forKey: "text")
              }
            }

            public var fragments: Fragments {
              get {
                return Fragments(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }

            public struct Fragments {
              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public var basicExpressionFragment: BasicExpressionFragment {
                get {
                  return BasicExpressionFragment(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }
            }
          }

          public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
            get {
              if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
              return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
            }
            set {
              guard let newValue = newValue else { return }
              resultMap = newValue.resultMap
            }
          }

          public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
            public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

            public static var selections: [GraphQLSelection] {
              return [
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                GraphQLField("key", type: .nonNull(.scalar(String.self))),
                GraphQLField("value", type: .nonNull(.scalar(String.self))),
                GraphQLField("text", type: .scalar(String.self)),
              ]
            }

            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
              self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
            }

            public var __typename: String {
              get {
                return resultMap["__typename"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "__typename")
              }
            }

            public var expressionBinaryType: EmbarkExpressionTypeBinary {
              get {
                return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
              }
              set {
                resultMap.updateValue(newValue, forKey: "expressionBinaryType")
              }
            }

            public var key: String {
              get {
                return resultMap["key"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "key")
              }
            }

            public var value: String {
              get {
                return resultMap["value"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "value")
              }
            }

            public var text: String? {
              get {
                return resultMap["text"] as? String
              }
              set {
                resultMap.updateValue(newValue, forKey: "text")
              }
            }

            public var fragments: Fragments {
              get {
                return Fragments(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }

            public struct Fragments {
              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public var basicExpressionFragment: BasicExpressionFragment {
                get {
                  return BasicExpressionFragment(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }
            }
          }

          public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
            get {
              if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
              return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
            }
            set {
              guard let newValue = newValue else { return }
              resultMap = newValue.resultMap
            }
          }

          public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
            public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

            public static var selections: [GraphQLSelection] {
              return [
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
                GraphQLField("text", type: .scalar(String.self)),
                GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
              ]
            }

            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
              self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
            }

            public var __typename: String {
              get {
                return resultMap["__typename"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "__typename")
              }
            }

            public var expressionMultipleType: EmbarkExpressionTypeMultiple {
              get {
                return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
              }
              set {
                resultMap.updateValue(newValue, forKey: "expressionMultipleType")
              }
            }

            public var text: String? {
              get {
                return resultMap["text"] as? String
              }
              set {
                resultMap.updateValue(newValue, forKey: "text")
              }
            }

            public var subExpressions: [SubExpression] {
              get {
                return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
              }
              set {
                resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
              }
            }

            public var fragments: Fragments {
              get {
                return Fragments(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }

            public struct Fragments {
              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public var basicExpressionFragment: BasicExpressionFragment {
                get {
                  return BasicExpressionFragment(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }
            }

            public struct SubExpression: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLTypeCase(
                    variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
                    default: [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    ]
                  )
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
                return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
              }

              public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
                return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
              }

              public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> SubExpression {
                return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var fragments: Fragments {
                get {
                  return Fragments(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public struct Fragments {
                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public var basicExpressionFragment: BasicExpressionFragment {
                  get {
                    return BasicExpressionFragment(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }
              }

              public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                get {
                  if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                  return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                }
                set {
                  guard let newValue = newValue else { return }
                  resultMap = newValue.resultMap
                }
              }

              public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                public static var selections: [GraphQLSelection] {
                  return [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                    GraphQLField("text", type: .scalar(String.self)),
                  ]
                }

                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                  self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                }

                public var __typename: String {
                  get {
                    return resultMap["__typename"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "__typename")
                  }
                }

                public var expressionUnaryType: EmbarkExpressionTypeUnary {
                  get {
                    return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                  }
                }

                public var text: String? {
                  get {
                    return resultMap["text"] as? String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "text")
                  }
                }

                public var fragments: Fragments {
                  get {
                    return Fragments(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }

                public struct Fragments {
                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public var basicExpressionFragment: BasicExpressionFragment {
                    get {
                      return BasicExpressionFragment(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }
                }
              }

              public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                get {
                  if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                  return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                }
                set {
                  guard let newValue = newValue else { return }
                  resultMap = newValue.resultMap
                }
              }

              public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                public static var selections: [GraphQLSelection] {
                  return [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                    GraphQLField("key", type: .nonNull(.scalar(String.self))),
                    GraphQLField("value", type: .nonNull(.scalar(String.self))),
                    GraphQLField("text", type: .scalar(String.self)),
                  ]
                }

                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                  self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                }

                public var __typename: String {
                  get {
                    return resultMap["__typename"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "__typename")
                  }
                }

                public var expressionBinaryType: EmbarkExpressionTypeBinary {
                  get {
                    return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                  }
                }

                public var key: String {
                  get {
                    return resultMap["key"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "key")
                  }
                }

                public var value: String {
                  get {
                    return resultMap["value"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "value")
                  }
                }

                public var text: String? {
                  get {
                    return resultMap["text"] as? String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "text")
                  }
                }

                public var fragments: Fragments {
                  get {
                    return Fragments(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }

                public struct Fragments {
                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public var basicExpressionFragment: BasicExpressionFragment {
                    get {
                      return BasicExpressionFragment(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }
                }
              }

              public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
                get {
                  if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
                  return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
                }
                set {
                  guard let newValue = newValue else { return }
                  resultMap = newValue.resultMap
                }
              }

              public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
                public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

                public static var selections: [GraphQLSelection] {
                  return [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
                    GraphQLField("text", type: .scalar(String.self)),
                    GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
                  ]
                }

                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
                  self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
                }

                public var __typename: String {
                  get {
                    return resultMap["__typename"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "__typename")
                  }
                }

                public var expressionMultipleType: EmbarkExpressionTypeMultiple {
                  get {
                    return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "expressionMultipleType")
                  }
                }

                public var text: String? {
                  get {
                    return resultMap["text"] as? String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "text")
                  }
                }

                public var subExpressions: [SubExpression] {
                  get {
                    return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
                  }
                  set {
                    resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
                  }
                }

                public var fragments: Fragments {
                  get {
                    return Fragments(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }

                public struct Fragments {
                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public var basicExpressionFragment: BasicExpressionFragment {
                    get {
                      return BasicExpressionFragment(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }
                }

                public struct SubExpression: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLTypeCase(
                        variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections],
                        default: [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        ]
                      )
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public static func makeEmbarkExpressionMultiple() -> SubExpression {
                    return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple"])
                  }

                  public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
                    return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                  }

                  public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
                    return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var basicExpressionFragment: BasicExpressionFragment {
                      get {
                        return BasicExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }

                  public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                    get {
                      if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                      return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                    }
                    set {
                      guard let newValue = newValue else { return }
                      resultMap = newValue.resultMap
                    }
                  }

                  public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                        GraphQLField("text", type: .scalar(String.self)),
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                      self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var expressionUnaryType: EmbarkExpressionTypeUnary {
                      get {
                        return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                      }
                    }

                    public var text: String? {
                      get {
                        return resultMap["text"] as? String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "text")
                      }
                    }

                    public var fragments: Fragments {
                      get {
                        return Fragments(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public struct Fragments {
                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public var basicExpressionFragment: BasicExpressionFragment {
                        get {
                          return BasicExpressionFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }
                    }
                  }

                  public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                    get {
                      if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                      return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                    }
                    set {
                      guard let newValue = newValue else { return }
                      resultMap = newValue.resultMap
                    }
                  }

                  public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                        GraphQLField("key", type: .nonNull(.scalar(String.self))),
                        GraphQLField("value", type: .nonNull(.scalar(String.self))),
                        GraphQLField("text", type: .scalar(String.self)),
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                      self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var expressionBinaryType: EmbarkExpressionTypeBinary {
                      get {
                        return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                      }
                    }

                    public var key: String {
                      get {
                        return resultMap["key"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "key")
                      }
                    }

                    public var value: String {
                      get {
                        return resultMap["value"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "value")
                      }
                    }

                    public var text: String? {
                      get {
                        return resultMap["text"] as? String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "text")
                      }
                    }

                    public var fragments: Fragments {
                      get {
                        return Fragments(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public struct Fragments {
                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public var basicExpressionFragment: BasicExpressionFragment {
                        get {
                          return BasicExpressionFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  struct BasicExpressionFragment: GraphQLFragment {
    /// The raw GraphQL definition of this fragment.
    public static let fragmentDefinition: String =
      """
      fragment BasicExpressionFragment on EmbarkExpression {
        __typename
        ... on EmbarkExpressionUnary {
          expressionUnaryType: type
          text
        }
        ... on EmbarkExpressionBinary {
          expressionBinaryType: type
          key
          value
          text
        }
      }
      """

    public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

    public static var selections: [GraphQLSelection] {
      return [
        GraphQLTypeCase(
          variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections],
          default: [
            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
          ]
        )
      ]
    }

    public private(set) var resultMap: ResultMap

    public init(unsafeResultMap: ResultMap) {
      self.resultMap = unsafeResultMap
    }

    public static func makeEmbarkExpressionMultiple() -> BasicExpressionFragment {
      return BasicExpressionFragment(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple"])
    }

    public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> BasicExpressionFragment {
      return BasicExpressionFragment(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
    }

    public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> BasicExpressionFragment {
      return BasicExpressionFragment(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
    }

    public var __typename: String {
      get {
        return resultMap["__typename"]! as! String
      }
      set {
        resultMap.updateValue(newValue, forKey: "__typename")
      }
    }

    public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
      get {
        if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
        return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
      }
      set {
        guard let newValue = newValue else { return }
        resultMap = newValue.resultMap
      }
    }

    public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
      public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

      public static var selections: [GraphQLSelection] {
        return [
          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
          GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
          GraphQLField("text", type: .scalar(String.self)),
        ]
      }

      public private(set) var resultMap: ResultMap

      public init(unsafeResultMap: ResultMap) {
        self.resultMap = unsafeResultMap
      }

      public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
        self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
      }

      public var __typename: String {
        get {
          return resultMap["__typename"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "__typename")
        }
      }

      public var expressionUnaryType: EmbarkExpressionTypeUnary {
        get {
          return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
        }
        set {
          resultMap.updateValue(newValue, forKey: "expressionUnaryType")
        }
      }

      public var text: String? {
        get {
          return resultMap["text"] as? String
        }
        set {
          resultMap.updateValue(newValue, forKey: "text")
        }
      }
    }

    public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
      get {
        if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
        return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
      }
      set {
        guard let newValue = newValue else { return }
        resultMap = newValue.resultMap
      }
    }

    public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
      public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

      public static var selections: [GraphQLSelection] {
        return [
          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
          GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
          GraphQLField("key", type: .nonNull(.scalar(String.self))),
          GraphQLField("value", type: .nonNull(.scalar(String.self))),
          GraphQLField("text", type: .scalar(String.self)),
        ]
      }

      public private(set) var resultMap: ResultMap

      public init(unsafeResultMap: ResultMap) {
        self.resultMap = unsafeResultMap
      }

      public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
        self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
      }

      public var __typename: String {
        get {
          return resultMap["__typename"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "__typename")
        }
      }

      public var expressionBinaryType: EmbarkExpressionTypeBinary {
        get {
          return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
        }
        set {
          resultMap.updateValue(newValue, forKey: "expressionBinaryType")
        }
      }

      public var key: String {
        get {
          return resultMap["key"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "key")
        }
      }

      public var value: String {
        get {
          return resultMap["value"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "value")
        }
      }

      public var text: String? {
        get {
          return resultMap["text"] as? String
        }
        set {
          resultMap.updateValue(newValue, forKey: "text")
        }
      }
    }
  }

  struct ExpressionFragment: GraphQLFragment {
    /// The raw GraphQL definition of this fragment.
    public static let fragmentDefinition: String =
      """
      fragment ExpressionFragment on EmbarkExpression {
        __typename
        ...BasicExpressionFragment
        ... on EmbarkExpressionMultiple {
          expressionMultipleType: type
          text
          subExpressions {
            __typename
            ...BasicExpressionFragment
            ... on EmbarkExpressionMultiple {
              expressionMultipleType: type
              text
              subExpressions {
                __typename
                ...BasicExpressionFragment
                ... on EmbarkExpressionMultiple {
                  expressionMultipleType: type
                  text
                  subExpressions {
                    __typename
                    ...BasicExpressionFragment
                  }
                }
              }
            }
          }
        }
      }
      """

    public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

    public static var selections: [GraphQLSelection] {
      return [
        GraphQLTypeCase(
          variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
          default: [
            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
          ]
        )
      ]
    }

    public private(set) var resultMap: ResultMap

    public init(unsafeResultMap: ResultMap) {
      self.resultMap = unsafeResultMap
    }

    public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> ExpressionFragment {
      return ExpressionFragment(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
    }

    public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> ExpressionFragment {
      return ExpressionFragment(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
    }

    public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> ExpressionFragment {
      return ExpressionFragment(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
    }

    public var __typename: String {
      get {
        return resultMap["__typename"]! as! String
      }
      set {
        resultMap.updateValue(newValue, forKey: "__typename")
      }
    }

    public var fragments: Fragments {
      get {
        return Fragments(unsafeResultMap: resultMap)
      }
      set {
        resultMap += newValue.resultMap
      }
    }

    public struct Fragments {
      public private(set) var resultMap: ResultMap

      public init(unsafeResultMap: ResultMap) {
        self.resultMap = unsafeResultMap
      }

      public var basicExpressionFragment: BasicExpressionFragment {
        get {
          return BasicExpressionFragment(unsafeResultMap: resultMap)
        }
        set {
          resultMap += newValue.resultMap
        }
      }
    }

    public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
      get {
        if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
        return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
      }
      set {
        guard let newValue = newValue else { return }
        resultMap = newValue.resultMap
      }
    }

    public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
      public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

      public static var selections: [GraphQLSelection] {
        return [
          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
          GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
          GraphQLField("text", type: .scalar(String.self)),
        ]
      }

      public private(set) var resultMap: ResultMap

      public init(unsafeResultMap: ResultMap) {
        self.resultMap = unsafeResultMap
      }

      public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
        self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
      }

      public var __typename: String {
        get {
          return resultMap["__typename"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "__typename")
        }
      }

      public var expressionUnaryType: EmbarkExpressionTypeUnary {
        get {
          return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
        }
        set {
          resultMap.updateValue(newValue, forKey: "expressionUnaryType")
        }
      }

      public var text: String? {
        get {
          return resultMap["text"] as? String
        }
        set {
          resultMap.updateValue(newValue, forKey: "text")
        }
      }

      public var fragments: Fragments {
        get {
          return Fragments(unsafeResultMap: resultMap)
        }
        set {
          resultMap += newValue.resultMap
        }
      }

      public struct Fragments {
        public private(set) var resultMap: ResultMap

        public init(unsafeResultMap: ResultMap) {
          self.resultMap = unsafeResultMap
        }

        public var basicExpressionFragment: BasicExpressionFragment {
          get {
            return BasicExpressionFragment(unsafeResultMap: resultMap)
          }
          set {
            resultMap += newValue.resultMap
          }
        }
      }
    }

    public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
      get {
        if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
        return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
      }
      set {
        guard let newValue = newValue else { return }
        resultMap = newValue.resultMap
      }
    }

    public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
      public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

      public static var selections: [GraphQLSelection] {
        return [
          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
          GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
          GraphQLField("key", type: .nonNull(.scalar(String.self))),
          GraphQLField("value", type: .nonNull(.scalar(String.self))),
          GraphQLField("text", type: .scalar(String.self)),
        ]
      }

      public private(set) var resultMap: ResultMap

      public init(unsafeResultMap: ResultMap) {
        self.resultMap = unsafeResultMap
      }

      public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
        self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
      }

      public var __typename: String {
        get {
          return resultMap["__typename"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "__typename")
        }
      }

      public var expressionBinaryType: EmbarkExpressionTypeBinary {
        get {
          return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
        }
        set {
          resultMap.updateValue(newValue, forKey: "expressionBinaryType")
        }
      }

      public var key: String {
        get {
          return resultMap["key"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "key")
        }
      }

      public var value: String {
        get {
          return resultMap["value"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "value")
        }
      }

      public var text: String? {
        get {
          return resultMap["text"] as? String
        }
        set {
          resultMap.updateValue(newValue, forKey: "text")
        }
      }

      public var fragments: Fragments {
        get {
          return Fragments(unsafeResultMap: resultMap)
        }
        set {
          resultMap += newValue.resultMap
        }
      }

      public struct Fragments {
        public private(set) var resultMap: ResultMap

        public init(unsafeResultMap: ResultMap) {
          self.resultMap = unsafeResultMap
        }

        public var basicExpressionFragment: BasicExpressionFragment {
          get {
            return BasicExpressionFragment(unsafeResultMap: resultMap)
          }
          set {
            resultMap += newValue.resultMap
          }
        }
      }
    }

    public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
      get {
        if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
        return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
      }
      set {
        guard let newValue = newValue else { return }
        resultMap = newValue.resultMap
      }
    }

    public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
      public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

      public static var selections: [GraphQLSelection] {
        return [
          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
          GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
          GraphQLField("text", type: .scalar(String.self)),
          GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
        ]
      }

      public private(set) var resultMap: ResultMap

      public init(unsafeResultMap: ResultMap) {
        self.resultMap = unsafeResultMap
      }

      public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
        self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
      }

      public var __typename: String {
        get {
          return resultMap["__typename"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "__typename")
        }
      }

      public var expressionMultipleType: EmbarkExpressionTypeMultiple {
        get {
          return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
        }
        set {
          resultMap.updateValue(newValue, forKey: "expressionMultipleType")
        }
      }

      public var text: String? {
        get {
          return resultMap["text"] as? String
        }
        set {
          resultMap.updateValue(newValue, forKey: "text")
        }
      }

      public var subExpressions: [SubExpression] {
        get {
          return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
        }
        set {
          resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
        }
      }

      public var fragments: Fragments {
        get {
          return Fragments(unsafeResultMap: resultMap)
        }
        set {
          resultMap += newValue.resultMap
        }
      }

      public struct Fragments {
        public private(set) var resultMap: ResultMap

        public init(unsafeResultMap: ResultMap) {
          self.resultMap = unsafeResultMap
        }

        public var basicExpressionFragment: BasicExpressionFragment {
          get {
            return BasicExpressionFragment(unsafeResultMap: resultMap)
          }
          set {
            resultMap += newValue.resultMap
          }
        }
      }

      public struct SubExpression: GraphQLSelectionSet {
        public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

        public static var selections: [GraphQLSelection] {
          return [
            GraphQLTypeCase(
              variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
              default: [
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              ]
            )
          ]
        }

        public private(set) var resultMap: ResultMap

        public init(unsafeResultMap: ResultMap) {
          self.resultMap = unsafeResultMap
        }

        public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
          return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
        }

        public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
          return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
        }

        public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> SubExpression {
          return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
        }

        public var __typename: String {
          get {
            return resultMap["__typename"]! as! String
          }
          set {
            resultMap.updateValue(newValue, forKey: "__typename")
          }
        }

        public var fragments: Fragments {
          get {
            return Fragments(unsafeResultMap: resultMap)
          }
          set {
            resultMap += newValue.resultMap
          }
        }

        public struct Fragments {
          public private(set) var resultMap: ResultMap

          public init(unsafeResultMap: ResultMap) {
            self.resultMap = unsafeResultMap
          }

          public var basicExpressionFragment: BasicExpressionFragment {
            get {
              return BasicExpressionFragment(unsafeResultMap: resultMap)
            }
            set {
              resultMap += newValue.resultMap
            }
          }
        }

        public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
          get {
            if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
            return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
          }
          set {
            guard let newValue = newValue else { return }
            resultMap = newValue.resultMap
          }
        }

        public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
          public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

          public static var selections: [GraphQLSelection] {
            return [
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
              GraphQLField("text", type: .scalar(String.self)),
            ]
          }

          public private(set) var resultMap: ResultMap

          public init(unsafeResultMap: ResultMap) {
            self.resultMap = unsafeResultMap
          }

          public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
            self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
          }

          public var __typename: String {
            get {
              return resultMap["__typename"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "__typename")
            }
          }

          public var expressionUnaryType: EmbarkExpressionTypeUnary {
            get {
              return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
            }
            set {
              resultMap.updateValue(newValue, forKey: "expressionUnaryType")
            }
          }

          public var text: String? {
            get {
              return resultMap["text"] as? String
            }
            set {
              resultMap.updateValue(newValue, forKey: "text")
            }
          }

          public var fragments: Fragments {
            get {
              return Fragments(unsafeResultMap: resultMap)
            }
            set {
              resultMap += newValue.resultMap
            }
          }

          public struct Fragments {
            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public var basicExpressionFragment: BasicExpressionFragment {
              get {
                return BasicExpressionFragment(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }
          }
        }

        public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
          get {
            if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
            return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
          }
          set {
            guard let newValue = newValue else { return }
            resultMap = newValue.resultMap
          }
        }

        public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
          public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

          public static var selections: [GraphQLSelection] {
            return [
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
              GraphQLField("key", type: .nonNull(.scalar(String.self))),
              GraphQLField("value", type: .nonNull(.scalar(String.self))),
              GraphQLField("text", type: .scalar(String.self)),
            ]
          }

          public private(set) var resultMap: ResultMap

          public init(unsafeResultMap: ResultMap) {
            self.resultMap = unsafeResultMap
          }

          public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
            self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
          }

          public var __typename: String {
            get {
              return resultMap["__typename"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "__typename")
            }
          }

          public var expressionBinaryType: EmbarkExpressionTypeBinary {
            get {
              return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
            }
            set {
              resultMap.updateValue(newValue, forKey: "expressionBinaryType")
            }
          }

          public var key: String {
            get {
              return resultMap["key"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "key")
            }
          }

          public var value: String {
            get {
              return resultMap["value"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "value")
            }
          }

          public var text: String? {
            get {
              return resultMap["text"] as? String
            }
            set {
              resultMap.updateValue(newValue, forKey: "text")
            }
          }

          public var fragments: Fragments {
            get {
              return Fragments(unsafeResultMap: resultMap)
            }
            set {
              resultMap += newValue.resultMap
            }
          }

          public struct Fragments {
            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public var basicExpressionFragment: BasicExpressionFragment {
              get {
                return BasicExpressionFragment(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }
          }
        }

        public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
          get {
            if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
            return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
          }
          set {
            guard let newValue = newValue else { return }
            resultMap = newValue.resultMap
          }
        }

        public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
          public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

          public static var selections: [GraphQLSelection] {
            return [
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
              GraphQLField("text", type: .scalar(String.self)),
              GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
            ]
          }

          public private(set) var resultMap: ResultMap

          public init(unsafeResultMap: ResultMap) {
            self.resultMap = unsafeResultMap
          }

          public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
            self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
          }

          public var __typename: String {
            get {
              return resultMap["__typename"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "__typename")
            }
          }

          public var expressionMultipleType: EmbarkExpressionTypeMultiple {
            get {
              return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
            }
            set {
              resultMap.updateValue(newValue, forKey: "expressionMultipleType")
            }
          }

          public var text: String? {
            get {
              return resultMap["text"] as? String
            }
            set {
              resultMap.updateValue(newValue, forKey: "text")
            }
          }

          public var subExpressions: [SubExpression] {
            get {
              return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
            }
            set {
              resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
            }
          }

          public var fragments: Fragments {
            get {
              return Fragments(unsafeResultMap: resultMap)
            }
            set {
              resultMap += newValue.resultMap
            }
          }

          public struct Fragments {
            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public var basicExpressionFragment: BasicExpressionFragment {
              get {
                return BasicExpressionFragment(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }
          }

          public struct SubExpression: GraphQLSelectionSet {
            public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

            public static var selections: [GraphQLSelection] {
              return [
                GraphQLTypeCase(
                  variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
                  default: [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  ]
                )
              ]
            }

            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
              return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
            }

            public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
              return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
            }

            public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> SubExpression {
              return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
            }

            public var __typename: String {
              get {
                return resultMap["__typename"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "__typename")
              }
            }

            public var fragments: Fragments {
              get {
                return Fragments(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }

            public struct Fragments {
              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public var basicExpressionFragment: BasicExpressionFragment {
                get {
                  return BasicExpressionFragment(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }
            }

            public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
              get {
                if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap = newValue.resultMap
              }
            }

            public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                  GraphQLField("text", type: .scalar(String.self)),
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var expressionUnaryType: EmbarkExpressionTypeUnary {
                get {
                  return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                }
                set {
                  resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                }
              }

              public var text: String? {
                get {
                  return resultMap["text"] as? String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "text")
                }
              }

              public var fragments: Fragments {
                get {
                  return Fragments(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public struct Fragments {
                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public var basicExpressionFragment: BasicExpressionFragment {
                  get {
                    return BasicExpressionFragment(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }
              }
            }

            public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
              get {
                if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap = newValue.resultMap
              }
            }

            public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                  GraphQLField("key", type: .nonNull(.scalar(String.self))),
                  GraphQLField("value", type: .nonNull(.scalar(String.self))),
                  GraphQLField("text", type: .scalar(String.self)),
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var expressionBinaryType: EmbarkExpressionTypeBinary {
                get {
                  return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                }
                set {
                  resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                }
              }

              public var key: String {
                get {
                  return resultMap["key"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "key")
                }
              }

              public var value: String {
                get {
                  return resultMap["value"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "value")
                }
              }

              public var text: String? {
                get {
                  return resultMap["text"] as? String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "text")
                }
              }

              public var fragments: Fragments {
                get {
                  return Fragments(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public struct Fragments {
                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public var basicExpressionFragment: BasicExpressionFragment {
                  get {
                    return BasicExpressionFragment(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }
              }
            }

            public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
              get {
                if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
                return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap = newValue.resultMap
              }
            }

            public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
                  GraphQLField("text", type: .scalar(String.self)),
                  GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
                self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var expressionMultipleType: EmbarkExpressionTypeMultiple {
                get {
                  return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
                }
                set {
                  resultMap.updateValue(newValue, forKey: "expressionMultipleType")
                }
              }

              public var text: String? {
                get {
                  return resultMap["text"] as? String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "text")
                }
              }

              public var subExpressions: [SubExpression] {
                get {
                  return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
                }
                set {
                  resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
                }
              }

              public var fragments: Fragments {
                get {
                  return Fragments(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public struct Fragments {
                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public var basicExpressionFragment: BasicExpressionFragment {
                  get {
                    return BasicExpressionFragment(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }
              }

              public struct SubExpression: GraphQLSelectionSet {
                public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

                public static var selections: [GraphQLSelection] {
                  return [
                    GraphQLTypeCase(
                      variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections],
                      default: [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      ]
                    )
                  ]
                }

                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public static func makeEmbarkExpressionMultiple() -> SubExpression {
                  return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple"])
                }

                public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
                  return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                }

                public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
                  return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                }

                public var __typename: String {
                  get {
                    return resultMap["__typename"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "__typename")
                  }
                }

                public var fragments: Fragments {
                  get {
                    return Fragments(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }

                public struct Fragments {
                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public var basicExpressionFragment: BasicExpressionFragment {
                    get {
                      return BasicExpressionFragment(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }
                }

                public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                  get {
                    if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                    return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                  }
                  set {
                    guard let newValue = newValue else { return }
                    resultMap = newValue.resultMap
                  }
                }

                public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                      GraphQLField("text", type: .scalar(String.self)),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var expressionUnaryType: EmbarkExpressionTypeUnary {
                    get {
                      return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                    }
                  }

                  public var text: String? {
                    get {
                      return resultMap["text"] as? String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "text")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var basicExpressionFragment: BasicExpressionFragment {
                      get {
                        return BasicExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }
                }

                public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                  get {
                    if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                    return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                  }
                  set {
                    guard let newValue = newValue else { return }
                    resultMap = newValue.resultMap
                  }
                }

                public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                      GraphQLField("key", type: .nonNull(.scalar(String.self))),
                      GraphQLField("value", type: .nonNull(.scalar(String.self))),
                      GraphQLField("text", type: .scalar(String.self)),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var expressionBinaryType: EmbarkExpressionTypeBinary {
                    get {
                      return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                    }
                  }

                  public var key: String {
                    get {
                      return resultMap["key"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "key")
                    }
                  }

                  public var value: String {
                    get {
                      return resultMap["value"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "value")
                    }
                  }

                  public var text: String? {
                    get {
                      return resultMap["text"] as? String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "text")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var basicExpressionFragment: BasicExpressionFragment {
                      get {
                        return BasicExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  struct ResponseFragment: GraphQLFragment {
    /// The raw GraphQL definition of this fragment.
    public static let fragmentDefinition: String =
      """
      fragment ResponseFragment on EmbarkResponse {
        __typename
        ... on EmbarkMessage {
          ...MessageFragment
        }
        ... on EmbarkGroupedResponse {
          component
          items {
            __typename
            ...MessageFragment
          }
          each {
            __typename
            key
            content {
              __typename
              ...MessageFragment
            }
          }
          title {
            __typename
            text
          }
        }
        ... on EmbarkResponseExpression {
          text
          expressions {
            __typename
            ...ExpressionFragment
          }
        }
      }
      """

    public static let possibleTypes: [String] = ["EmbarkGroupedResponse", "EmbarkResponseExpression", "EmbarkMessage"]

    public static var selections: [GraphQLSelection] {
      return [
        GraphQLTypeCase(
          variants: ["EmbarkMessage": AsEmbarkMessage.selections, "EmbarkGroupedResponse": AsEmbarkGroupedResponse.selections, "EmbarkResponseExpression": AsEmbarkResponseExpression.selections],
          default: [
            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
          ]
        )
      ]
    }

    public private(set) var resultMap: ResultMap

    public init(unsafeResultMap: ResultMap) {
      self.resultMap = unsafeResultMap
    }

    public static func makeEmbarkMessage(text: String, expressions: [AsEmbarkMessage.Expression]) -> ResponseFragment {
      return ResponseFragment(unsafeResultMap: ["__typename": "EmbarkMessage", "text": text, "expressions": expressions.map { (value: AsEmbarkMessage.Expression) -> ResultMap in value.resultMap }])
    }

    public static func makeEmbarkGroupedResponse(component: String, items: [AsEmbarkGroupedResponse.Item], each: AsEmbarkGroupedResponse.Each? = nil, title: AsEmbarkGroupedResponse.Title) -> ResponseFragment {
      return ResponseFragment(unsafeResultMap: ["__typename": "EmbarkGroupedResponse", "component": component, "items": items.map { (value: AsEmbarkGroupedResponse.Item) -> ResultMap in value.resultMap }, "each": each.flatMap { (value: AsEmbarkGroupedResponse.Each) -> ResultMap in value.resultMap }, "title": title.resultMap])
    }

    public static func makeEmbarkResponseExpression(text: String, expressions: [AsEmbarkResponseExpression.Expression]) -> ResponseFragment {
      return ResponseFragment(unsafeResultMap: ["__typename": "EmbarkResponseExpression", "text": text, "expressions": expressions.map { (value: AsEmbarkResponseExpression.Expression) -> ResultMap in value.resultMap }])
    }

    public var __typename: String {
      get {
        return resultMap["__typename"]! as! String
      }
      set {
        resultMap.updateValue(newValue, forKey: "__typename")
      }
    }

    public var asEmbarkMessage: AsEmbarkMessage? {
      get {
        if !AsEmbarkMessage.possibleTypes.contains(__typename) { return nil }
        return AsEmbarkMessage(unsafeResultMap: resultMap)
      }
      set {
        guard let newValue = newValue else { return }
        resultMap = newValue.resultMap
      }
    }

    public struct AsEmbarkMessage: GraphQLSelectionSet {
      public static let possibleTypes: [String] = ["EmbarkMessage"]

      public static var selections: [GraphQLSelection] {
        return [
          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
          GraphQLField("text", type: .nonNull(.scalar(String.self))),
          GraphQLField("expressions", type: .nonNull(.list(.nonNull(.object(Expression.selections))))),
        ]
      }

      public private(set) var resultMap: ResultMap

      public init(unsafeResultMap: ResultMap) {
        self.resultMap = unsafeResultMap
      }

      public init(text: String, expressions: [Expression]) {
        self.init(unsafeResultMap: ["__typename": "EmbarkMessage", "text": text, "expressions": expressions.map { (value: Expression) -> ResultMap in value.resultMap }])
      }

      public var __typename: String {
        get {
          return resultMap["__typename"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "__typename")
        }
      }

      public var text: String {
        get {
          return resultMap["text"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "text")
        }
      }

      public var expressions: [Expression] {
        get {
          return (resultMap["expressions"] as! [ResultMap]).map { (value: ResultMap) -> Expression in Expression(unsafeResultMap: value) }
        }
        set {
          resultMap.updateValue(newValue.map { (value: Expression) -> ResultMap in value.resultMap }, forKey: "expressions")
        }
      }

      public var fragments: Fragments {
        get {
          return Fragments(unsafeResultMap: resultMap)
        }
        set {
          resultMap += newValue.resultMap
        }
      }

      public struct Fragments {
        public private(set) var resultMap: ResultMap

        public init(unsafeResultMap: ResultMap) {
          self.resultMap = unsafeResultMap
        }

        public var messageFragment: MessageFragment {
          get {
            return MessageFragment(unsafeResultMap: resultMap)
          }
          set {
            resultMap += newValue.resultMap
          }
        }
      }

      public struct Expression: GraphQLSelectionSet {
        public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

        public static var selections: [GraphQLSelection] {
          return [
            GraphQLTypeCase(
              variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
              default: [
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              ]
            )
          ]
        }

        public private(set) var resultMap: ResultMap

        public init(unsafeResultMap: ResultMap) {
          self.resultMap = unsafeResultMap
        }

        public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> Expression {
          return Expression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
        }

        public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> Expression {
          return Expression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
        }

        public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> Expression {
          return Expression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
        }

        public var __typename: String {
          get {
            return resultMap["__typename"]! as! String
          }
          set {
            resultMap.updateValue(newValue, forKey: "__typename")
          }
        }

        public var fragments: Fragments {
          get {
            return Fragments(unsafeResultMap: resultMap)
          }
          set {
            resultMap += newValue.resultMap
          }
        }

        public struct Fragments {
          public private(set) var resultMap: ResultMap

          public init(unsafeResultMap: ResultMap) {
            self.resultMap = unsafeResultMap
          }

          public var expressionFragment: ExpressionFragment {
            get {
              return ExpressionFragment(unsafeResultMap: resultMap)
            }
            set {
              resultMap += newValue.resultMap
            }
          }

          public var basicExpressionFragment: BasicExpressionFragment {
            get {
              return BasicExpressionFragment(unsafeResultMap: resultMap)
            }
            set {
              resultMap += newValue.resultMap
            }
          }
        }

        public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
          get {
            if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
            return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
          }
          set {
            guard let newValue = newValue else { return }
            resultMap = newValue.resultMap
          }
        }

        public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
          public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

          public static var selections: [GraphQLSelection] {
            return [
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
              GraphQLField("text", type: .scalar(String.self)),
            ]
          }

          public private(set) var resultMap: ResultMap

          public init(unsafeResultMap: ResultMap) {
            self.resultMap = unsafeResultMap
          }

          public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
            self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
          }

          public var __typename: String {
            get {
              return resultMap["__typename"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "__typename")
            }
          }

          public var expressionUnaryType: EmbarkExpressionTypeUnary {
            get {
              return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
            }
            set {
              resultMap.updateValue(newValue, forKey: "expressionUnaryType")
            }
          }

          public var text: String? {
            get {
              return resultMap["text"] as? String
            }
            set {
              resultMap.updateValue(newValue, forKey: "text")
            }
          }

          public var fragments: Fragments {
            get {
              return Fragments(unsafeResultMap: resultMap)
            }
            set {
              resultMap += newValue.resultMap
            }
          }

          public struct Fragments {
            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public var expressionFragment: ExpressionFragment {
              get {
                return ExpressionFragment(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }

            public var basicExpressionFragment: BasicExpressionFragment {
              get {
                return BasicExpressionFragment(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }
          }
        }

        public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
          get {
            if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
            return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
          }
          set {
            guard let newValue = newValue else { return }
            resultMap = newValue.resultMap
          }
        }

        public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
          public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

          public static var selections: [GraphQLSelection] {
            return [
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
              GraphQLField("key", type: .nonNull(.scalar(String.self))),
              GraphQLField("value", type: .nonNull(.scalar(String.self))),
              GraphQLField("text", type: .scalar(String.self)),
            ]
          }

          public private(set) var resultMap: ResultMap

          public init(unsafeResultMap: ResultMap) {
            self.resultMap = unsafeResultMap
          }

          public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
            self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
          }

          public var __typename: String {
            get {
              return resultMap["__typename"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "__typename")
            }
          }

          public var expressionBinaryType: EmbarkExpressionTypeBinary {
            get {
              return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
            }
            set {
              resultMap.updateValue(newValue, forKey: "expressionBinaryType")
            }
          }

          public var key: String {
            get {
              return resultMap["key"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "key")
            }
          }

          public var value: String {
            get {
              return resultMap["value"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "value")
            }
          }

          public var text: String? {
            get {
              return resultMap["text"] as? String
            }
            set {
              resultMap.updateValue(newValue, forKey: "text")
            }
          }

          public var fragments: Fragments {
            get {
              return Fragments(unsafeResultMap: resultMap)
            }
            set {
              resultMap += newValue.resultMap
            }
          }

          public struct Fragments {
            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public var expressionFragment: ExpressionFragment {
              get {
                return ExpressionFragment(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }

            public var basicExpressionFragment: BasicExpressionFragment {
              get {
                return BasicExpressionFragment(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }
          }
        }

        public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
          get {
            if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
            return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
          }
          set {
            guard let newValue = newValue else { return }
            resultMap = newValue.resultMap
          }
        }

        public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
          public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

          public static var selections: [GraphQLSelection] {
            return [
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
              GraphQLField("text", type: .scalar(String.self)),
              GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
            ]
          }

          public private(set) var resultMap: ResultMap

          public init(unsafeResultMap: ResultMap) {
            self.resultMap = unsafeResultMap
          }

          public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
            self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
          }

          public var __typename: String {
            get {
              return resultMap["__typename"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "__typename")
            }
          }

          public var expressionMultipleType: EmbarkExpressionTypeMultiple {
            get {
              return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
            }
            set {
              resultMap.updateValue(newValue, forKey: "expressionMultipleType")
            }
          }

          public var text: String? {
            get {
              return resultMap["text"] as? String
            }
            set {
              resultMap.updateValue(newValue, forKey: "text")
            }
          }

          public var subExpressions: [SubExpression] {
            get {
              return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
            }
            set {
              resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
            }
          }

          public var fragments: Fragments {
            get {
              return Fragments(unsafeResultMap: resultMap)
            }
            set {
              resultMap += newValue.resultMap
            }
          }

          public struct Fragments {
            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public var expressionFragment: ExpressionFragment {
              get {
                return ExpressionFragment(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }

            public var basicExpressionFragment: BasicExpressionFragment {
              get {
                return BasicExpressionFragment(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }
          }

          public struct SubExpression: GraphQLSelectionSet {
            public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

            public static var selections: [GraphQLSelection] {
              return [
                GraphQLTypeCase(
                  variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
                  default: [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  ]
                )
              ]
            }

            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
              return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
            }

            public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
              return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
            }

            public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> SubExpression {
              return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
            }

            public var __typename: String {
              get {
                return resultMap["__typename"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "__typename")
              }
            }

            public var fragments: Fragments {
              get {
                return Fragments(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }

            public struct Fragments {
              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public var basicExpressionFragment: BasicExpressionFragment {
                get {
                  return BasicExpressionFragment(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }
            }

            public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
              get {
                if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap = newValue.resultMap
              }
            }

            public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                  GraphQLField("text", type: .scalar(String.self)),
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var expressionUnaryType: EmbarkExpressionTypeUnary {
                get {
                  return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                }
                set {
                  resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                }
              }

              public var text: String? {
                get {
                  return resultMap["text"] as? String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "text")
                }
              }

              public var fragments: Fragments {
                get {
                  return Fragments(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public struct Fragments {
                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public var basicExpressionFragment: BasicExpressionFragment {
                  get {
                    return BasicExpressionFragment(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }
              }
            }

            public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
              get {
                if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap = newValue.resultMap
              }
            }

            public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                  GraphQLField("key", type: .nonNull(.scalar(String.self))),
                  GraphQLField("value", type: .nonNull(.scalar(String.self))),
                  GraphQLField("text", type: .scalar(String.self)),
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var expressionBinaryType: EmbarkExpressionTypeBinary {
                get {
                  return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                }
                set {
                  resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                }
              }

              public var key: String {
                get {
                  return resultMap["key"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "key")
                }
              }

              public var value: String {
                get {
                  return resultMap["value"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "value")
                }
              }

              public var text: String? {
                get {
                  return resultMap["text"] as? String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "text")
                }
              }

              public var fragments: Fragments {
                get {
                  return Fragments(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public struct Fragments {
                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public var basicExpressionFragment: BasicExpressionFragment {
                  get {
                    return BasicExpressionFragment(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }
              }
            }

            public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
              get {
                if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
                return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap = newValue.resultMap
              }
            }

            public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
                  GraphQLField("text", type: .scalar(String.self)),
                  GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
                self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var expressionMultipleType: EmbarkExpressionTypeMultiple {
                get {
                  return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
                }
                set {
                  resultMap.updateValue(newValue, forKey: "expressionMultipleType")
                }
              }

              public var text: String? {
                get {
                  return resultMap["text"] as? String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "text")
                }
              }

              public var subExpressions: [SubExpression] {
                get {
                  return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
                }
                set {
                  resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
                }
              }

              public var fragments: Fragments {
                get {
                  return Fragments(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public struct Fragments {
                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public var basicExpressionFragment: BasicExpressionFragment {
                  get {
                    return BasicExpressionFragment(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }
              }

              public struct SubExpression: GraphQLSelectionSet {
                public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

                public static var selections: [GraphQLSelection] {
                  return [
                    GraphQLTypeCase(
                      variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
                      default: [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      ]
                    )
                  ]
                }

                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
                  return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                }

                public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
                  return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                }

                public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> SubExpression {
                  return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
                }

                public var __typename: String {
                  get {
                    return resultMap["__typename"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "__typename")
                  }
                }

                public var fragments: Fragments {
                  get {
                    return Fragments(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }

                public struct Fragments {
                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public var basicExpressionFragment: BasicExpressionFragment {
                    get {
                      return BasicExpressionFragment(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }
                }

                public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                  get {
                    if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                    return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                  }
                  set {
                    guard let newValue = newValue else { return }
                    resultMap = newValue.resultMap
                  }
                }

                public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                      GraphQLField("text", type: .scalar(String.self)),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var expressionUnaryType: EmbarkExpressionTypeUnary {
                    get {
                      return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                    }
                  }

                  public var text: String? {
                    get {
                      return resultMap["text"] as? String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "text")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var basicExpressionFragment: BasicExpressionFragment {
                      get {
                        return BasicExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }
                }

                public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                  get {
                    if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                    return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                  }
                  set {
                    guard let newValue = newValue else { return }
                    resultMap = newValue.resultMap
                  }
                }

                public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                      GraphQLField("key", type: .nonNull(.scalar(String.self))),
                      GraphQLField("value", type: .nonNull(.scalar(String.self))),
                      GraphQLField("text", type: .scalar(String.self)),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var expressionBinaryType: EmbarkExpressionTypeBinary {
                    get {
                      return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                    }
                  }

                  public var key: String {
                    get {
                      return resultMap["key"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "key")
                    }
                  }

                  public var value: String {
                    get {
                      return resultMap["value"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "value")
                    }
                  }

                  public var text: String? {
                    get {
                      return resultMap["text"] as? String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "text")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var basicExpressionFragment: BasicExpressionFragment {
                      get {
                        return BasicExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }
                }

                public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
                  get {
                    if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
                    return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
                  }
                  set {
                    guard let newValue = newValue else { return }
                    resultMap = newValue.resultMap
                  }
                }

                public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
                      GraphQLField("text", type: .scalar(String.self)),
                      GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var expressionMultipleType: EmbarkExpressionTypeMultiple {
                    get {
                      return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "expressionMultipleType")
                    }
                  }

                  public var text: String? {
                    get {
                      return resultMap["text"] as? String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "text")
                    }
                  }

                  public var subExpressions: [SubExpression] {
                    get {
                      return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
                    }
                    set {
                      resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var basicExpressionFragment: BasicExpressionFragment {
                      get {
                        return BasicExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }

                  public struct SubExpression: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLTypeCase(
                          variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections],
                          default: [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          ]
                        )
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public static func makeEmbarkExpressionMultiple() -> SubExpression {
                      return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple"])
                    }

                    public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
                      return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                    }

                    public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
                      return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var fragments: Fragments {
                      get {
                        return Fragments(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public struct Fragments {
                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public var basicExpressionFragment: BasicExpressionFragment {
                        get {
                          return BasicExpressionFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }
                    }

                    public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                      get {
                        if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                        return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                      }
                      set {
                        guard let newValue = newValue else { return }
                        resultMap = newValue.resultMap
                      }
                    }

                    public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                      public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                      public static var selections: [GraphQLSelection] {
                        return [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                          GraphQLField("text", type: .scalar(String.self)),
                        ]
                      }

                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                        self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                      }

                      public var __typename: String {
                        get {
                          return resultMap["__typename"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "__typename")
                        }
                      }

                      public var expressionUnaryType: EmbarkExpressionTypeUnary {
                        get {
                          return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                        }
                      }

                      public var text: String? {
                        get {
                          return resultMap["text"] as? String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "text")
                        }
                      }

                      public var fragments: Fragments {
                        get {
                          return Fragments(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public struct Fragments {
                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public var basicExpressionFragment: BasicExpressionFragment {
                          get {
                            return BasicExpressionFragment(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }
                      }
                    }

                    public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                      get {
                        if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                        return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                      }
                      set {
                        guard let newValue = newValue else { return }
                        resultMap = newValue.resultMap
                      }
                    }

                    public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                      public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                      public static var selections: [GraphQLSelection] {
                        return [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                          GraphQLField("key", type: .nonNull(.scalar(String.self))),
                          GraphQLField("value", type: .nonNull(.scalar(String.self))),
                          GraphQLField("text", type: .scalar(String.self)),
                        ]
                      }

                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                        self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                      }

                      public var __typename: String {
                        get {
                          return resultMap["__typename"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "__typename")
                        }
                      }

                      public var expressionBinaryType: EmbarkExpressionTypeBinary {
                        get {
                          return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                        }
                      }

                      public var key: String {
                        get {
                          return resultMap["key"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "key")
                        }
                      }

                      public var value: String {
                        get {
                          return resultMap["value"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "value")
                        }
                      }

                      public var text: String? {
                        get {
                          return resultMap["text"] as? String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "text")
                        }
                      }

                      public var fragments: Fragments {
                        get {
                          return Fragments(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public struct Fragments {
                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public var basicExpressionFragment: BasicExpressionFragment {
                          get {
                            return BasicExpressionFragment(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    public var asEmbarkGroupedResponse: AsEmbarkGroupedResponse? {
      get {
        if !AsEmbarkGroupedResponse.possibleTypes.contains(__typename) { return nil }
        return AsEmbarkGroupedResponse(unsafeResultMap: resultMap)
      }
      set {
        guard let newValue = newValue else { return }
        resultMap = newValue.resultMap
      }
    }

    public struct AsEmbarkGroupedResponse: GraphQLSelectionSet {
      public static let possibleTypes: [String] = ["EmbarkGroupedResponse"]

      public static var selections: [GraphQLSelection] {
        return [
          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
          GraphQLField("component", type: .nonNull(.scalar(String.self))),
          GraphQLField("items", type: .nonNull(.list(.nonNull(.object(Item.selections))))),
          GraphQLField("each", type: .object(Each.selections)),
          GraphQLField("title", type: .nonNull(.object(Title.selections))),
        ]
      }

      public private(set) var resultMap: ResultMap

      public init(unsafeResultMap: ResultMap) {
        self.resultMap = unsafeResultMap
      }

      public init(component: String, items: [Item], each: Each? = nil, title: Title) {
        self.init(unsafeResultMap: ["__typename": "EmbarkGroupedResponse", "component": component, "items": items.map { (value: Item) -> ResultMap in value.resultMap }, "each": each.flatMap { (value: Each) -> ResultMap in value.resultMap }, "title": title.resultMap])
      }

      public var __typename: String {
        get {
          return resultMap["__typename"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "__typename")
        }
      }

      public var component: String {
        get {
          return resultMap["component"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "component")
        }
      }

      public var items: [Item] {
        get {
          return (resultMap["items"] as! [ResultMap]).map { (value: ResultMap) -> Item in Item(unsafeResultMap: value) }
        }
        set {
          resultMap.updateValue(newValue.map { (value: Item) -> ResultMap in value.resultMap }, forKey: "items")
        }
      }

      public var each: Each? {
        get {
          return (resultMap["each"] as? ResultMap).flatMap { Each(unsafeResultMap: $0) }
        }
        set {
          resultMap.updateValue(newValue?.resultMap, forKey: "each")
        }
      }

      public var title: Title {
        get {
          return Title(unsafeResultMap: resultMap["title"]! as! ResultMap)
        }
        set {
          resultMap.updateValue(newValue.resultMap, forKey: "title")
        }
      }

      public struct Item: GraphQLSelectionSet {
        public static let possibleTypes: [String] = ["EmbarkMessage"]

        public static var selections: [GraphQLSelection] {
          return [
            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
            GraphQLField("text", type: .nonNull(.scalar(String.self))),
            GraphQLField("expressions", type: .nonNull(.list(.nonNull(.object(Expression.selections))))),
          ]
        }

        public private(set) var resultMap: ResultMap

        public init(unsafeResultMap: ResultMap) {
          self.resultMap = unsafeResultMap
        }

        public init(text: String, expressions: [Expression]) {
          self.init(unsafeResultMap: ["__typename": "EmbarkMessage", "text": text, "expressions": expressions.map { (value: Expression) -> ResultMap in value.resultMap }])
        }

        public var __typename: String {
          get {
            return resultMap["__typename"]! as! String
          }
          set {
            resultMap.updateValue(newValue, forKey: "__typename")
          }
        }

        public var text: String {
          get {
            return resultMap["text"]! as! String
          }
          set {
            resultMap.updateValue(newValue, forKey: "text")
          }
        }

        public var expressions: [Expression] {
          get {
            return (resultMap["expressions"] as! [ResultMap]).map { (value: ResultMap) -> Expression in Expression(unsafeResultMap: value) }
          }
          set {
            resultMap.updateValue(newValue.map { (value: Expression) -> ResultMap in value.resultMap }, forKey: "expressions")
          }
        }

        public var fragments: Fragments {
          get {
            return Fragments(unsafeResultMap: resultMap)
          }
          set {
            resultMap += newValue.resultMap
          }
        }

        public struct Fragments {
          public private(set) var resultMap: ResultMap

          public init(unsafeResultMap: ResultMap) {
            self.resultMap = unsafeResultMap
          }

          public var messageFragment: MessageFragment {
            get {
              return MessageFragment(unsafeResultMap: resultMap)
            }
            set {
              resultMap += newValue.resultMap
            }
          }
        }

        public struct Expression: GraphQLSelectionSet {
          public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

          public static var selections: [GraphQLSelection] {
            return [
              GraphQLTypeCase(
                variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
                default: [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                ]
              )
            ]
          }

          public private(set) var resultMap: ResultMap

          public init(unsafeResultMap: ResultMap) {
            self.resultMap = unsafeResultMap
          }

          public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> Expression {
            return Expression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
          }

          public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> Expression {
            return Expression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
          }

          public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> Expression {
            return Expression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
          }

          public var __typename: String {
            get {
              return resultMap["__typename"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "__typename")
            }
          }

          public var fragments: Fragments {
            get {
              return Fragments(unsafeResultMap: resultMap)
            }
            set {
              resultMap += newValue.resultMap
            }
          }

          public struct Fragments {
            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public var expressionFragment: ExpressionFragment {
              get {
                return ExpressionFragment(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }

            public var basicExpressionFragment: BasicExpressionFragment {
              get {
                return BasicExpressionFragment(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }
          }

          public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
            get {
              if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
              return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
            }
            set {
              guard let newValue = newValue else { return }
              resultMap = newValue.resultMap
            }
          }

          public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
            public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

            public static var selections: [GraphQLSelection] {
              return [
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                GraphQLField("text", type: .scalar(String.self)),
              ]
            }

            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
              self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
            }

            public var __typename: String {
              get {
                return resultMap["__typename"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "__typename")
              }
            }

            public var expressionUnaryType: EmbarkExpressionTypeUnary {
              get {
                return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
              }
              set {
                resultMap.updateValue(newValue, forKey: "expressionUnaryType")
              }
            }

            public var text: String? {
              get {
                return resultMap["text"] as? String
              }
              set {
                resultMap.updateValue(newValue, forKey: "text")
              }
            }

            public var fragments: Fragments {
              get {
                return Fragments(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }

            public struct Fragments {
              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public var expressionFragment: ExpressionFragment {
                get {
                  return ExpressionFragment(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public var basicExpressionFragment: BasicExpressionFragment {
                get {
                  return BasicExpressionFragment(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }
            }
          }

          public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
            get {
              if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
              return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
            }
            set {
              guard let newValue = newValue else { return }
              resultMap = newValue.resultMap
            }
          }

          public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
            public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

            public static var selections: [GraphQLSelection] {
              return [
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                GraphQLField("key", type: .nonNull(.scalar(String.self))),
                GraphQLField("value", type: .nonNull(.scalar(String.self))),
                GraphQLField("text", type: .scalar(String.self)),
              ]
            }

            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
              self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
            }

            public var __typename: String {
              get {
                return resultMap["__typename"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "__typename")
              }
            }

            public var expressionBinaryType: EmbarkExpressionTypeBinary {
              get {
                return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
              }
              set {
                resultMap.updateValue(newValue, forKey: "expressionBinaryType")
              }
            }

            public var key: String {
              get {
                return resultMap["key"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "key")
              }
            }

            public var value: String {
              get {
                return resultMap["value"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "value")
              }
            }

            public var text: String? {
              get {
                return resultMap["text"] as? String
              }
              set {
                resultMap.updateValue(newValue, forKey: "text")
              }
            }

            public var fragments: Fragments {
              get {
                return Fragments(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }

            public struct Fragments {
              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public var expressionFragment: ExpressionFragment {
                get {
                  return ExpressionFragment(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public var basicExpressionFragment: BasicExpressionFragment {
                get {
                  return BasicExpressionFragment(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }
            }
          }

          public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
            get {
              if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
              return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
            }
            set {
              guard let newValue = newValue else { return }
              resultMap = newValue.resultMap
            }
          }

          public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
            public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

            public static var selections: [GraphQLSelection] {
              return [
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
                GraphQLField("text", type: .scalar(String.self)),
                GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
              ]
            }

            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
              self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
            }

            public var __typename: String {
              get {
                return resultMap["__typename"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "__typename")
              }
            }

            public var expressionMultipleType: EmbarkExpressionTypeMultiple {
              get {
                return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
              }
              set {
                resultMap.updateValue(newValue, forKey: "expressionMultipleType")
              }
            }

            public var text: String? {
              get {
                return resultMap["text"] as? String
              }
              set {
                resultMap.updateValue(newValue, forKey: "text")
              }
            }

            public var subExpressions: [SubExpression] {
              get {
                return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
              }
              set {
                resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
              }
            }

            public var fragments: Fragments {
              get {
                return Fragments(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }

            public struct Fragments {
              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public var expressionFragment: ExpressionFragment {
                get {
                  return ExpressionFragment(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public var basicExpressionFragment: BasicExpressionFragment {
                get {
                  return BasicExpressionFragment(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }
            }

            public struct SubExpression: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLTypeCase(
                    variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
                    default: [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    ]
                  )
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
                return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
              }

              public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
                return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
              }

              public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> SubExpression {
                return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var fragments: Fragments {
                get {
                  return Fragments(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public struct Fragments {
                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public var basicExpressionFragment: BasicExpressionFragment {
                  get {
                    return BasicExpressionFragment(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }
              }

              public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                get {
                  if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                  return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                }
                set {
                  guard let newValue = newValue else { return }
                  resultMap = newValue.resultMap
                }
              }

              public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                public static var selections: [GraphQLSelection] {
                  return [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                    GraphQLField("text", type: .scalar(String.self)),
                  ]
                }

                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                  self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                }

                public var __typename: String {
                  get {
                    return resultMap["__typename"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "__typename")
                  }
                }

                public var expressionUnaryType: EmbarkExpressionTypeUnary {
                  get {
                    return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                  }
                }

                public var text: String? {
                  get {
                    return resultMap["text"] as? String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "text")
                  }
                }

                public var fragments: Fragments {
                  get {
                    return Fragments(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }

                public struct Fragments {
                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public var basicExpressionFragment: BasicExpressionFragment {
                    get {
                      return BasicExpressionFragment(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }
                }
              }

              public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                get {
                  if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                  return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                }
                set {
                  guard let newValue = newValue else { return }
                  resultMap = newValue.resultMap
                }
              }

              public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                public static var selections: [GraphQLSelection] {
                  return [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                    GraphQLField("key", type: .nonNull(.scalar(String.self))),
                    GraphQLField("value", type: .nonNull(.scalar(String.self))),
                    GraphQLField("text", type: .scalar(String.self)),
                  ]
                }

                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                  self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                }

                public var __typename: String {
                  get {
                    return resultMap["__typename"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "__typename")
                  }
                }

                public var expressionBinaryType: EmbarkExpressionTypeBinary {
                  get {
                    return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                  }
                }

                public var key: String {
                  get {
                    return resultMap["key"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "key")
                  }
                }

                public var value: String {
                  get {
                    return resultMap["value"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "value")
                  }
                }

                public var text: String? {
                  get {
                    return resultMap["text"] as? String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "text")
                  }
                }

                public var fragments: Fragments {
                  get {
                    return Fragments(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }

                public struct Fragments {
                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public var basicExpressionFragment: BasicExpressionFragment {
                    get {
                      return BasicExpressionFragment(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }
                }
              }

              public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
                get {
                  if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
                  return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
                }
                set {
                  guard let newValue = newValue else { return }
                  resultMap = newValue.resultMap
                }
              }

              public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
                public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

                public static var selections: [GraphQLSelection] {
                  return [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
                    GraphQLField("text", type: .scalar(String.self)),
                    GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
                  ]
                }

                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
                  self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
                }

                public var __typename: String {
                  get {
                    return resultMap["__typename"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "__typename")
                  }
                }

                public var expressionMultipleType: EmbarkExpressionTypeMultiple {
                  get {
                    return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "expressionMultipleType")
                  }
                }

                public var text: String? {
                  get {
                    return resultMap["text"] as? String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "text")
                  }
                }

                public var subExpressions: [SubExpression] {
                  get {
                    return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
                  }
                  set {
                    resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
                  }
                }

                public var fragments: Fragments {
                  get {
                    return Fragments(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }

                public struct Fragments {
                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public var basicExpressionFragment: BasicExpressionFragment {
                    get {
                      return BasicExpressionFragment(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }
                }

                public struct SubExpression: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLTypeCase(
                        variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
                        default: [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        ]
                      )
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
                    return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                  }

                  public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
                    return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                  }

                  public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> SubExpression {
                    return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var basicExpressionFragment: BasicExpressionFragment {
                      get {
                        return BasicExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }

                  public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                    get {
                      if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                      return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                    }
                    set {
                      guard let newValue = newValue else { return }
                      resultMap = newValue.resultMap
                    }
                  }

                  public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                        GraphQLField("text", type: .scalar(String.self)),
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                      self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var expressionUnaryType: EmbarkExpressionTypeUnary {
                      get {
                        return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                      }
                    }

                    public var text: String? {
                      get {
                        return resultMap["text"] as? String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "text")
                      }
                    }

                    public var fragments: Fragments {
                      get {
                        return Fragments(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public struct Fragments {
                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public var basicExpressionFragment: BasicExpressionFragment {
                        get {
                          return BasicExpressionFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }
                    }
                  }

                  public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                    get {
                      if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                      return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                    }
                    set {
                      guard let newValue = newValue else { return }
                      resultMap = newValue.resultMap
                    }
                  }

                  public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                        GraphQLField("key", type: .nonNull(.scalar(String.self))),
                        GraphQLField("value", type: .nonNull(.scalar(String.self))),
                        GraphQLField("text", type: .scalar(String.self)),
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                      self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var expressionBinaryType: EmbarkExpressionTypeBinary {
                      get {
                        return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                      }
                    }

                    public var key: String {
                      get {
                        return resultMap["key"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "key")
                      }
                    }

                    public var value: String {
                      get {
                        return resultMap["value"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "value")
                      }
                    }

                    public var text: String? {
                      get {
                        return resultMap["text"] as? String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "text")
                      }
                    }

                    public var fragments: Fragments {
                      get {
                        return Fragments(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public struct Fragments {
                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public var basicExpressionFragment: BasicExpressionFragment {
                        get {
                          return BasicExpressionFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }
                    }
                  }

                  public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
                    get {
                      if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
                      return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
                    }
                    set {
                      guard let newValue = newValue else { return }
                      resultMap = newValue.resultMap
                    }
                  }

                  public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
                        GraphQLField("text", type: .scalar(String.self)),
                        GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
                      self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var expressionMultipleType: EmbarkExpressionTypeMultiple {
                      get {
                        return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "expressionMultipleType")
                      }
                    }

                    public var text: String? {
                      get {
                        return resultMap["text"] as? String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "text")
                      }
                    }

                    public var subExpressions: [SubExpression] {
                      get {
                        return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
                      }
                      set {
                        resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
                      }
                    }

                    public var fragments: Fragments {
                      get {
                        return Fragments(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public struct Fragments {
                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public var basicExpressionFragment: BasicExpressionFragment {
                        get {
                          return BasicExpressionFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }
                    }

                    public struct SubExpression: GraphQLSelectionSet {
                      public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

                      public static var selections: [GraphQLSelection] {
                        return [
                          GraphQLTypeCase(
                            variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections],
                            default: [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            ]
                          )
                        ]
                      }

                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public static func makeEmbarkExpressionMultiple() -> SubExpression {
                        return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple"])
                      }

                      public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
                        return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                      }

                      public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
                        return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                      }

                      public var __typename: String {
                        get {
                          return resultMap["__typename"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "__typename")
                        }
                      }

                      public var fragments: Fragments {
                        get {
                          return Fragments(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public struct Fragments {
                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public var basicExpressionFragment: BasicExpressionFragment {
                          get {
                            return BasicExpressionFragment(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }
                      }

                      public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                        get {
                          if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                          return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                        }
                        set {
                          guard let newValue = newValue else { return }
                          resultMap = newValue.resultMap
                        }
                      }

                      public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                            GraphQLField("text", type: .scalar(String.self)),
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                          self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var expressionUnaryType: EmbarkExpressionTypeUnary {
                          get {
                            return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                          }
                        }

                        public var text: String? {
                          get {
                            return resultMap["text"] as? String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "text")
                          }
                        }

                        public var fragments: Fragments {
                          get {
                            return Fragments(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }

                        public struct Fragments {
                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public var basicExpressionFragment: BasicExpressionFragment {
                            get {
                              return BasicExpressionFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }
                        }
                      }

                      public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                        get {
                          if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                          return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                        }
                        set {
                          guard let newValue = newValue else { return }
                          resultMap = newValue.resultMap
                        }
                      }

                      public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                            GraphQLField("key", type: .nonNull(.scalar(String.self))),
                            GraphQLField("value", type: .nonNull(.scalar(String.self))),
                            GraphQLField("text", type: .scalar(String.self)),
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                          self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var expressionBinaryType: EmbarkExpressionTypeBinary {
                          get {
                            return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                          }
                        }

                        public var key: String {
                          get {
                            return resultMap["key"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "key")
                          }
                        }

                        public var value: String {
                          get {
                            return resultMap["value"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "value")
                          }
                        }

                        public var text: String? {
                          get {
                            return resultMap["text"] as? String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "text")
                          }
                        }

                        public var fragments: Fragments {
                          get {
                            return Fragments(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }

                        public struct Fragments {
                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public var basicExpressionFragment: BasicExpressionFragment {
                            get {
                              return BasicExpressionFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      public struct Each: GraphQLSelectionSet {
        public static let possibleTypes: [String] = ["EmbarkGroupedResponseEach"]

        public static var selections: [GraphQLSelection] {
          return [
            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
            GraphQLField("key", type: .nonNull(.scalar(String.self))),
            GraphQLField("content", type: .nonNull(.object(Content.selections))),
          ]
        }

        public private(set) var resultMap: ResultMap

        public init(unsafeResultMap: ResultMap) {
          self.resultMap = unsafeResultMap
        }

        public init(key: String, content: Content) {
          self.init(unsafeResultMap: ["__typename": "EmbarkGroupedResponseEach", "key": key, "content": content.resultMap])
        }

        public var __typename: String {
          get {
            return resultMap["__typename"]! as! String
          }
          set {
            resultMap.updateValue(newValue, forKey: "__typename")
          }
        }

        public var key: String {
          get {
            return resultMap["key"]! as! String
          }
          set {
            resultMap.updateValue(newValue, forKey: "key")
          }
        }

        public var content: Content {
          get {
            return Content(unsafeResultMap: resultMap["content"]! as! ResultMap)
          }
          set {
            resultMap.updateValue(newValue.resultMap, forKey: "content")
          }
        }

        public struct Content: GraphQLSelectionSet {
          public static let possibleTypes: [String] = ["EmbarkMessage"]

          public static var selections: [GraphQLSelection] {
            return [
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("text", type: .nonNull(.scalar(String.self))),
              GraphQLField("expressions", type: .nonNull(.list(.nonNull(.object(Expression.selections))))),
            ]
          }

          public private(set) var resultMap: ResultMap

          public init(unsafeResultMap: ResultMap) {
            self.resultMap = unsafeResultMap
          }

          public init(text: String, expressions: [Expression]) {
            self.init(unsafeResultMap: ["__typename": "EmbarkMessage", "text": text, "expressions": expressions.map { (value: Expression) -> ResultMap in value.resultMap }])
          }

          public var __typename: String {
            get {
              return resultMap["__typename"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "__typename")
            }
          }

          public var text: String {
            get {
              return resultMap["text"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "text")
            }
          }

          public var expressions: [Expression] {
            get {
              return (resultMap["expressions"] as! [ResultMap]).map { (value: ResultMap) -> Expression in Expression(unsafeResultMap: value) }
            }
            set {
              resultMap.updateValue(newValue.map { (value: Expression) -> ResultMap in value.resultMap }, forKey: "expressions")
            }
          }

          public var fragments: Fragments {
            get {
              return Fragments(unsafeResultMap: resultMap)
            }
            set {
              resultMap += newValue.resultMap
            }
          }

          public struct Fragments {
            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public var messageFragment: MessageFragment {
              get {
                return MessageFragment(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }
          }

          public struct Expression: GraphQLSelectionSet {
            public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

            public static var selections: [GraphQLSelection] {
              return [
                GraphQLTypeCase(
                  variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
                  default: [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  ]
                )
              ]
            }

            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> Expression {
              return Expression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
            }

            public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> Expression {
              return Expression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
            }

            public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> Expression {
              return Expression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
            }

            public var __typename: String {
              get {
                return resultMap["__typename"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "__typename")
              }
            }

            public var fragments: Fragments {
              get {
                return Fragments(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }

            public struct Fragments {
              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public var expressionFragment: ExpressionFragment {
                get {
                  return ExpressionFragment(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public var basicExpressionFragment: BasicExpressionFragment {
                get {
                  return BasicExpressionFragment(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }
            }

            public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
              get {
                if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap = newValue.resultMap
              }
            }

            public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                  GraphQLField("text", type: .scalar(String.self)),
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var expressionUnaryType: EmbarkExpressionTypeUnary {
                get {
                  return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                }
                set {
                  resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                }
              }

              public var text: String? {
                get {
                  return resultMap["text"] as? String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "text")
                }
              }

              public var fragments: Fragments {
                get {
                  return Fragments(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public struct Fragments {
                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public var expressionFragment: ExpressionFragment {
                  get {
                    return ExpressionFragment(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }

                public var basicExpressionFragment: BasicExpressionFragment {
                  get {
                    return BasicExpressionFragment(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }
              }
            }

            public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
              get {
                if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap = newValue.resultMap
              }
            }

            public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                  GraphQLField("key", type: .nonNull(.scalar(String.self))),
                  GraphQLField("value", type: .nonNull(.scalar(String.self))),
                  GraphQLField("text", type: .scalar(String.self)),
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var expressionBinaryType: EmbarkExpressionTypeBinary {
                get {
                  return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                }
                set {
                  resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                }
              }

              public var key: String {
                get {
                  return resultMap["key"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "key")
                }
              }

              public var value: String {
                get {
                  return resultMap["value"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "value")
                }
              }

              public var text: String? {
                get {
                  return resultMap["text"] as? String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "text")
                }
              }

              public var fragments: Fragments {
                get {
                  return Fragments(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public struct Fragments {
                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public var expressionFragment: ExpressionFragment {
                  get {
                    return ExpressionFragment(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }

                public var basicExpressionFragment: BasicExpressionFragment {
                  get {
                    return BasicExpressionFragment(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }
              }
            }

            public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
              get {
                if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
                return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap = newValue.resultMap
              }
            }

            public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
                  GraphQLField("text", type: .scalar(String.self)),
                  GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
                self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var expressionMultipleType: EmbarkExpressionTypeMultiple {
                get {
                  return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
                }
                set {
                  resultMap.updateValue(newValue, forKey: "expressionMultipleType")
                }
              }

              public var text: String? {
                get {
                  return resultMap["text"] as? String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "text")
                }
              }

              public var subExpressions: [SubExpression] {
                get {
                  return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
                }
                set {
                  resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
                }
              }

              public var fragments: Fragments {
                get {
                  return Fragments(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public struct Fragments {
                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public var expressionFragment: ExpressionFragment {
                  get {
                    return ExpressionFragment(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }

                public var basicExpressionFragment: BasicExpressionFragment {
                  get {
                    return BasicExpressionFragment(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }
              }

              public struct SubExpression: GraphQLSelectionSet {
                public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

                public static var selections: [GraphQLSelection] {
                  return [
                    GraphQLTypeCase(
                      variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
                      default: [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      ]
                    )
                  ]
                }

                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
                  return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                }

                public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
                  return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                }

                public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> SubExpression {
                  return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
                }

                public var __typename: String {
                  get {
                    return resultMap["__typename"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "__typename")
                  }
                }

                public var fragments: Fragments {
                  get {
                    return Fragments(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }

                public struct Fragments {
                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public var basicExpressionFragment: BasicExpressionFragment {
                    get {
                      return BasicExpressionFragment(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }
                }

                public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                  get {
                    if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                    return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                  }
                  set {
                    guard let newValue = newValue else { return }
                    resultMap = newValue.resultMap
                  }
                }

                public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                      GraphQLField("text", type: .scalar(String.self)),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var expressionUnaryType: EmbarkExpressionTypeUnary {
                    get {
                      return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                    }
                  }

                  public var text: String? {
                    get {
                      return resultMap["text"] as? String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "text")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var basicExpressionFragment: BasicExpressionFragment {
                      get {
                        return BasicExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }
                }

                public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                  get {
                    if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                    return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                  }
                  set {
                    guard let newValue = newValue else { return }
                    resultMap = newValue.resultMap
                  }
                }

                public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                      GraphQLField("key", type: .nonNull(.scalar(String.self))),
                      GraphQLField("value", type: .nonNull(.scalar(String.self))),
                      GraphQLField("text", type: .scalar(String.self)),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var expressionBinaryType: EmbarkExpressionTypeBinary {
                    get {
                      return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                    }
                  }

                  public var key: String {
                    get {
                      return resultMap["key"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "key")
                    }
                  }

                  public var value: String {
                    get {
                      return resultMap["value"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "value")
                    }
                  }

                  public var text: String? {
                    get {
                      return resultMap["text"] as? String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "text")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var basicExpressionFragment: BasicExpressionFragment {
                      get {
                        return BasicExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }
                }

                public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
                  get {
                    if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
                    return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
                  }
                  set {
                    guard let newValue = newValue else { return }
                    resultMap = newValue.resultMap
                  }
                }

                public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
                      GraphQLField("text", type: .scalar(String.self)),
                      GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var expressionMultipleType: EmbarkExpressionTypeMultiple {
                    get {
                      return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "expressionMultipleType")
                    }
                  }

                  public var text: String? {
                    get {
                      return resultMap["text"] as? String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "text")
                    }
                  }

                  public var subExpressions: [SubExpression] {
                    get {
                      return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
                    }
                    set {
                      resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var basicExpressionFragment: BasicExpressionFragment {
                      get {
                        return BasicExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }

                  public struct SubExpression: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLTypeCase(
                          variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
                          default: [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          ]
                        )
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
                      return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                    }

                    public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
                      return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                    }

                    public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> SubExpression {
                      return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var fragments: Fragments {
                      get {
                        return Fragments(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public struct Fragments {
                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public var basicExpressionFragment: BasicExpressionFragment {
                        get {
                          return BasicExpressionFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }
                    }

                    public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                      get {
                        if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                        return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                      }
                      set {
                        guard let newValue = newValue else { return }
                        resultMap = newValue.resultMap
                      }
                    }

                    public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                      public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                      public static var selections: [GraphQLSelection] {
                        return [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                          GraphQLField("text", type: .scalar(String.self)),
                        ]
                      }

                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                        self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                      }

                      public var __typename: String {
                        get {
                          return resultMap["__typename"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "__typename")
                        }
                      }

                      public var expressionUnaryType: EmbarkExpressionTypeUnary {
                        get {
                          return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                        }
                      }

                      public var text: String? {
                        get {
                          return resultMap["text"] as? String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "text")
                        }
                      }

                      public var fragments: Fragments {
                        get {
                          return Fragments(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public struct Fragments {
                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public var basicExpressionFragment: BasicExpressionFragment {
                          get {
                            return BasicExpressionFragment(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }
                      }
                    }

                    public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                      get {
                        if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                        return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                      }
                      set {
                        guard let newValue = newValue else { return }
                        resultMap = newValue.resultMap
                      }
                    }

                    public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                      public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                      public static var selections: [GraphQLSelection] {
                        return [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                          GraphQLField("key", type: .nonNull(.scalar(String.self))),
                          GraphQLField("value", type: .nonNull(.scalar(String.self))),
                          GraphQLField("text", type: .scalar(String.self)),
                        ]
                      }

                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                        self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                      }

                      public var __typename: String {
                        get {
                          return resultMap["__typename"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "__typename")
                        }
                      }

                      public var expressionBinaryType: EmbarkExpressionTypeBinary {
                        get {
                          return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                        }
                      }

                      public var key: String {
                        get {
                          return resultMap["key"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "key")
                        }
                      }

                      public var value: String {
                        get {
                          return resultMap["value"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "value")
                        }
                      }

                      public var text: String? {
                        get {
                          return resultMap["text"] as? String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "text")
                        }
                      }

                      public var fragments: Fragments {
                        get {
                          return Fragments(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public struct Fragments {
                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public var basicExpressionFragment: BasicExpressionFragment {
                          get {
                            return BasicExpressionFragment(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }
                      }
                    }

                    public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
                      get {
                        if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
                        return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
                      }
                      set {
                        guard let newValue = newValue else { return }
                        resultMap = newValue.resultMap
                      }
                    }

                    public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
                      public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

                      public static var selections: [GraphQLSelection] {
                        return [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
                          GraphQLField("text", type: .scalar(String.self)),
                          GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
                        ]
                      }

                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
                        self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
                      }

                      public var __typename: String {
                        get {
                          return resultMap["__typename"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "__typename")
                        }
                      }

                      public var expressionMultipleType: EmbarkExpressionTypeMultiple {
                        get {
                          return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "expressionMultipleType")
                        }
                      }

                      public var text: String? {
                        get {
                          return resultMap["text"] as? String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "text")
                        }
                      }

                      public var subExpressions: [SubExpression] {
                        get {
                          return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
                        }
                        set {
                          resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
                        }
                      }

                      public var fragments: Fragments {
                        get {
                          return Fragments(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public struct Fragments {
                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public var basicExpressionFragment: BasicExpressionFragment {
                          get {
                            return BasicExpressionFragment(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }
                      }

                      public struct SubExpression: GraphQLSelectionSet {
                        public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

                        public static var selections: [GraphQLSelection] {
                          return [
                            GraphQLTypeCase(
                              variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections],
                              default: [
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              ]
                            )
                          ]
                        }

                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public static func makeEmbarkExpressionMultiple() -> SubExpression {
                          return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple"])
                        }

                        public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
                          return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                        }

                        public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
                          return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                        }

                        public var __typename: String {
                          get {
                            return resultMap["__typename"]! as! String
                          }
                          set {
                            resultMap.updateValue(newValue, forKey: "__typename")
                          }
                        }

                        public var fragments: Fragments {
                          get {
                            return Fragments(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }

                        public struct Fragments {
                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public var basicExpressionFragment: BasicExpressionFragment {
                            get {
                              return BasicExpressionFragment(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }
                        }

                        public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                          get {
                            if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                            return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                          }
                          set {
                            guard let newValue = newValue else { return }
                            resultMap = newValue.resultMap
                          }
                        }

                        public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                              GraphQLField("text", type: .scalar(String.self)),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var expressionUnaryType: EmbarkExpressionTypeUnary {
                            get {
                              return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                            }
                          }

                          public var text: String? {
                            get {
                              return resultMap["text"] as? String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "text")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var basicExpressionFragment: BasicExpressionFragment {
                              get {
                                return BasicExpressionFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }
                          }
                        }

                        public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                          get {
                            if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                            return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                          }
                          set {
                            guard let newValue = newValue else { return }
                            resultMap = newValue.resultMap
                          }
                        }

                        public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                          public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                          public static var selections: [GraphQLSelection] {
                            return [
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                              GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                              GraphQLField("key", type: .nonNull(.scalar(String.self))),
                              GraphQLField("value", type: .nonNull(.scalar(String.self))),
                              GraphQLField("text", type: .scalar(String.self)),
                            ]
                          }

                          public private(set) var resultMap: ResultMap

                          public init(unsafeResultMap: ResultMap) {
                            self.resultMap = unsafeResultMap
                          }

                          public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                            self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                          }

                          public var __typename: String {
                            get {
                              return resultMap["__typename"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "__typename")
                            }
                          }

                          public var expressionBinaryType: EmbarkExpressionTypeBinary {
                            get {
                              return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                            }
                          }

                          public var key: String {
                            get {
                              return resultMap["key"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "key")
                            }
                          }

                          public var value: String {
                            get {
                              return resultMap["value"]! as! String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "value")
                            }
                          }

                          public var text: String? {
                            get {
                              return resultMap["text"] as? String
                            }
                            set {
                              resultMap.updateValue(newValue, forKey: "text")
                            }
                          }

                          public var fragments: Fragments {
                            get {
                              return Fragments(unsafeResultMap: resultMap)
                            }
                            set {
                              resultMap += newValue.resultMap
                            }
                          }

                          public struct Fragments {
                            public private(set) var resultMap: ResultMap

                            public init(unsafeResultMap: ResultMap) {
                              self.resultMap = unsafeResultMap
                            }

                            public var basicExpressionFragment: BasicExpressionFragment {
                              get {
                                return BasicExpressionFragment(unsafeResultMap: resultMap)
                              }
                              set {
                                resultMap += newValue.resultMap
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      public struct Title: GraphQLSelectionSet {
        public static let possibleTypes: [String] = ["EmbarkResponseExpression"]

        public static var selections: [GraphQLSelection] {
          return [
            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
            GraphQLField("text", type: .nonNull(.scalar(String.self))),
          ]
        }

        public private(set) var resultMap: ResultMap

        public init(unsafeResultMap: ResultMap) {
          self.resultMap = unsafeResultMap
        }

        public init(text: String) {
          self.init(unsafeResultMap: ["__typename": "EmbarkResponseExpression", "text": text])
        }

        public var __typename: String {
          get {
            return resultMap["__typename"]! as! String
          }
          set {
            resultMap.updateValue(newValue, forKey: "__typename")
          }
        }

        public var text: String {
          get {
            return resultMap["text"]! as! String
          }
          set {
            resultMap.updateValue(newValue, forKey: "text")
          }
        }
      }
    }

    public var asEmbarkResponseExpression: AsEmbarkResponseExpression? {
      get {
        if !AsEmbarkResponseExpression.possibleTypes.contains(__typename) { return nil }
        return AsEmbarkResponseExpression(unsafeResultMap: resultMap)
      }
      set {
        guard let newValue = newValue else { return }
        resultMap = newValue.resultMap
      }
    }

    public struct AsEmbarkResponseExpression: GraphQLSelectionSet {
      public static let possibleTypes: [String] = ["EmbarkResponseExpression"]

      public static var selections: [GraphQLSelection] {
        return [
          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
          GraphQLField("text", type: .nonNull(.scalar(String.self))),
          GraphQLField("expressions", type: .nonNull(.list(.nonNull(.object(Expression.selections))))),
        ]
      }

      public private(set) var resultMap: ResultMap

      public init(unsafeResultMap: ResultMap) {
        self.resultMap = unsafeResultMap
      }

      public init(text: String, expressions: [Expression]) {
        self.init(unsafeResultMap: ["__typename": "EmbarkResponseExpression", "text": text, "expressions": expressions.map { (value: Expression) -> ResultMap in value.resultMap }])
      }

      public var __typename: String {
        get {
          return resultMap["__typename"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "__typename")
        }
      }

      public var text: String {
        get {
          return resultMap["text"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "text")
        }
      }

      public var expressions: [Expression] {
        get {
          return (resultMap["expressions"] as! [ResultMap]).map { (value: ResultMap) -> Expression in Expression(unsafeResultMap: value) }
        }
        set {
          resultMap.updateValue(newValue.map { (value: Expression) -> ResultMap in value.resultMap }, forKey: "expressions")
        }
      }

      public struct Expression: GraphQLSelectionSet {
        public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

        public static var selections: [GraphQLSelection] {
          return [
            GraphQLTypeCase(
              variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
              default: [
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              ]
            )
          ]
        }

        public private(set) var resultMap: ResultMap

        public init(unsafeResultMap: ResultMap) {
          self.resultMap = unsafeResultMap
        }

        public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> Expression {
          return Expression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
        }

        public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> Expression {
          return Expression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
        }

        public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> Expression {
          return Expression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
        }

        public var __typename: String {
          get {
            return resultMap["__typename"]! as! String
          }
          set {
            resultMap.updateValue(newValue, forKey: "__typename")
          }
        }

        public var fragments: Fragments {
          get {
            return Fragments(unsafeResultMap: resultMap)
          }
          set {
            resultMap += newValue.resultMap
          }
        }

        public struct Fragments {
          public private(set) var resultMap: ResultMap

          public init(unsafeResultMap: ResultMap) {
            self.resultMap = unsafeResultMap
          }

          public var expressionFragment: ExpressionFragment {
            get {
              return ExpressionFragment(unsafeResultMap: resultMap)
            }
            set {
              resultMap += newValue.resultMap
            }
          }

          public var basicExpressionFragment: BasicExpressionFragment {
            get {
              return BasicExpressionFragment(unsafeResultMap: resultMap)
            }
            set {
              resultMap += newValue.resultMap
            }
          }
        }

        public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
          get {
            if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
            return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
          }
          set {
            guard let newValue = newValue else { return }
            resultMap = newValue.resultMap
          }
        }

        public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
          public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

          public static var selections: [GraphQLSelection] {
            return [
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
              GraphQLField("text", type: .scalar(String.self)),
            ]
          }

          public private(set) var resultMap: ResultMap

          public init(unsafeResultMap: ResultMap) {
            self.resultMap = unsafeResultMap
          }

          public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
            self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
          }

          public var __typename: String {
            get {
              return resultMap["__typename"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "__typename")
            }
          }

          public var expressionUnaryType: EmbarkExpressionTypeUnary {
            get {
              return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
            }
            set {
              resultMap.updateValue(newValue, forKey: "expressionUnaryType")
            }
          }

          public var text: String? {
            get {
              return resultMap["text"] as? String
            }
            set {
              resultMap.updateValue(newValue, forKey: "text")
            }
          }

          public var fragments: Fragments {
            get {
              return Fragments(unsafeResultMap: resultMap)
            }
            set {
              resultMap += newValue.resultMap
            }
          }

          public struct Fragments {
            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public var expressionFragment: ExpressionFragment {
              get {
                return ExpressionFragment(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }

            public var basicExpressionFragment: BasicExpressionFragment {
              get {
                return BasicExpressionFragment(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }
          }
        }

        public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
          get {
            if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
            return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
          }
          set {
            guard let newValue = newValue else { return }
            resultMap = newValue.resultMap
          }
        }

        public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
          public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

          public static var selections: [GraphQLSelection] {
            return [
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
              GraphQLField("key", type: .nonNull(.scalar(String.self))),
              GraphQLField("value", type: .nonNull(.scalar(String.self))),
              GraphQLField("text", type: .scalar(String.self)),
            ]
          }

          public private(set) var resultMap: ResultMap

          public init(unsafeResultMap: ResultMap) {
            self.resultMap = unsafeResultMap
          }

          public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
            self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
          }

          public var __typename: String {
            get {
              return resultMap["__typename"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "__typename")
            }
          }

          public var expressionBinaryType: EmbarkExpressionTypeBinary {
            get {
              return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
            }
            set {
              resultMap.updateValue(newValue, forKey: "expressionBinaryType")
            }
          }

          public var key: String {
            get {
              return resultMap["key"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "key")
            }
          }

          public var value: String {
            get {
              return resultMap["value"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "value")
            }
          }

          public var text: String? {
            get {
              return resultMap["text"] as? String
            }
            set {
              resultMap.updateValue(newValue, forKey: "text")
            }
          }

          public var fragments: Fragments {
            get {
              return Fragments(unsafeResultMap: resultMap)
            }
            set {
              resultMap += newValue.resultMap
            }
          }

          public struct Fragments {
            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public var expressionFragment: ExpressionFragment {
              get {
                return ExpressionFragment(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }

            public var basicExpressionFragment: BasicExpressionFragment {
              get {
                return BasicExpressionFragment(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }
          }
        }

        public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
          get {
            if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
            return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
          }
          set {
            guard let newValue = newValue else { return }
            resultMap = newValue.resultMap
          }
        }

        public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
          public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

          public static var selections: [GraphQLSelection] {
            return [
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
              GraphQLField("text", type: .scalar(String.self)),
              GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
            ]
          }

          public private(set) var resultMap: ResultMap

          public init(unsafeResultMap: ResultMap) {
            self.resultMap = unsafeResultMap
          }

          public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
            self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
          }

          public var __typename: String {
            get {
              return resultMap["__typename"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "__typename")
            }
          }

          public var expressionMultipleType: EmbarkExpressionTypeMultiple {
            get {
              return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
            }
            set {
              resultMap.updateValue(newValue, forKey: "expressionMultipleType")
            }
          }

          public var text: String? {
            get {
              return resultMap["text"] as? String
            }
            set {
              resultMap.updateValue(newValue, forKey: "text")
            }
          }

          public var subExpressions: [SubExpression] {
            get {
              return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
            }
            set {
              resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
            }
          }

          public var fragments: Fragments {
            get {
              return Fragments(unsafeResultMap: resultMap)
            }
            set {
              resultMap += newValue.resultMap
            }
          }

          public struct Fragments {
            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public var expressionFragment: ExpressionFragment {
              get {
                return ExpressionFragment(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }

            public var basicExpressionFragment: BasicExpressionFragment {
              get {
                return BasicExpressionFragment(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }
          }

          public struct SubExpression: GraphQLSelectionSet {
            public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

            public static var selections: [GraphQLSelection] {
              return [
                GraphQLTypeCase(
                  variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
                  default: [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  ]
                )
              ]
            }

            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
              return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
            }

            public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
              return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
            }

            public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> SubExpression {
              return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
            }

            public var __typename: String {
              get {
                return resultMap["__typename"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "__typename")
              }
            }

            public var fragments: Fragments {
              get {
                return Fragments(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }

            public struct Fragments {
              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public var basicExpressionFragment: BasicExpressionFragment {
                get {
                  return BasicExpressionFragment(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }
            }

            public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
              get {
                if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap = newValue.resultMap
              }
            }

            public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                  GraphQLField("text", type: .scalar(String.self)),
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var expressionUnaryType: EmbarkExpressionTypeUnary {
                get {
                  return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                }
                set {
                  resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                }
              }

              public var text: String? {
                get {
                  return resultMap["text"] as? String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "text")
                }
              }

              public var fragments: Fragments {
                get {
                  return Fragments(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public struct Fragments {
                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public var basicExpressionFragment: BasicExpressionFragment {
                  get {
                    return BasicExpressionFragment(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }
              }
            }

            public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
              get {
                if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap = newValue.resultMap
              }
            }

            public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                  GraphQLField("key", type: .nonNull(.scalar(String.self))),
                  GraphQLField("value", type: .nonNull(.scalar(String.self))),
                  GraphQLField("text", type: .scalar(String.self)),
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var expressionBinaryType: EmbarkExpressionTypeBinary {
                get {
                  return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                }
                set {
                  resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                }
              }

              public var key: String {
                get {
                  return resultMap["key"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "key")
                }
              }

              public var value: String {
                get {
                  return resultMap["value"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "value")
                }
              }

              public var text: String? {
                get {
                  return resultMap["text"] as? String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "text")
                }
              }

              public var fragments: Fragments {
                get {
                  return Fragments(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public struct Fragments {
                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public var basicExpressionFragment: BasicExpressionFragment {
                  get {
                    return BasicExpressionFragment(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }
              }
            }

            public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
              get {
                if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
                return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap = newValue.resultMap
              }
            }

            public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
                  GraphQLField("text", type: .scalar(String.self)),
                  GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
                self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var expressionMultipleType: EmbarkExpressionTypeMultiple {
                get {
                  return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
                }
                set {
                  resultMap.updateValue(newValue, forKey: "expressionMultipleType")
                }
              }

              public var text: String? {
                get {
                  return resultMap["text"] as? String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "text")
                }
              }

              public var subExpressions: [SubExpression] {
                get {
                  return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
                }
                set {
                  resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
                }
              }

              public var fragments: Fragments {
                get {
                  return Fragments(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public struct Fragments {
                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public var basicExpressionFragment: BasicExpressionFragment {
                  get {
                    return BasicExpressionFragment(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }
              }

              public struct SubExpression: GraphQLSelectionSet {
                public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

                public static var selections: [GraphQLSelection] {
                  return [
                    GraphQLTypeCase(
                      variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
                      default: [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      ]
                    )
                  ]
                }

                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
                  return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                }

                public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
                  return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                }

                public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> SubExpression {
                  return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
                }

                public var __typename: String {
                  get {
                    return resultMap["__typename"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "__typename")
                  }
                }

                public var fragments: Fragments {
                  get {
                    return Fragments(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }

                public struct Fragments {
                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public var basicExpressionFragment: BasicExpressionFragment {
                    get {
                      return BasicExpressionFragment(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }
                }

                public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                  get {
                    if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                    return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                  }
                  set {
                    guard let newValue = newValue else { return }
                    resultMap = newValue.resultMap
                  }
                }

                public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                      GraphQLField("text", type: .scalar(String.self)),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var expressionUnaryType: EmbarkExpressionTypeUnary {
                    get {
                      return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                    }
                  }

                  public var text: String? {
                    get {
                      return resultMap["text"] as? String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "text")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var basicExpressionFragment: BasicExpressionFragment {
                      get {
                        return BasicExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }
                }

                public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                  get {
                    if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                    return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                  }
                  set {
                    guard let newValue = newValue else { return }
                    resultMap = newValue.resultMap
                  }
                }

                public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                      GraphQLField("key", type: .nonNull(.scalar(String.self))),
                      GraphQLField("value", type: .nonNull(.scalar(String.self))),
                      GraphQLField("text", type: .scalar(String.self)),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var expressionBinaryType: EmbarkExpressionTypeBinary {
                    get {
                      return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                    }
                  }

                  public var key: String {
                    get {
                      return resultMap["key"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "key")
                    }
                  }

                  public var value: String {
                    get {
                      return resultMap["value"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "value")
                    }
                  }

                  public var text: String? {
                    get {
                      return resultMap["text"] as? String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "text")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var basicExpressionFragment: BasicExpressionFragment {
                      get {
                        return BasicExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }
                }

                public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
                  get {
                    if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
                    return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
                  }
                  set {
                    guard let newValue = newValue else { return }
                    resultMap = newValue.resultMap
                  }
                }

                public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
                      GraphQLField("text", type: .scalar(String.self)),
                      GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var expressionMultipleType: EmbarkExpressionTypeMultiple {
                    get {
                      return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "expressionMultipleType")
                    }
                  }

                  public var text: String? {
                    get {
                      return resultMap["text"] as? String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "text")
                    }
                  }

                  public var subExpressions: [SubExpression] {
                    get {
                      return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
                    }
                    set {
                      resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var basicExpressionFragment: BasicExpressionFragment {
                      get {
                        return BasicExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }

                  public struct SubExpression: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLTypeCase(
                          variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections],
                          default: [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          ]
                        )
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public static func makeEmbarkExpressionMultiple() -> SubExpression {
                      return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple"])
                    }

                    public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
                      return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                    }

                    public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
                      return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var fragments: Fragments {
                      get {
                        return Fragments(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public struct Fragments {
                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public var basicExpressionFragment: BasicExpressionFragment {
                        get {
                          return BasicExpressionFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }
                    }

                    public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                      get {
                        if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                        return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                      }
                      set {
                        guard let newValue = newValue else { return }
                        resultMap = newValue.resultMap
                      }
                    }

                    public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                      public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                      public static var selections: [GraphQLSelection] {
                        return [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                          GraphQLField("text", type: .scalar(String.self)),
                        ]
                      }

                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                        self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                      }

                      public var __typename: String {
                        get {
                          return resultMap["__typename"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "__typename")
                        }
                      }

                      public var expressionUnaryType: EmbarkExpressionTypeUnary {
                        get {
                          return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                        }
                      }

                      public var text: String? {
                        get {
                          return resultMap["text"] as? String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "text")
                        }
                      }

                      public var fragments: Fragments {
                        get {
                          return Fragments(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public struct Fragments {
                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public var basicExpressionFragment: BasicExpressionFragment {
                          get {
                            return BasicExpressionFragment(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }
                      }
                    }

                    public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                      get {
                        if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                        return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                      }
                      set {
                        guard let newValue = newValue else { return }
                        resultMap = newValue.resultMap
                      }
                    }

                    public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                      public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                      public static var selections: [GraphQLSelection] {
                        return [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                          GraphQLField("key", type: .nonNull(.scalar(String.self))),
                          GraphQLField("value", type: .nonNull(.scalar(String.self))),
                          GraphQLField("text", type: .scalar(String.self)),
                        ]
                      }

                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                        self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                      }

                      public var __typename: String {
                        get {
                          return resultMap["__typename"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "__typename")
                        }
                      }

                      public var expressionBinaryType: EmbarkExpressionTypeBinary {
                        get {
                          return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                        }
                      }

                      public var key: String {
                        get {
                          return resultMap["key"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "key")
                        }
                      }

                      public var value: String {
                        get {
                          return resultMap["value"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "value")
                        }
                      }

                      public var text: String? {
                        get {
                          return resultMap["text"] as? String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "text")
                        }
                      }

                      public var fragments: Fragments {
                        get {
                          return Fragments(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public struct Fragments {
                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public var basicExpressionFragment: BasicExpressionFragment {
                          get {
                            return BasicExpressionFragment(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  struct ApiSingleVariableFragment: GraphQLFragment {
    /// The raw GraphQL definition of this fragment.
    public static let fragmentDefinition: String =
      """
      fragment ApiSingleVariableFragment on EmbarkAPIGraphQLSingleVariable {
        __typename
        key
        from
        as
      }
      """

    public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

    public static var selections: [GraphQLSelection] {
      return [
        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
        GraphQLField("key", type: .nonNull(.scalar(String.self))),
        GraphQLField("from", type: .nonNull(.scalar(String.self))),
        GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
      ]
    }

    public private(set) var resultMap: ResultMap

    public init(unsafeResultMap: ResultMap) {
      self.resultMap = unsafeResultMap
    }

    public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
      self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
    }

    public var __typename: String {
      get {
        return resultMap["__typename"]! as! String
      }
      set {
        resultMap.updateValue(newValue, forKey: "__typename")
      }
    }

    public var key: String {
      get {
        return resultMap["key"]! as! String
      }
      set {
        resultMap.updateValue(newValue, forKey: "key")
      }
    }

    public var from: String {
      get {
        return resultMap["from"]! as! String
      }
      set {
        resultMap.updateValue(newValue, forKey: "from")
      }
    }

    public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
      get {
        return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
      }
      set {
        resultMap.updateValue(newValue, forKey: "as")
      }
    }
  }

  struct ApiGeneratedVariableFragment: GraphQLFragment {
    /// The raw GraphQL definition of this fragment.
    public static let fragmentDefinition: String =
      """
      fragment ApiGeneratedVariableFragment on EmbarkAPIGraphQLGeneratedVariable {
        __typename
        key
        storeAs
        type
      }
      """

    public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

    public static var selections: [GraphQLSelection] {
      return [
        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
        GraphQLField("key", type: .nonNull(.scalar(String.self))),
        GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
        GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
      ]
    }

    public private(set) var resultMap: ResultMap

    public init(unsafeResultMap: ResultMap) {
      self.resultMap = unsafeResultMap
    }

    public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
      self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
    }

    public var __typename: String {
      get {
        return resultMap["__typename"]! as! String
      }
      set {
        resultMap.updateValue(newValue, forKey: "__typename")
      }
    }

    public var key: String {
      get {
        return resultMap["key"]! as! String
      }
      set {
        resultMap.updateValue(newValue, forKey: "key")
      }
    }

    public var storeAs: String {
      get {
        return resultMap["storeAs"]! as! String
      }
      set {
        resultMap.updateValue(newValue, forKey: "storeAs")
      }
    }

    public var type: EmbarkAPIGraphQLVariableGeneratedType {
      get {
        return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
      }
      set {
        resultMap.updateValue(newValue, forKey: "type")
      }
    }
  }

  struct ApiMultiActionVariableFragment: GraphQLFragment {
    /// The raw GraphQL definition of this fragment.
    public static let fragmentDefinition: String =
      """
      fragment ApiMultiActionVariableFragment on EmbarkAPIGraphQLMultiActionVariable {
        __typename
        key
        variables {
          __typename
          ...ApiSingleVariableFragment
          ...ApiGeneratedVariableFragment
          ... on EmbarkAPIGraphQLMultiActionVariable {
            key
            variables {
              __typename
              ...ApiSingleVariableFragment
              ...ApiGeneratedVariableFragment
            }
          }
        }
      }
      """

    public static let possibleTypes: [String] = ["EmbarkAPIGraphQLMultiActionVariable"]

    public static var selections: [GraphQLSelection] {
      return [
        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
        GraphQLField("key", type: .nonNull(.scalar(String.self))),
        GraphQLField("variables", type: .nonNull(.list(.nonNull(.object(Variable.selections))))),
      ]
    }

    public private(set) var resultMap: ResultMap

    public init(unsafeResultMap: ResultMap) {
      self.resultMap = unsafeResultMap
    }

    public init(key: String, variables: [Variable]) {
      self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: Variable) -> ResultMap in value.resultMap }])
    }

    public var __typename: String {
      get {
        return resultMap["__typename"]! as! String
      }
      set {
        resultMap.updateValue(newValue, forKey: "__typename")
      }
    }

    public var key: String {
      get {
        return resultMap["key"]! as! String
      }
      set {
        resultMap.updateValue(newValue, forKey: "key")
      }
    }

    public var variables: [Variable] {
      get {
        return (resultMap["variables"] as! [ResultMap]).map { (value: ResultMap) -> Variable in Variable(unsafeResultMap: value) }
      }
      set {
        resultMap.updateValue(newValue.map { (value: Variable) -> ResultMap in value.resultMap }, forKey: "variables")
      }
    }

    public struct Variable: GraphQLSelectionSet {
      public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable", "EmbarkAPIGraphQLGeneratedVariable", "EmbarkAPIGraphQLMultiActionVariable", "EmbarkAPIGraphQLConstantVariable"]

      public static var selections: [GraphQLSelection] {
        return [
          GraphQLTypeCase(
            variants: ["EmbarkAPIGraphQLSingleVariable": AsEmbarkApiGraphQlSingleVariable.selections, "EmbarkAPIGraphQLGeneratedVariable": AsEmbarkApiGraphQlGeneratedVariable.selections, "EmbarkAPIGraphQLMultiActionVariable": AsEmbarkApiGraphQlMultiActionVariable.selections],
            default: [
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
            ]
          )
        ]
      }

      public private(set) var resultMap: ResultMap

      public init(unsafeResultMap: ResultMap) {
        self.resultMap = unsafeResultMap
      }

      public static func makeEmbarkAPIGraphQLConstantVariable() -> Variable {
        return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLConstantVariable"])
      }

      public static func makeEmbarkAPIGraphQLSingleVariable(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) -> Variable {
        return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
      }

      public static func makeEmbarkAPIGraphQLGeneratedVariable(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) -> Variable {
        return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
      }

      public static func makeEmbarkAPIGraphQLMultiActionVariable(key: String, variables: [AsEmbarkApiGraphQlMultiActionVariable.Variable]) -> Variable {
        return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: AsEmbarkApiGraphQlMultiActionVariable.Variable) -> ResultMap in value.resultMap }])
      }

      public var __typename: String {
        get {
          return resultMap["__typename"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "__typename")
        }
      }

      public var fragments: Fragments {
        get {
          return Fragments(unsafeResultMap: resultMap)
        }
        set {
          resultMap += newValue.resultMap
        }
      }

      public struct Fragments {
        public private(set) var resultMap: ResultMap

        public init(unsafeResultMap: ResultMap) {
          self.resultMap = unsafeResultMap
        }

        public var apiSingleVariableFragment: ApiSingleVariableFragment? {
          get {
            if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
            return ApiSingleVariableFragment(unsafeResultMap: resultMap)
          }
          set {
            guard let newValue = newValue else { return }
            resultMap += newValue.resultMap
          }
        }

        public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
          get {
            if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
            return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
          }
          set {
            guard let newValue = newValue else { return }
            resultMap += newValue.resultMap
          }
        }
      }

      public var asEmbarkApiGraphQlSingleVariable: AsEmbarkApiGraphQlSingleVariable? {
        get {
          if !AsEmbarkApiGraphQlSingleVariable.possibleTypes.contains(__typename) { return nil }
          return AsEmbarkApiGraphQlSingleVariable(unsafeResultMap: resultMap)
        }
        set {
          guard let newValue = newValue else { return }
          resultMap = newValue.resultMap
        }
      }

      public struct AsEmbarkApiGraphQlSingleVariable: GraphQLSelectionSet {
        public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

        public static var selections: [GraphQLSelection] {
          return [
            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
            GraphQLField("key", type: .nonNull(.scalar(String.self))),
            GraphQLField("from", type: .nonNull(.scalar(String.self))),
            GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
          ]
        }

        public private(set) var resultMap: ResultMap

        public init(unsafeResultMap: ResultMap) {
          self.resultMap = unsafeResultMap
        }

        public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
          self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
        }

        public var __typename: String {
          get {
            return resultMap["__typename"]! as! String
          }
          set {
            resultMap.updateValue(newValue, forKey: "__typename")
          }
        }

        public var key: String {
          get {
            return resultMap["key"]! as! String
          }
          set {
            resultMap.updateValue(newValue, forKey: "key")
          }
        }

        public var from: String {
          get {
            return resultMap["from"]! as! String
          }
          set {
            resultMap.updateValue(newValue, forKey: "from")
          }
        }

        public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
          get {
            return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
          }
          set {
            resultMap.updateValue(newValue, forKey: "as")
          }
        }

        public var fragments: Fragments {
          get {
            return Fragments(unsafeResultMap: resultMap)
          }
          set {
            resultMap += newValue.resultMap
          }
        }

        public struct Fragments {
          public private(set) var resultMap: ResultMap

          public init(unsafeResultMap: ResultMap) {
            self.resultMap = unsafeResultMap
          }

          public var apiSingleVariableFragment: ApiSingleVariableFragment {
            get {
              return ApiSingleVariableFragment(unsafeResultMap: resultMap)
            }
            set {
              resultMap += newValue.resultMap
            }
          }

          public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
            get {
              if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
              return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
            }
            set {
              guard let newValue = newValue else { return }
              resultMap += newValue.resultMap
            }
          }
        }
      }

      public var asEmbarkApiGraphQlGeneratedVariable: AsEmbarkApiGraphQlGeneratedVariable? {
        get {
          if !AsEmbarkApiGraphQlGeneratedVariable.possibleTypes.contains(__typename) { return nil }
          return AsEmbarkApiGraphQlGeneratedVariable(unsafeResultMap: resultMap)
        }
        set {
          guard let newValue = newValue else { return }
          resultMap = newValue.resultMap
        }
      }

      public struct AsEmbarkApiGraphQlGeneratedVariable: GraphQLSelectionSet {
        public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

        public static var selections: [GraphQLSelection] {
          return [
            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
            GraphQLField("key", type: .nonNull(.scalar(String.self))),
            GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
            GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
          ]
        }

        public private(set) var resultMap: ResultMap

        public init(unsafeResultMap: ResultMap) {
          self.resultMap = unsafeResultMap
        }

        public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
          self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
        }

        public var __typename: String {
          get {
            return resultMap["__typename"]! as! String
          }
          set {
            resultMap.updateValue(newValue, forKey: "__typename")
          }
        }

        public var key: String {
          get {
            return resultMap["key"]! as! String
          }
          set {
            resultMap.updateValue(newValue, forKey: "key")
          }
        }

        public var storeAs: String {
          get {
            return resultMap["storeAs"]! as! String
          }
          set {
            resultMap.updateValue(newValue, forKey: "storeAs")
          }
        }

        public var type: EmbarkAPIGraphQLVariableGeneratedType {
          get {
            return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
          }
          set {
            resultMap.updateValue(newValue, forKey: "type")
          }
        }

        public var fragments: Fragments {
          get {
            return Fragments(unsafeResultMap: resultMap)
          }
          set {
            resultMap += newValue.resultMap
          }
        }

        public struct Fragments {
          public private(set) var resultMap: ResultMap

          public init(unsafeResultMap: ResultMap) {
            self.resultMap = unsafeResultMap
          }

          public var apiSingleVariableFragment: ApiSingleVariableFragment? {
            get {
              if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
              return ApiSingleVariableFragment(unsafeResultMap: resultMap)
            }
            set {
              guard let newValue = newValue else { return }
              resultMap += newValue.resultMap
            }
          }

          public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment {
            get {
              return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
            }
            set {
              resultMap += newValue.resultMap
            }
          }
        }
      }

      public var asEmbarkApiGraphQlMultiActionVariable: AsEmbarkApiGraphQlMultiActionVariable? {
        get {
          if !AsEmbarkApiGraphQlMultiActionVariable.possibleTypes.contains(__typename) { return nil }
          return AsEmbarkApiGraphQlMultiActionVariable(unsafeResultMap: resultMap)
        }
        set {
          guard let newValue = newValue else { return }
          resultMap = newValue.resultMap
        }
      }

      public struct AsEmbarkApiGraphQlMultiActionVariable: GraphQLSelectionSet {
        public static let possibleTypes: [String] = ["EmbarkAPIGraphQLMultiActionVariable"]

        public static var selections: [GraphQLSelection] {
          return [
            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
            GraphQLField("key", type: .nonNull(.scalar(String.self))),
            GraphQLField("variables", type: .nonNull(.list(.nonNull(.object(Variable.selections))))),
          ]
        }

        public private(set) var resultMap: ResultMap

        public init(unsafeResultMap: ResultMap) {
          self.resultMap = unsafeResultMap
        }

        public init(key: String, variables: [Variable]) {
          self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: Variable) -> ResultMap in value.resultMap }])
        }

        public var __typename: String {
          get {
            return resultMap["__typename"]! as! String
          }
          set {
            resultMap.updateValue(newValue, forKey: "__typename")
          }
        }

        public var key: String {
          get {
            return resultMap["key"]! as! String
          }
          set {
            resultMap.updateValue(newValue, forKey: "key")
          }
        }

        public var variables: [Variable] {
          get {
            return (resultMap["variables"] as! [ResultMap]).map { (value: ResultMap) -> Variable in Variable(unsafeResultMap: value) }
          }
          set {
            resultMap.updateValue(newValue.map { (value: Variable) -> ResultMap in value.resultMap }, forKey: "variables")
          }
        }

        public var fragments: Fragments {
          get {
            return Fragments(unsafeResultMap: resultMap)
          }
          set {
            resultMap += newValue.resultMap
          }
        }

        public struct Fragments {
          public private(set) var resultMap: ResultMap

          public init(unsafeResultMap: ResultMap) {
            self.resultMap = unsafeResultMap
          }

          public var apiSingleVariableFragment: ApiSingleVariableFragment? {
            get {
              if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
              return ApiSingleVariableFragment(unsafeResultMap: resultMap)
            }
            set {
              guard let newValue = newValue else { return }
              resultMap += newValue.resultMap
            }
          }

          public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
            get {
              if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
              return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
            }
            set {
              guard let newValue = newValue else { return }
              resultMap += newValue.resultMap
            }
          }
        }

        public struct Variable: GraphQLSelectionSet {
          public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable", "EmbarkAPIGraphQLGeneratedVariable", "EmbarkAPIGraphQLMultiActionVariable", "EmbarkAPIGraphQLConstantVariable"]

          public static var selections: [GraphQLSelection] {
            return [
              GraphQLTypeCase(
                variants: ["EmbarkAPIGraphQLSingleVariable": AsEmbarkApiGraphQlSingleVariable.selections, "EmbarkAPIGraphQLGeneratedVariable": AsEmbarkApiGraphQlGeneratedVariable.selections],
                default: [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                ]
              )
            ]
          }

          public private(set) var resultMap: ResultMap

          public init(unsafeResultMap: ResultMap) {
            self.resultMap = unsafeResultMap
          }

          public static func makeEmbarkAPIGraphQLMultiActionVariable() -> Variable {
            return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable"])
          }

          public static func makeEmbarkAPIGraphQLConstantVariable() -> Variable {
            return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLConstantVariable"])
          }

          public static func makeEmbarkAPIGraphQLSingleVariable(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) -> Variable {
            return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
          }

          public static func makeEmbarkAPIGraphQLGeneratedVariable(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) -> Variable {
            return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
          }

          public var __typename: String {
            get {
              return resultMap["__typename"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "__typename")
            }
          }

          public var fragments: Fragments {
            get {
              return Fragments(unsafeResultMap: resultMap)
            }
            set {
              resultMap += newValue.resultMap
            }
          }

          public struct Fragments {
            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public var apiSingleVariableFragment: ApiSingleVariableFragment? {
              get {
                if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                return ApiSingleVariableFragment(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap += newValue.resultMap
              }
            }

            public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
              get {
                if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap += newValue.resultMap
              }
            }
          }

          public var asEmbarkApiGraphQlSingleVariable: AsEmbarkApiGraphQlSingleVariable? {
            get {
              if !AsEmbarkApiGraphQlSingleVariable.possibleTypes.contains(__typename) { return nil }
              return AsEmbarkApiGraphQlSingleVariable(unsafeResultMap: resultMap)
            }
            set {
              guard let newValue = newValue else { return }
              resultMap = newValue.resultMap
            }
          }

          public struct AsEmbarkApiGraphQlSingleVariable: GraphQLSelectionSet {
            public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

            public static var selections: [GraphQLSelection] {
              return [
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("key", type: .nonNull(.scalar(String.self))),
                GraphQLField("from", type: .nonNull(.scalar(String.self))),
                GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
              ]
            }

            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
              self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
            }

            public var __typename: String {
              get {
                return resultMap["__typename"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "__typename")
              }
            }

            public var key: String {
              get {
                return resultMap["key"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "key")
              }
            }

            public var from: String {
              get {
                return resultMap["from"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "from")
              }
            }

            public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
              get {
                return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
              }
              set {
                resultMap.updateValue(newValue, forKey: "as")
              }
            }

            public var fragments: Fragments {
              get {
                return Fragments(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }

            public struct Fragments {
              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public var apiSingleVariableFragment: ApiSingleVariableFragment {
                get {
                  return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                get {
                  if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                  return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                }
                set {
                  guard let newValue = newValue else { return }
                  resultMap += newValue.resultMap
                }
              }
            }
          }

          public var asEmbarkApiGraphQlGeneratedVariable: AsEmbarkApiGraphQlGeneratedVariable? {
            get {
              if !AsEmbarkApiGraphQlGeneratedVariable.possibleTypes.contains(__typename) { return nil }
              return AsEmbarkApiGraphQlGeneratedVariable(unsafeResultMap: resultMap)
            }
            set {
              guard let newValue = newValue else { return }
              resultMap = newValue.resultMap
            }
          }

          public struct AsEmbarkApiGraphQlGeneratedVariable: GraphQLSelectionSet {
            public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

            public static var selections: [GraphQLSelection] {
              return [
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("key", type: .nonNull(.scalar(String.self))),
                GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
                GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
              ]
            }

            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
              self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
            }

            public var __typename: String {
              get {
                return resultMap["__typename"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "__typename")
              }
            }

            public var key: String {
              get {
                return resultMap["key"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "key")
              }
            }

            public var storeAs: String {
              get {
                return resultMap["storeAs"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "storeAs")
              }
            }

            public var type: EmbarkAPIGraphQLVariableGeneratedType {
              get {
                return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
              }
              set {
                resultMap.updateValue(newValue, forKey: "type")
              }
            }

            public var fragments: Fragments {
              get {
                return Fragments(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }

            public struct Fragments {
              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                get {
                  if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                  return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                }
                set {
                  guard let newValue = newValue else { return }
                  resultMap += newValue.resultMap
                }
              }

              public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment {
                get {
                  return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }
            }
          }
        }
      }
    }
  }

  struct EmbarkNumberActionFragment: GraphQLFragment {
    /// The raw GraphQL definition of this fragment.
    public static let fragmentDefinition: String =
      """
      fragment EmbarkNumberActionFragment on EmbarkNumberActionData {
        __typename
        key
        placeholder
        unit
        label
        maxValue
        minValue
        link {
          __typename
          ...EmbarkLinkFragment
        }
      }
      """

    public static let possibleTypes: [String] = ["EmbarkNumberActionData"]

    public static var selections: [GraphQLSelection] {
      return [
        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
        GraphQLField("key", type: .nonNull(.scalar(String.self))),
        GraphQLField("placeholder", type: .nonNull(.scalar(String.self))),
        GraphQLField("unit", type: .scalar(String.self)),
        GraphQLField("label", type: .scalar(String.self)),
        GraphQLField("maxValue", type: .scalar(Int.self)),
        GraphQLField("minValue", type: .scalar(Int.self)),
        GraphQLField("link", type: .nonNull(.object(Link.selections))),
      ]
    }

    public private(set) var resultMap: ResultMap

    public init(unsafeResultMap: ResultMap) {
      self.resultMap = unsafeResultMap
    }

    public init(key: String, placeholder: String, unit: String? = nil, label: String? = nil, maxValue: Int? = nil, minValue: Int? = nil, link: Link) {
      self.init(unsafeResultMap: ["__typename": "EmbarkNumberActionData", "key": key, "placeholder": placeholder, "unit": unit, "label": label, "maxValue": maxValue, "minValue": minValue, "link": link.resultMap])
    }

    public var __typename: String {
      get {
        return resultMap["__typename"]! as! String
      }
      set {
        resultMap.updateValue(newValue, forKey: "__typename")
      }
    }

    public var key: String {
      get {
        return resultMap["key"]! as! String
      }
      set {
        resultMap.updateValue(newValue, forKey: "key")
      }
    }

    public var placeholder: String {
      get {
        return resultMap["placeholder"]! as! String
      }
      set {
        resultMap.updateValue(newValue, forKey: "placeholder")
      }
    }

    public var unit: String? {
      get {
        return resultMap["unit"] as? String
      }
      set {
        resultMap.updateValue(newValue, forKey: "unit")
      }
    }

    public var label: String? {
      get {
        return resultMap["label"] as? String
      }
      set {
        resultMap.updateValue(newValue, forKey: "label")
      }
    }

    public var maxValue: Int? {
      get {
        return resultMap["maxValue"] as? Int
      }
      set {
        resultMap.updateValue(newValue, forKey: "maxValue")
      }
    }

    public var minValue: Int? {
      get {
        return resultMap["minValue"] as? Int
      }
      set {
        resultMap.updateValue(newValue, forKey: "minValue")
      }
    }

    public var link: Link {
      get {
        return Link(unsafeResultMap: resultMap["link"]! as! ResultMap)
      }
      set {
        resultMap.updateValue(newValue.resultMap, forKey: "link")
      }
    }

    public struct Link: GraphQLSelectionSet {
      public static let possibleTypes: [String] = ["EmbarkLink"]

      public static var selections: [GraphQLSelection] {
        return [
          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
          GraphQLField("name", type: .nonNull(.scalar(String.self))),
          GraphQLField("label", type: .nonNull(.scalar(String.self))),
        ]
      }

      public private(set) var resultMap: ResultMap

      public init(unsafeResultMap: ResultMap) {
        self.resultMap = unsafeResultMap
      }

      public init(name: String, label: String) {
        self.init(unsafeResultMap: ["__typename": "EmbarkLink", "name": name, "label": label])
      }

      public var __typename: String {
        get {
          return resultMap["__typename"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "__typename")
        }
      }

      public var name: String {
        get {
          return resultMap["name"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "name")
        }
      }

      public var label: String {
        get {
          return resultMap["label"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "label")
        }
      }

      public var fragments: Fragments {
        get {
          return Fragments(unsafeResultMap: resultMap)
        }
        set {
          resultMap += newValue.resultMap
        }
      }

      public struct Fragments {
        public private(set) var resultMap: ResultMap

        public init(unsafeResultMap: ResultMap) {
          self.resultMap = unsafeResultMap
        }

        public var embarkLinkFragment: EmbarkLinkFragment {
          get {
            return EmbarkLinkFragment(unsafeResultMap: resultMap)
          }
          set {
            resultMap += newValue.resultMap
          }
        }
      }
    }
  }

  struct ApiVariablesFragment: GraphQLFragment {
    /// The raw GraphQL definition of this fragment.
    public static let fragmentDefinition: String =
      """
      fragment ApiVariablesFragment on EmbarkAPIGraphQLVariable {
        __typename
        ...ApiSingleVariableFragment
        ...ApiGeneratedVariableFragment
        ...ApiMultiActionVariableFragment
      }
      """

    public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable", "EmbarkAPIGraphQLGeneratedVariable", "EmbarkAPIGraphQLMultiActionVariable", "EmbarkAPIGraphQLConstantVariable"]

    public static var selections: [GraphQLSelection] {
      return [
        GraphQLTypeCase(
          variants: ["EmbarkAPIGraphQLSingleVariable": AsEmbarkApiGraphQlSingleVariable.selections, "EmbarkAPIGraphQLGeneratedVariable": AsEmbarkApiGraphQlGeneratedVariable.selections, "EmbarkAPIGraphQLMultiActionVariable": AsEmbarkApiGraphQlMultiActionVariable.selections],
          default: [
            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
          ]
        )
      ]
    }

    public private(set) var resultMap: ResultMap

    public init(unsafeResultMap: ResultMap) {
      self.resultMap = unsafeResultMap
    }

    public static func makeEmbarkAPIGraphQLConstantVariable() -> ApiVariablesFragment {
      return ApiVariablesFragment(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLConstantVariable"])
    }

    public static func makeEmbarkAPIGraphQLSingleVariable(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) -> ApiVariablesFragment {
      return ApiVariablesFragment(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
    }

    public static func makeEmbarkAPIGraphQLGeneratedVariable(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) -> ApiVariablesFragment {
      return ApiVariablesFragment(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
    }

    public static func makeEmbarkAPIGraphQLMultiActionVariable(key: String, variables: [AsEmbarkApiGraphQlMultiActionVariable.Variable]) -> ApiVariablesFragment {
      return ApiVariablesFragment(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: AsEmbarkApiGraphQlMultiActionVariable.Variable) -> ResultMap in value.resultMap }])
    }

    public var __typename: String {
      get {
        return resultMap["__typename"]! as! String
      }
      set {
        resultMap.updateValue(newValue, forKey: "__typename")
      }
    }

    public var fragments: Fragments {
      get {
        return Fragments(unsafeResultMap: resultMap)
      }
      set {
        resultMap += newValue.resultMap
      }
    }

    public struct Fragments {
      public private(set) var resultMap: ResultMap

      public init(unsafeResultMap: ResultMap) {
        self.resultMap = unsafeResultMap
      }

      public var apiSingleVariableFragment: ApiSingleVariableFragment? {
        get {
          if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
          return ApiSingleVariableFragment(unsafeResultMap: resultMap)
        }
        set {
          guard let newValue = newValue else { return }
          resultMap += newValue.resultMap
        }
      }

      public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
        get {
          if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
          return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
        }
        set {
          guard let newValue = newValue else { return }
          resultMap += newValue.resultMap
        }
      }

      public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment? {
        get {
          if !ApiMultiActionVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
          return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
        }
        set {
          guard let newValue = newValue else { return }
          resultMap += newValue.resultMap
        }
      }
    }

    public var asEmbarkApiGraphQlSingleVariable: AsEmbarkApiGraphQlSingleVariable? {
      get {
        if !AsEmbarkApiGraphQlSingleVariable.possibleTypes.contains(__typename) { return nil }
        return AsEmbarkApiGraphQlSingleVariable(unsafeResultMap: resultMap)
      }
      set {
        guard let newValue = newValue else { return }
        resultMap = newValue.resultMap
      }
    }

    public struct AsEmbarkApiGraphQlSingleVariable: GraphQLSelectionSet {
      public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

      public static var selections: [GraphQLSelection] {
        return [
          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
          GraphQLField("key", type: .nonNull(.scalar(String.self))),
          GraphQLField("from", type: .nonNull(.scalar(String.self))),
          GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
        ]
      }

      public private(set) var resultMap: ResultMap

      public init(unsafeResultMap: ResultMap) {
        self.resultMap = unsafeResultMap
      }

      public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
        self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
      }

      public var __typename: String {
        get {
          return resultMap["__typename"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "__typename")
        }
      }

      public var key: String {
        get {
          return resultMap["key"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "key")
        }
      }

      public var from: String {
        get {
          return resultMap["from"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "from")
        }
      }

      public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
        get {
          return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
        }
        set {
          resultMap.updateValue(newValue, forKey: "as")
        }
      }

      public var fragments: Fragments {
        get {
          return Fragments(unsafeResultMap: resultMap)
        }
        set {
          resultMap += newValue.resultMap
        }
      }

      public struct Fragments {
        public private(set) var resultMap: ResultMap

        public init(unsafeResultMap: ResultMap) {
          self.resultMap = unsafeResultMap
        }

        public var apiSingleVariableFragment: ApiSingleVariableFragment {
          get {
            return ApiSingleVariableFragment(unsafeResultMap: resultMap)
          }
          set {
            resultMap += newValue.resultMap
          }
        }

        public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
          get {
            if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
            return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
          }
          set {
            guard let newValue = newValue else { return }
            resultMap += newValue.resultMap
          }
        }

        public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment? {
          get {
            if !ApiMultiActionVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
            return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
          }
          set {
            guard let newValue = newValue else { return }
            resultMap += newValue.resultMap
          }
        }
      }
    }

    public var asEmbarkApiGraphQlGeneratedVariable: AsEmbarkApiGraphQlGeneratedVariable? {
      get {
        if !AsEmbarkApiGraphQlGeneratedVariable.possibleTypes.contains(__typename) { return nil }
        return AsEmbarkApiGraphQlGeneratedVariable(unsafeResultMap: resultMap)
      }
      set {
        guard let newValue = newValue else { return }
        resultMap = newValue.resultMap
      }
    }

    public struct AsEmbarkApiGraphQlGeneratedVariable: GraphQLSelectionSet {
      public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

      public static var selections: [GraphQLSelection] {
        return [
          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
          GraphQLField("key", type: .nonNull(.scalar(String.self))),
          GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
          GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
        ]
      }

      public private(set) var resultMap: ResultMap

      public init(unsafeResultMap: ResultMap) {
        self.resultMap = unsafeResultMap
      }

      public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
        self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
      }

      public var __typename: String {
        get {
          return resultMap["__typename"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "__typename")
        }
      }

      public var key: String {
        get {
          return resultMap["key"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "key")
        }
      }

      public var storeAs: String {
        get {
          return resultMap["storeAs"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "storeAs")
        }
      }

      public var type: EmbarkAPIGraphQLVariableGeneratedType {
        get {
          return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
        }
        set {
          resultMap.updateValue(newValue, forKey: "type")
        }
      }

      public var fragments: Fragments {
        get {
          return Fragments(unsafeResultMap: resultMap)
        }
        set {
          resultMap += newValue.resultMap
        }
      }

      public struct Fragments {
        public private(set) var resultMap: ResultMap

        public init(unsafeResultMap: ResultMap) {
          self.resultMap = unsafeResultMap
        }

        public var apiSingleVariableFragment: ApiSingleVariableFragment? {
          get {
            if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
            return ApiSingleVariableFragment(unsafeResultMap: resultMap)
          }
          set {
            guard let newValue = newValue else { return }
            resultMap += newValue.resultMap
          }
        }

        public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment {
          get {
            return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
          }
          set {
            resultMap += newValue.resultMap
          }
        }

        public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment? {
          get {
            if !ApiMultiActionVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
            return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
          }
          set {
            guard let newValue = newValue else { return }
            resultMap += newValue.resultMap
          }
        }
      }
    }

    public var asEmbarkApiGraphQlMultiActionVariable: AsEmbarkApiGraphQlMultiActionVariable? {
      get {
        if !AsEmbarkApiGraphQlMultiActionVariable.possibleTypes.contains(__typename) { return nil }
        return AsEmbarkApiGraphQlMultiActionVariable(unsafeResultMap: resultMap)
      }
      set {
        guard let newValue = newValue else { return }
        resultMap = newValue.resultMap
      }
    }

    public struct AsEmbarkApiGraphQlMultiActionVariable: GraphQLSelectionSet {
      public static let possibleTypes: [String] = ["EmbarkAPIGraphQLMultiActionVariable"]

      public static var selections: [GraphQLSelection] {
        return [
          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
          GraphQLField("key", type: .nonNull(.scalar(String.self))),
          GraphQLField("variables", type: .nonNull(.list(.nonNull(.object(Variable.selections))))),
        ]
      }

      public private(set) var resultMap: ResultMap

      public init(unsafeResultMap: ResultMap) {
        self.resultMap = unsafeResultMap
      }

      public init(key: String, variables: [Variable]) {
        self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: Variable) -> ResultMap in value.resultMap }])
      }

      public var __typename: String {
        get {
          return resultMap["__typename"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "__typename")
        }
      }

      public var key: String {
        get {
          return resultMap["key"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "key")
        }
      }

      public var variables: [Variable] {
        get {
          return (resultMap["variables"] as! [ResultMap]).map { (value: ResultMap) -> Variable in Variable(unsafeResultMap: value) }
        }
        set {
          resultMap.updateValue(newValue.map { (value: Variable) -> ResultMap in value.resultMap }, forKey: "variables")
        }
      }

      public var fragments: Fragments {
        get {
          return Fragments(unsafeResultMap: resultMap)
        }
        set {
          resultMap += newValue.resultMap
        }
      }

      public struct Fragments {
        public private(set) var resultMap: ResultMap

        public init(unsafeResultMap: ResultMap) {
          self.resultMap = unsafeResultMap
        }

        public var apiSingleVariableFragment: ApiSingleVariableFragment? {
          get {
            if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
            return ApiSingleVariableFragment(unsafeResultMap: resultMap)
          }
          set {
            guard let newValue = newValue else { return }
            resultMap += newValue.resultMap
          }
        }

        public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
          get {
            if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
            return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
          }
          set {
            guard let newValue = newValue else { return }
            resultMap += newValue.resultMap
          }
        }

        public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment {
          get {
            return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
          }
          set {
            resultMap += newValue.resultMap
          }
        }
      }

      public struct Variable: GraphQLSelectionSet {
        public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable", "EmbarkAPIGraphQLGeneratedVariable", "EmbarkAPIGraphQLMultiActionVariable", "EmbarkAPIGraphQLConstantVariable"]

        public static var selections: [GraphQLSelection] {
          return [
            GraphQLTypeCase(
              variants: ["EmbarkAPIGraphQLSingleVariable": AsEmbarkApiGraphQlSingleVariable.selections, "EmbarkAPIGraphQLGeneratedVariable": AsEmbarkApiGraphQlGeneratedVariable.selections, "EmbarkAPIGraphQLMultiActionVariable": AsEmbarkApiGraphQlMultiActionVariable.selections],
              default: [
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              ]
            )
          ]
        }

        public private(set) var resultMap: ResultMap

        public init(unsafeResultMap: ResultMap) {
          self.resultMap = unsafeResultMap
        }

        public static func makeEmbarkAPIGraphQLConstantVariable() -> Variable {
          return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLConstantVariable"])
        }

        public static func makeEmbarkAPIGraphQLSingleVariable(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) -> Variable {
          return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
        }

        public static func makeEmbarkAPIGraphQLGeneratedVariable(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) -> Variable {
          return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
        }

        public static func makeEmbarkAPIGraphQLMultiActionVariable(key: String, variables: [AsEmbarkApiGraphQlMultiActionVariable.Variable]) -> Variable {
          return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: AsEmbarkApiGraphQlMultiActionVariable.Variable) -> ResultMap in value.resultMap }])
        }

        public var __typename: String {
          get {
            return resultMap["__typename"]! as! String
          }
          set {
            resultMap.updateValue(newValue, forKey: "__typename")
          }
        }

        public var fragments: Fragments {
          get {
            return Fragments(unsafeResultMap: resultMap)
          }
          set {
            resultMap += newValue.resultMap
          }
        }

        public struct Fragments {
          public private(set) var resultMap: ResultMap

          public init(unsafeResultMap: ResultMap) {
            self.resultMap = unsafeResultMap
          }

          public var apiSingleVariableFragment: ApiSingleVariableFragment? {
            get {
              if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
              return ApiSingleVariableFragment(unsafeResultMap: resultMap)
            }
            set {
              guard let newValue = newValue else { return }
              resultMap += newValue.resultMap
            }
          }

          public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
            get {
              if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
              return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
            }
            set {
              guard let newValue = newValue else { return }
              resultMap += newValue.resultMap
            }
          }
        }

        public var asEmbarkApiGraphQlSingleVariable: AsEmbarkApiGraphQlSingleVariable? {
          get {
            if !AsEmbarkApiGraphQlSingleVariable.possibleTypes.contains(__typename) { return nil }
            return AsEmbarkApiGraphQlSingleVariable(unsafeResultMap: resultMap)
          }
          set {
            guard let newValue = newValue else { return }
            resultMap = newValue.resultMap
          }
        }

        public struct AsEmbarkApiGraphQlSingleVariable: GraphQLSelectionSet {
          public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

          public static var selections: [GraphQLSelection] {
            return [
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("key", type: .nonNull(.scalar(String.self))),
              GraphQLField("from", type: .nonNull(.scalar(String.self))),
              GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
            ]
          }

          public private(set) var resultMap: ResultMap

          public init(unsafeResultMap: ResultMap) {
            self.resultMap = unsafeResultMap
          }

          public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
            self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
          }

          public var __typename: String {
            get {
              return resultMap["__typename"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "__typename")
            }
          }

          public var key: String {
            get {
              return resultMap["key"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "key")
            }
          }

          public var from: String {
            get {
              return resultMap["from"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "from")
            }
          }

          public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
            get {
              return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
            }
            set {
              resultMap.updateValue(newValue, forKey: "as")
            }
          }

          public var fragments: Fragments {
            get {
              return Fragments(unsafeResultMap: resultMap)
            }
            set {
              resultMap += newValue.resultMap
            }
          }

          public struct Fragments {
            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public var apiSingleVariableFragment: ApiSingleVariableFragment {
              get {
                return ApiSingleVariableFragment(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }

            public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
              get {
                if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap += newValue.resultMap
              }
            }
          }
        }

        public var asEmbarkApiGraphQlGeneratedVariable: AsEmbarkApiGraphQlGeneratedVariable? {
          get {
            if !AsEmbarkApiGraphQlGeneratedVariable.possibleTypes.contains(__typename) { return nil }
            return AsEmbarkApiGraphQlGeneratedVariable(unsafeResultMap: resultMap)
          }
          set {
            guard let newValue = newValue else { return }
            resultMap = newValue.resultMap
          }
        }

        public struct AsEmbarkApiGraphQlGeneratedVariable: GraphQLSelectionSet {
          public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

          public static var selections: [GraphQLSelection] {
            return [
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("key", type: .nonNull(.scalar(String.self))),
              GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
              GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
            ]
          }

          public private(set) var resultMap: ResultMap

          public init(unsafeResultMap: ResultMap) {
            self.resultMap = unsafeResultMap
          }

          public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
            self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
          }

          public var __typename: String {
            get {
              return resultMap["__typename"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "__typename")
            }
          }

          public var key: String {
            get {
              return resultMap["key"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "key")
            }
          }

          public var storeAs: String {
            get {
              return resultMap["storeAs"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "storeAs")
            }
          }

          public var type: EmbarkAPIGraphQLVariableGeneratedType {
            get {
              return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
            }
            set {
              resultMap.updateValue(newValue, forKey: "type")
            }
          }

          public var fragments: Fragments {
            get {
              return Fragments(unsafeResultMap: resultMap)
            }
            set {
              resultMap += newValue.resultMap
            }
          }

          public struct Fragments {
            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public var apiSingleVariableFragment: ApiSingleVariableFragment? {
              get {
                if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                return ApiSingleVariableFragment(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap += newValue.resultMap
              }
            }

            public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment {
              get {
                return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }
          }
        }

        public var asEmbarkApiGraphQlMultiActionVariable: AsEmbarkApiGraphQlMultiActionVariable? {
          get {
            if !AsEmbarkApiGraphQlMultiActionVariable.possibleTypes.contains(__typename) { return nil }
            return AsEmbarkApiGraphQlMultiActionVariable(unsafeResultMap: resultMap)
          }
          set {
            guard let newValue = newValue else { return }
            resultMap = newValue.resultMap
          }
        }

        public struct AsEmbarkApiGraphQlMultiActionVariable: GraphQLSelectionSet {
          public static let possibleTypes: [String] = ["EmbarkAPIGraphQLMultiActionVariable"]

          public static var selections: [GraphQLSelection] {
            return [
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("key", type: .nonNull(.scalar(String.self))),
              GraphQLField("variables", type: .nonNull(.list(.nonNull(.object(Variable.selections))))),
            ]
          }

          public private(set) var resultMap: ResultMap

          public init(unsafeResultMap: ResultMap) {
            self.resultMap = unsafeResultMap
          }

          public init(key: String, variables: [Variable]) {
            self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: Variable) -> ResultMap in value.resultMap }])
          }

          public var __typename: String {
            get {
              return resultMap["__typename"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "__typename")
            }
          }

          public var key: String {
            get {
              return resultMap["key"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "key")
            }
          }

          public var variables: [Variable] {
            get {
              return (resultMap["variables"] as! [ResultMap]).map { (value: ResultMap) -> Variable in Variable(unsafeResultMap: value) }
            }
            set {
              resultMap.updateValue(newValue.map { (value: Variable) -> ResultMap in value.resultMap }, forKey: "variables")
            }
          }

          public var fragments: Fragments {
            get {
              return Fragments(unsafeResultMap: resultMap)
            }
            set {
              resultMap += newValue.resultMap
            }
          }

          public struct Fragments {
            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public var apiSingleVariableFragment: ApiSingleVariableFragment? {
              get {
                if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                return ApiSingleVariableFragment(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap += newValue.resultMap
              }
            }

            public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
              get {
                if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap += newValue.resultMap
              }
            }
          }

          public struct Variable: GraphQLSelectionSet {
            public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable", "EmbarkAPIGraphQLGeneratedVariable", "EmbarkAPIGraphQLMultiActionVariable", "EmbarkAPIGraphQLConstantVariable"]

            public static var selections: [GraphQLSelection] {
              return [
                GraphQLTypeCase(
                  variants: ["EmbarkAPIGraphQLSingleVariable": AsEmbarkApiGraphQlSingleVariable.selections, "EmbarkAPIGraphQLGeneratedVariable": AsEmbarkApiGraphQlGeneratedVariable.selections],
                  default: [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  ]
                )
              ]
            }

            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public static func makeEmbarkAPIGraphQLMultiActionVariable() -> Variable {
              return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable"])
            }

            public static func makeEmbarkAPIGraphQLConstantVariable() -> Variable {
              return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLConstantVariable"])
            }

            public static func makeEmbarkAPIGraphQLSingleVariable(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) -> Variable {
              return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
            }

            public static func makeEmbarkAPIGraphQLGeneratedVariable(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) -> Variable {
              return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
            }

            public var __typename: String {
              get {
                return resultMap["__typename"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "__typename")
              }
            }

            public var fragments: Fragments {
              get {
                return Fragments(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }

            public struct Fragments {
              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                get {
                  if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                  return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                }
                set {
                  guard let newValue = newValue else { return }
                  resultMap += newValue.resultMap
                }
              }

              public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                get {
                  if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                  return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                }
                set {
                  guard let newValue = newValue else { return }
                  resultMap += newValue.resultMap
                }
              }
            }

            public var asEmbarkApiGraphQlSingleVariable: AsEmbarkApiGraphQlSingleVariable? {
              get {
                if !AsEmbarkApiGraphQlSingleVariable.possibleTypes.contains(__typename) { return nil }
                return AsEmbarkApiGraphQlSingleVariable(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap = newValue.resultMap
              }
            }

            public struct AsEmbarkApiGraphQlSingleVariable: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("key", type: .nonNull(.scalar(String.self))),
                  GraphQLField("from", type: .nonNull(.scalar(String.self))),
                  GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
                self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var key: String {
                get {
                  return resultMap["key"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "key")
                }
              }

              public var from: String {
                get {
                  return resultMap["from"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "from")
                }
              }

              public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
                get {
                  return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
                }
                set {
                  resultMap.updateValue(newValue, forKey: "as")
                }
              }

              public var fragments: Fragments {
                get {
                  return Fragments(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public struct Fragments {
                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public var apiSingleVariableFragment: ApiSingleVariableFragment {
                  get {
                    return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }

                public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                  get {
                    if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                    return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                  }
                  set {
                    guard let newValue = newValue else { return }
                    resultMap += newValue.resultMap
                  }
                }
              }
            }

            public var asEmbarkApiGraphQlGeneratedVariable: AsEmbarkApiGraphQlGeneratedVariable? {
              get {
                if !AsEmbarkApiGraphQlGeneratedVariable.possibleTypes.contains(__typename) { return nil }
                return AsEmbarkApiGraphQlGeneratedVariable(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap = newValue.resultMap
              }
            }

            public struct AsEmbarkApiGraphQlGeneratedVariable: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("key", type: .nonNull(.scalar(String.self))),
                  GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
                  GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
                self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var key: String {
                get {
                  return resultMap["key"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "key")
                }
              }

              public var storeAs: String {
                get {
                  return resultMap["storeAs"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "storeAs")
                }
              }

              public var type: EmbarkAPIGraphQLVariableGeneratedType {
                get {
                  return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
                }
                set {
                  resultMap.updateValue(newValue, forKey: "type")
                }
              }

              public var fragments: Fragments {
                get {
                  return Fragments(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public struct Fragments {
                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                  get {
                    if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                    return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                  }
                  set {
                    guard let newValue = newValue else { return }
                    resultMap += newValue.resultMap
                  }
                }

                public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment {
                  get {
                    return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  struct ApiFragment: GraphQLFragment {
    /// The raw GraphQL definition of this fragment.
    public static let fragmentDefinition: String =
      """
      fragment ApiFragment on EmbarkApi {
        __typename
        ... on EmbarkApiGraphQLQuery {
          data {
            __typename
            next {
              __typename
              ...EmbarkLinkFragment
            }
            query
            variables {
              __typename
              ...ApiVariablesFragment
            }
            queryResults: results {
              __typename
              key
              as
            }
            queryErrors: errors {
              __typename
              contains
              next {
                __typename
                ...EmbarkLinkFragment
              }
            }
          }
        }
        ... on EmbarkApiGraphQLMutation {
          data {
            __typename
            next {
              __typename
              ...EmbarkLinkFragment
            }
            mutation
            variables {
              __typename
              ...ApiVariablesFragment
            }
            mutationResults: results {
              __typename
              key
              as
            }
            mutationErrors: errors {
              __typename
              contains
              next {
                __typename
                ...EmbarkLinkFragment
              }
            }
          }
        }
      }
      """

    public static let possibleTypes: [String] = ["EmbarkApiPersonalInformation", "EmbarkApiHouseInformation", "EmbarkApiCreateQuote", "EmbarkApiGraphQLQuery", "EmbarkApiGraphQLMutation"]

    public static var selections: [GraphQLSelection] {
      return [
        GraphQLTypeCase(
          variants: ["EmbarkApiGraphQLQuery": AsEmbarkApiGraphQlQuery.selections, "EmbarkApiGraphQLMutation": AsEmbarkApiGraphQlMutation.selections],
          default: [
            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
          ]
        )
      ]
    }

    public private(set) var resultMap: ResultMap

    public init(unsafeResultMap: ResultMap) {
      self.resultMap = unsafeResultMap
    }

    public static func makeEmbarkApiPersonalInformation() -> ApiFragment {
      return ApiFragment(unsafeResultMap: ["__typename": "EmbarkApiPersonalInformation"])
    }

    public static func makeEmbarkApiHouseInformation() -> ApiFragment {
      return ApiFragment(unsafeResultMap: ["__typename": "EmbarkApiHouseInformation"])
    }

    public static func makeEmbarkApiCreateQuote() -> ApiFragment {
      return ApiFragment(unsafeResultMap: ["__typename": "EmbarkApiCreateQuote"])
    }

    public static func makeEmbarkApiGraphQLQuery(data: AsEmbarkApiGraphQlQuery.Datum) -> ApiFragment {
      return ApiFragment(unsafeResultMap: ["__typename": "EmbarkApiGraphQLQuery", "data": data.resultMap])
    }

    public static func makeEmbarkApiGraphQLMutation(data: AsEmbarkApiGraphQlMutation.Datum) -> ApiFragment {
      return ApiFragment(unsafeResultMap: ["__typename": "EmbarkApiGraphQLMutation", "data": data.resultMap])
    }

    public var __typename: String {
      get {
        return resultMap["__typename"]! as! String
      }
      set {
        resultMap.updateValue(newValue, forKey: "__typename")
      }
    }

    public var asEmbarkApiGraphQlQuery: AsEmbarkApiGraphQlQuery? {
      get {
        if !AsEmbarkApiGraphQlQuery.possibleTypes.contains(__typename) { return nil }
        return AsEmbarkApiGraphQlQuery(unsafeResultMap: resultMap)
      }
      set {
        guard let newValue = newValue else { return }
        resultMap = newValue.resultMap
      }
    }

    public struct AsEmbarkApiGraphQlQuery: GraphQLSelectionSet {
      public static let possibleTypes: [String] = ["EmbarkApiGraphQLQuery"]

      public static var selections: [GraphQLSelection] {
        return [
          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
          GraphQLField("data", type: .nonNull(.object(Datum.selections))),
        ]
      }

      public private(set) var resultMap: ResultMap

      public init(unsafeResultMap: ResultMap) {
        self.resultMap = unsafeResultMap
      }

      public init(data: Datum) {
        self.init(unsafeResultMap: ["__typename": "EmbarkApiGraphQLQuery", "data": data.resultMap])
      }

      public var __typename: String {
        get {
          return resultMap["__typename"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "__typename")
        }
      }

      public var data: Datum {
        get {
          return Datum(unsafeResultMap: resultMap["data"]! as! ResultMap)
        }
        set {
          resultMap.updateValue(newValue.resultMap, forKey: "data")
        }
      }

      public struct Datum: GraphQLSelectionSet {
        public static let possibleTypes: [String] = ["EmbarkApiGraphQLQueryData"]

        public static var selections: [GraphQLSelection] {
          return [
            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
            GraphQLField("next", type: .object(Next.selections)),
            GraphQLField("query", type: .nonNull(.scalar(String.self))),
            GraphQLField("variables", type: .nonNull(.list(.nonNull(.object(Variable.selections))))),
            GraphQLField("results", alias: "queryResults", type: .nonNull(.list(.nonNull(.object(QueryResult.selections))))),
            GraphQLField("errors", alias: "queryErrors", type: .nonNull(.list(.nonNull(.object(QueryError.selections))))),
          ]
        }

        public private(set) var resultMap: ResultMap

        public init(unsafeResultMap: ResultMap) {
          self.resultMap = unsafeResultMap
        }

        public init(next: Next? = nil, query: String, variables: [Variable], queryResults: [QueryResult], queryErrors: [QueryError]) {
          self.init(unsafeResultMap: ["__typename": "EmbarkApiGraphQLQueryData", "next": next.flatMap { (value: Next) -> ResultMap in value.resultMap }, "query": query, "variables": variables.map { (value: Variable) -> ResultMap in value.resultMap }, "queryResults": queryResults.map { (value: QueryResult) -> ResultMap in value.resultMap }, "queryErrors": queryErrors.map { (value: QueryError) -> ResultMap in value.resultMap }])
        }

        public var __typename: String {
          get {
            return resultMap["__typename"]! as! String
          }
          set {
            resultMap.updateValue(newValue, forKey: "__typename")
          }
        }

        public var next: Next? {
          get {
            return (resultMap["next"] as? ResultMap).flatMap { Next(unsafeResultMap: $0) }
          }
          set {
            resultMap.updateValue(newValue?.resultMap, forKey: "next")
          }
        }

        public var query: String {
          get {
            return resultMap["query"]! as! String
          }
          set {
            resultMap.updateValue(newValue, forKey: "query")
          }
        }

        public var variables: [Variable] {
          get {
            return (resultMap["variables"] as! [ResultMap]).map { (value: ResultMap) -> Variable in Variable(unsafeResultMap: value) }
          }
          set {
            resultMap.updateValue(newValue.map { (value: Variable) -> ResultMap in value.resultMap }, forKey: "variables")
          }
        }

        public var queryResults: [QueryResult] {
          get {
            return (resultMap["queryResults"] as! [ResultMap]).map { (value: ResultMap) -> QueryResult in QueryResult(unsafeResultMap: value) }
          }
          set {
            resultMap.updateValue(newValue.map { (value: QueryResult) -> ResultMap in value.resultMap }, forKey: "queryResults")
          }
        }

        public var queryErrors: [QueryError] {
          get {
            return (resultMap["queryErrors"] as! [ResultMap]).map { (value: ResultMap) -> QueryError in QueryError(unsafeResultMap: value) }
          }
          set {
            resultMap.updateValue(newValue.map { (value: QueryError) -> ResultMap in value.resultMap }, forKey: "queryErrors")
          }
        }

        public struct Next: GraphQLSelectionSet {
          public static let possibleTypes: [String] = ["EmbarkLink"]

          public static var selections: [GraphQLSelection] {
            return [
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("name", type: .nonNull(.scalar(String.self))),
              GraphQLField("label", type: .nonNull(.scalar(String.self))),
            ]
          }

          public private(set) var resultMap: ResultMap

          public init(unsafeResultMap: ResultMap) {
            self.resultMap = unsafeResultMap
          }

          public init(name: String, label: String) {
            self.init(unsafeResultMap: ["__typename": "EmbarkLink", "name": name, "label": label])
          }

          public var __typename: String {
            get {
              return resultMap["__typename"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "__typename")
            }
          }

          public var name: String {
            get {
              return resultMap["name"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "name")
            }
          }

          public var label: String {
            get {
              return resultMap["label"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "label")
            }
          }

          public var fragments: Fragments {
            get {
              return Fragments(unsafeResultMap: resultMap)
            }
            set {
              resultMap += newValue.resultMap
            }
          }

          public struct Fragments {
            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public var embarkLinkFragment: EmbarkLinkFragment {
              get {
                return EmbarkLinkFragment(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }
          }
        }

        public struct Variable: GraphQLSelectionSet {
          public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable", "EmbarkAPIGraphQLGeneratedVariable", "EmbarkAPIGraphQLMultiActionVariable", "EmbarkAPIGraphQLConstantVariable"]

          public static var selections: [GraphQLSelection] {
            return [
              GraphQLTypeCase(
                variants: ["EmbarkAPIGraphQLSingleVariable": AsEmbarkApiGraphQlSingleVariable.selections, "EmbarkAPIGraphQLGeneratedVariable": AsEmbarkApiGraphQlGeneratedVariable.selections, "EmbarkAPIGraphQLMultiActionVariable": AsEmbarkApiGraphQlMultiActionVariable.selections],
                default: [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                ]
              )
            ]
          }

          public private(set) var resultMap: ResultMap

          public init(unsafeResultMap: ResultMap) {
            self.resultMap = unsafeResultMap
          }

          public static func makeEmbarkAPIGraphQLConstantVariable() -> Variable {
            return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLConstantVariable"])
          }

          public static func makeEmbarkAPIGraphQLSingleVariable(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) -> Variable {
            return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
          }

          public static func makeEmbarkAPIGraphQLGeneratedVariable(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) -> Variable {
            return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
          }

          public static func makeEmbarkAPIGraphQLMultiActionVariable(key: String, variables: [AsEmbarkApiGraphQlMultiActionVariable.Variable]) -> Variable {
            return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: AsEmbarkApiGraphQlMultiActionVariable.Variable) -> ResultMap in value.resultMap }])
          }

          public var __typename: String {
            get {
              return resultMap["__typename"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "__typename")
            }
          }

          public var fragments: Fragments {
            get {
              return Fragments(unsafeResultMap: resultMap)
            }
            set {
              resultMap += newValue.resultMap
            }
          }

          public struct Fragments {
            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public var apiVariablesFragment: ApiVariablesFragment {
              get {
                return ApiVariablesFragment(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }

            public var apiSingleVariableFragment: ApiSingleVariableFragment? {
              get {
                if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                return ApiSingleVariableFragment(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap += newValue.resultMap
              }
            }

            public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
              get {
                if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap += newValue.resultMap
              }
            }

            public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment? {
              get {
                if !ApiMultiActionVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap += newValue.resultMap
              }
            }
          }

          public var asEmbarkApiGraphQlSingleVariable: AsEmbarkApiGraphQlSingleVariable? {
            get {
              if !AsEmbarkApiGraphQlSingleVariable.possibleTypes.contains(__typename) { return nil }
              return AsEmbarkApiGraphQlSingleVariable(unsafeResultMap: resultMap)
            }
            set {
              guard let newValue = newValue else { return }
              resultMap = newValue.resultMap
            }
          }

          public struct AsEmbarkApiGraphQlSingleVariable: GraphQLSelectionSet {
            public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

            public static var selections: [GraphQLSelection] {
              return [
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("key", type: .nonNull(.scalar(String.self))),
                GraphQLField("from", type: .nonNull(.scalar(String.self))),
                GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
              ]
            }

            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
              self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
            }

            public var __typename: String {
              get {
                return resultMap["__typename"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "__typename")
              }
            }

            public var key: String {
              get {
                return resultMap["key"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "key")
              }
            }

            public var from: String {
              get {
                return resultMap["from"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "from")
              }
            }

            public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
              get {
                return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
              }
              set {
                resultMap.updateValue(newValue, forKey: "as")
              }
            }

            public var fragments: Fragments {
              get {
                return Fragments(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }

            public struct Fragments {
              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public var apiVariablesFragment: ApiVariablesFragment {
                get {
                  return ApiVariablesFragment(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public var apiSingleVariableFragment: ApiSingleVariableFragment {
                get {
                  return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                get {
                  if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                  return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                }
                set {
                  guard let newValue = newValue else { return }
                  resultMap += newValue.resultMap
                }
              }

              public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment? {
                get {
                  if !ApiMultiActionVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                  return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                }
                set {
                  guard let newValue = newValue else { return }
                  resultMap += newValue.resultMap
                }
              }
            }
          }

          public var asEmbarkApiGraphQlGeneratedVariable: AsEmbarkApiGraphQlGeneratedVariable? {
            get {
              if !AsEmbarkApiGraphQlGeneratedVariable.possibleTypes.contains(__typename) { return nil }
              return AsEmbarkApiGraphQlGeneratedVariable(unsafeResultMap: resultMap)
            }
            set {
              guard let newValue = newValue else { return }
              resultMap = newValue.resultMap
            }
          }

          public struct AsEmbarkApiGraphQlGeneratedVariable: GraphQLSelectionSet {
            public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

            public static var selections: [GraphQLSelection] {
              return [
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("key", type: .nonNull(.scalar(String.self))),
                GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
                GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
              ]
            }

            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
              self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
            }

            public var __typename: String {
              get {
                return resultMap["__typename"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "__typename")
              }
            }

            public var key: String {
              get {
                return resultMap["key"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "key")
              }
            }

            public var storeAs: String {
              get {
                return resultMap["storeAs"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "storeAs")
              }
            }

            public var type: EmbarkAPIGraphQLVariableGeneratedType {
              get {
                return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
              }
              set {
                resultMap.updateValue(newValue, forKey: "type")
              }
            }

            public var fragments: Fragments {
              get {
                return Fragments(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }

            public struct Fragments {
              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public var apiVariablesFragment: ApiVariablesFragment {
                get {
                  return ApiVariablesFragment(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                get {
                  if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                  return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                }
                set {
                  guard let newValue = newValue else { return }
                  resultMap += newValue.resultMap
                }
              }

              public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment {
                get {
                  return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment? {
                get {
                  if !ApiMultiActionVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                  return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                }
                set {
                  guard let newValue = newValue else { return }
                  resultMap += newValue.resultMap
                }
              }
            }
          }

          public var asEmbarkApiGraphQlMultiActionVariable: AsEmbarkApiGraphQlMultiActionVariable? {
            get {
              if !AsEmbarkApiGraphQlMultiActionVariable.possibleTypes.contains(__typename) { return nil }
              return AsEmbarkApiGraphQlMultiActionVariable(unsafeResultMap: resultMap)
            }
            set {
              guard let newValue = newValue else { return }
              resultMap = newValue.resultMap
            }
          }

          public struct AsEmbarkApiGraphQlMultiActionVariable: GraphQLSelectionSet {
            public static let possibleTypes: [String] = ["EmbarkAPIGraphQLMultiActionVariable"]

            public static var selections: [GraphQLSelection] {
              return [
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("key", type: .nonNull(.scalar(String.self))),
                GraphQLField("variables", type: .nonNull(.list(.nonNull(.object(Variable.selections))))),
              ]
            }

            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public init(key: String, variables: [Variable]) {
              self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: Variable) -> ResultMap in value.resultMap }])
            }

            public var __typename: String {
              get {
                return resultMap["__typename"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "__typename")
              }
            }

            public var key: String {
              get {
                return resultMap["key"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "key")
              }
            }

            public var variables: [Variable] {
              get {
                return (resultMap["variables"] as! [ResultMap]).map { (value: ResultMap) -> Variable in Variable(unsafeResultMap: value) }
              }
              set {
                resultMap.updateValue(newValue.map { (value: Variable) -> ResultMap in value.resultMap }, forKey: "variables")
              }
            }

            public var fragments: Fragments {
              get {
                return Fragments(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }

            public struct Fragments {
              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public var apiVariablesFragment: ApiVariablesFragment {
                get {
                  return ApiVariablesFragment(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                get {
                  if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                  return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                }
                set {
                  guard let newValue = newValue else { return }
                  resultMap += newValue.resultMap
                }
              }

              public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                get {
                  if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                  return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                }
                set {
                  guard let newValue = newValue else { return }
                  resultMap += newValue.resultMap
                }
              }

              public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment {
                get {
                  return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }
            }

            public struct Variable: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable", "EmbarkAPIGraphQLGeneratedVariable", "EmbarkAPIGraphQLMultiActionVariable", "EmbarkAPIGraphQLConstantVariable"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLTypeCase(
                    variants: ["EmbarkAPIGraphQLSingleVariable": AsEmbarkApiGraphQlSingleVariable.selections, "EmbarkAPIGraphQLGeneratedVariable": AsEmbarkApiGraphQlGeneratedVariable.selections, "EmbarkAPIGraphQLMultiActionVariable": AsEmbarkApiGraphQlMultiActionVariable.selections],
                    default: [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    ]
                  )
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public static func makeEmbarkAPIGraphQLConstantVariable() -> Variable {
                return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLConstantVariable"])
              }

              public static func makeEmbarkAPIGraphQLSingleVariable(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) -> Variable {
                return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
              }

              public static func makeEmbarkAPIGraphQLGeneratedVariable(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) -> Variable {
                return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
              }

              public static func makeEmbarkAPIGraphQLMultiActionVariable(key: String, variables: [AsEmbarkApiGraphQlMultiActionVariable.Variable]) -> Variable {
                return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: AsEmbarkApiGraphQlMultiActionVariable.Variable) -> ResultMap in value.resultMap }])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var fragments: Fragments {
                get {
                  return Fragments(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public struct Fragments {
                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                  get {
                    if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                    return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                  }
                  set {
                    guard let newValue = newValue else { return }
                    resultMap += newValue.resultMap
                  }
                }

                public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                  get {
                    if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                    return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                  }
                  set {
                    guard let newValue = newValue else { return }
                    resultMap += newValue.resultMap
                  }
                }
              }

              public var asEmbarkApiGraphQlSingleVariable: AsEmbarkApiGraphQlSingleVariable? {
                get {
                  if !AsEmbarkApiGraphQlSingleVariable.possibleTypes.contains(__typename) { return nil }
                  return AsEmbarkApiGraphQlSingleVariable(unsafeResultMap: resultMap)
                }
                set {
                  guard let newValue = newValue else { return }
                  resultMap = newValue.resultMap
                }
              }

              public struct AsEmbarkApiGraphQlSingleVariable: GraphQLSelectionSet {
                public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

                public static var selections: [GraphQLSelection] {
                  return [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("key", type: .nonNull(.scalar(String.self))),
                    GraphQLField("from", type: .nonNull(.scalar(String.self))),
                    GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
                  ]
                }

                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
                  self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                }

                public var __typename: String {
                  get {
                    return resultMap["__typename"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "__typename")
                  }
                }

                public var key: String {
                  get {
                    return resultMap["key"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "key")
                  }
                }

                public var from: String {
                  get {
                    return resultMap["from"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "from")
                  }
                }

                public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
                  get {
                    return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "as")
                  }
                }

                public var fragments: Fragments {
                  get {
                    return Fragments(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }

                public struct Fragments {
                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public var apiSingleVariableFragment: ApiSingleVariableFragment {
                    get {
                      return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                    get {
                      if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                      return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                    }
                    set {
                      guard let newValue = newValue else { return }
                      resultMap += newValue.resultMap
                    }
                  }
                }
              }

              public var asEmbarkApiGraphQlGeneratedVariable: AsEmbarkApiGraphQlGeneratedVariable? {
                get {
                  if !AsEmbarkApiGraphQlGeneratedVariable.possibleTypes.contains(__typename) { return nil }
                  return AsEmbarkApiGraphQlGeneratedVariable(unsafeResultMap: resultMap)
                }
                set {
                  guard let newValue = newValue else { return }
                  resultMap = newValue.resultMap
                }
              }

              public struct AsEmbarkApiGraphQlGeneratedVariable: GraphQLSelectionSet {
                public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

                public static var selections: [GraphQLSelection] {
                  return [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("key", type: .nonNull(.scalar(String.self))),
                    GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
                    GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
                  ]
                }

                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
                  self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                }

                public var __typename: String {
                  get {
                    return resultMap["__typename"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "__typename")
                  }
                }

                public var key: String {
                  get {
                    return resultMap["key"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "key")
                  }
                }

                public var storeAs: String {
                  get {
                    return resultMap["storeAs"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "storeAs")
                  }
                }

                public var type: EmbarkAPIGraphQLVariableGeneratedType {
                  get {
                    return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "type")
                  }
                }

                public var fragments: Fragments {
                  get {
                    return Fragments(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }

                public struct Fragments {
                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                    get {
                      if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                      return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                    }
                    set {
                      guard let newValue = newValue else { return }
                      resultMap += newValue.resultMap
                    }
                  }

                  public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment {
                    get {
                      return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }
                }
              }

              public var asEmbarkApiGraphQlMultiActionVariable: AsEmbarkApiGraphQlMultiActionVariable? {
                get {
                  if !AsEmbarkApiGraphQlMultiActionVariable.possibleTypes.contains(__typename) { return nil }
                  return AsEmbarkApiGraphQlMultiActionVariable(unsafeResultMap: resultMap)
                }
                set {
                  guard let newValue = newValue else { return }
                  resultMap = newValue.resultMap
                }
              }

              public struct AsEmbarkApiGraphQlMultiActionVariable: GraphQLSelectionSet {
                public static let possibleTypes: [String] = ["EmbarkAPIGraphQLMultiActionVariable"]

                public static var selections: [GraphQLSelection] {
                  return [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("key", type: .nonNull(.scalar(String.self))),
                    GraphQLField("variables", type: .nonNull(.list(.nonNull(.object(Variable.selections))))),
                  ]
                }

                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public init(key: String, variables: [Variable]) {
                  self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: Variable) -> ResultMap in value.resultMap }])
                }

                public var __typename: String {
                  get {
                    return resultMap["__typename"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "__typename")
                  }
                }

                public var key: String {
                  get {
                    return resultMap["key"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "key")
                  }
                }

                public var variables: [Variable] {
                  get {
                    return (resultMap["variables"] as! [ResultMap]).map { (value: ResultMap) -> Variable in Variable(unsafeResultMap: value) }
                  }
                  set {
                    resultMap.updateValue(newValue.map { (value: Variable) -> ResultMap in value.resultMap }, forKey: "variables")
                  }
                }

                public var fragments: Fragments {
                  get {
                    return Fragments(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }

                public struct Fragments {
                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                    get {
                      if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                      return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                    }
                    set {
                      guard let newValue = newValue else { return }
                      resultMap += newValue.resultMap
                    }
                  }

                  public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                    get {
                      if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                      return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                    }
                    set {
                      guard let newValue = newValue else { return }
                      resultMap += newValue.resultMap
                    }
                  }
                }

                public struct Variable: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable", "EmbarkAPIGraphQLGeneratedVariable", "EmbarkAPIGraphQLMultiActionVariable", "EmbarkAPIGraphQLConstantVariable"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLTypeCase(
                        variants: ["EmbarkAPIGraphQLSingleVariable": AsEmbarkApiGraphQlSingleVariable.selections, "EmbarkAPIGraphQLGeneratedVariable": AsEmbarkApiGraphQlGeneratedVariable.selections],
                        default: [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        ]
                      )
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public static func makeEmbarkAPIGraphQLMultiActionVariable() -> Variable {
                    return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable"])
                  }

                  public static func makeEmbarkAPIGraphQLConstantVariable() -> Variable {
                    return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLConstantVariable"])
                  }

                  public static func makeEmbarkAPIGraphQLSingleVariable(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) -> Variable {
                    return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                  }

                  public static func makeEmbarkAPIGraphQLGeneratedVariable(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) -> Variable {
                    return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                      get {
                        if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                        return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        guard let newValue = newValue else { return }
                        resultMap += newValue.resultMap
                      }
                    }

                    public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                      get {
                        if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                        return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        guard let newValue = newValue else { return }
                        resultMap += newValue.resultMap
                      }
                    }
                  }

                  public var asEmbarkApiGraphQlSingleVariable: AsEmbarkApiGraphQlSingleVariable? {
                    get {
                      if !AsEmbarkApiGraphQlSingleVariable.possibleTypes.contains(__typename) { return nil }
                      return AsEmbarkApiGraphQlSingleVariable(unsafeResultMap: resultMap)
                    }
                    set {
                      guard let newValue = newValue else { return }
                      resultMap = newValue.resultMap
                    }
                  }

                  public struct AsEmbarkApiGraphQlSingleVariable: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("key", type: .nonNull(.scalar(String.self))),
                        GraphQLField("from", type: .nonNull(.scalar(String.self))),
                        GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
                      self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var key: String {
                      get {
                        return resultMap["key"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "key")
                      }
                    }

                    public var from: String {
                      get {
                        return resultMap["from"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "from")
                      }
                    }

                    public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
                      get {
                        return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "as")
                      }
                    }

                    public var fragments: Fragments {
                      get {
                        return Fragments(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public struct Fragments {
                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public var apiSingleVariableFragment: ApiSingleVariableFragment {
                        get {
                          return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                        get {
                          if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                          return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          guard let newValue = newValue else { return }
                          resultMap += newValue.resultMap
                        }
                      }
                    }
                  }

                  public var asEmbarkApiGraphQlGeneratedVariable: AsEmbarkApiGraphQlGeneratedVariable? {
                    get {
                      if !AsEmbarkApiGraphQlGeneratedVariable.possibleTypes.contains(__typename) { return nil }
                      return AsEmbarkApiGraphQlGeneratedVariable(unsafeResultMap: resultMap)
                    }
                    set {
                      guard let newValue = newValue else { return }
                      resultMap = newValue.resultMap
                    }
                  }

                  public struct AsEmbarkApiGraphQlGeneratedVariable: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("key", type: .nonNull(.scalar(String.self))),
                        GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
                        GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
                      self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var key: String {
                      get {
                        return resultMap["key"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "key")
                      }
                    }

                    public var storeAs: String {
                      get {
                        return resultMap["storeAs"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "storeAs")
                      }
                    }

                    public var type: EmbarkAPIGraphQLVariableGeneratedType {
                      get {
                        return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "type")
                      }
                    }

                    public var fragments: Fragments {
                      get {
                        return Fragments(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public struct Fragments {
                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                        get {
                          if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                          return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          guard let newValue = newValue else { return }
                          resultMap += newValue.resultMap
                        }
                      }

                      public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment {
                        get {
                          return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }

        public struct QueryResult: GraphQLSelectionSet {
          public static let possibleTypes: [String] = ["EmbarkAPIGraphQLResult"]

          public static var selections: [GraphQLSelection] {
            return [
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("key", type: .nonNull(.scalar(String.self))),
              GraphQLField("as", type: .nonNull(.scalar(String.self))),
            ]
          }

          public private(set) var resultMap: ResultMap

          public init(unsafeResultMap: ResultMap) {
            self.resultMap = unsafeResultMap
          }

          public init(key: String, `as`: String) {
            self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLResult", "key": key, "as": `as`])
          }

          public var __typename: String {
            get {
              return resultMap["__typename"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "__typename")
            }
          }

          public var key: String {
            get {
              return resultMap["key"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "key")
            }
          }

          public var `as`: String {
            get {
              return resultMap["as"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "as")
            }
          }
        }

        public struct QueryError: GraphQLSelectionSet {
          public static let possibleTypes: [String] = ["EmbarkAPIGraphQLError"]

          public static var selections: [GraphQLSelection] {
            return [
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("contains", type: .scalar(String.self)),
              GraphQLField("next", type: .nonNull(.object(Next.selections))),
            ]
          }

          public private(set) var resultMap: ResultMap

          public init(unsafeResultMap: ResultMap) {
            self.resultMap = unsafeResultMap
          }

          public init(contains: String? = nil, next: Next) {
            self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLError", "contains": contains, "next": next.resultMap])
          }

          public var __typename: String {
            get {
              return resultMap["__typename"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "__typename")
            }
          }

          public var contains: String? {
            get {
              return resultMap["contains"] as? String
            }
            set {
              resultMap.updateValue(newValue, forKey: "contains")
            }
          }

          public var next: Next {
            get {
              return Next(unsafeResultMap: resultMap["next"]! as! ResultMap)
            }
            set {
              resultMap.updateValue(newValue.resultMap, forKey: "next")
            }
          }

          public struct Next: GraphQLSelectionSet {
            public static let possibleTypes: [String] = ["EmbarkLink"]

            public static var selections: [GraphQLSelection] {
              return [
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("name", type: .nonNull(.scalar(String.self))),
                GraphQLField("label", type: .nonNull(.scalar(String.self))),
              ]
            }

            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public init(name: String, label: String) {
              self.init(unsafeResultMap: ["__typename": "EmbarkLink", "name": name, "label": label])
            }

            public var __typename: String {
              get {
                return resultMap["__typename"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "__typename")
              }
            }

            public var name: String {
              get {
                return resultMap["name"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "name")
              }
            }

            public var label: String {
              get {
                return resultMap["label"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "label")
              }
            }

            public var fragments: Fragments {
              get {
                return Fragments(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }

            public struct Fragments {
              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public var embarkLinkFragment: EmbarkLinkFragment {
                get {
                  return EmbarkLinkFragment(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }
            }
          }
        }
      }
    }

    public var asEmbarkApiGraphQlMutation: AsEmbarkApiGraphQlMutation? {
      get {
        if !AsEmbarkApiGraphQlMutation.possibleTypes.contains(__typename) { return nil }
        return AsEmbarkApiGraphQlMutation(unsafeResultMap: resultMap)
      }
      set {
        guard let newValue = newValue else { return }
        resultMap = newValue.resultMap
      }
    }

    public struct AsEmbarkApiGraphQlMutation: GraphQLSelectionSet {
      public static let possibleTypes: [String] = ["EmbarkApiGraphQLMutation"]

      public static var selections: [GraphQLSelection] {
        return [
          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
          GraphQLField("data", type: .nonNull(.object(Datum.selections))),
        ]
      }

      public private(set) var resultMap: ResultMap

      public init(unsafeResultMap: ResultMap) {
        self.resultMap = unsafeResultMap
      }

      public init(data: Datum) {
        self.init(unsafeResultMap: ["__typename": "EmbarkApiGraphQLMutation", "data": data.resultMap])
      }

      public var __typename: String {
        get {
          return resultMap["__typename"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "__typename")
        }
      }

      public var data: Datum {
        get {
          return Datum(unsafeResultMap: resultMap["data"]! as! ResultMap)
        }
        set {
          resultMap.updateValue(newValue.resultMap, forKey: "data")
        }
      }

      public struct Datum: GraphQLSelectionSet {
        public static let possibleTypes: [String] = ["EmbarkApiGraphQLMutationData"]

        public static var selections: [GraphQLSelection] {
          return [
            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
            GraphQLField("next", type: .object(Next.selections)),
            GraphQLField("mutation", type: .nonNull(.scalar(String.self))),
            GraphQLField("variables", type: .nonNull(.list(.nonNull(.object(Variable.selections))))),
            GraphQLField("results", alias: "mutationResults", type: .nonNull(.list(.object(MutationResult.selections)))),
            GraphQLField("errors", alias: "mutationErrors", type: .nonNull(.list(.nonNull(.object(MutationError.selections))))),
          ]
        }

        public private(set) var resultMap: ResultMap

        public init(unsafeResultMap: ResultMap) {
          self.resultMap = unsafeResultMap
        }

        public init(next: Next? = nil, mutation: String, variables: [Variable], mutationResults: [MutationResult?], mutationErrors: [MutationError]) {
          self.init(unsafeResultMap: ["__typename": "EmbarkApiGraphQLMutationData", "next": next.flatMap { (value: Next) -> ResultMap in value.resultMap }, "mutation": mutation, "variables": variables.map { (value: Variable) -> ResultMap in value.resultMap }, "mutationResults": mutationResults.map { (value: MutationResult?) -> ResultMap? in value.flatMap { (value: MutationResult) -> ResultMap in value.resultMap } }, "mutationErrors": mutationErrors.map { (value: MutationError) -> ResultMap in value.resultMap }])
        }

        public var __typename: String {
          get {
            return resultMap["__typename"]! as! String
          }
          set {
            resultMap.updateValue(newValue, forKey: "__typename")
          }
        }

        public var next: Next? {
          get {
            return (resultMap["next"] as? ResultMap).flatMap { Next(unsafeResultMap: $0) }
          }
          set {
            resultMap.updateValue(newValue?.resultMap, forKey: "next")
          }
        }

        public var mutation: String {
          get {
            return resultMap["mutation"]! as! String
          }
          set {
            resultMap.updateValue(newValue, forKey: "mutation")
          }
        }

        public var variables: [Variable] {
          get {
            return (resultMap["variables"] as! [ResultMap]).map { (value: ResultMap) -> Variable in Variable(unsafeResultMap: value) }
          }
          set {
            resultMap.updateValue(newValue.map { (value: Variable) -> ResultMap in value.resultMap }, forKey: "variables")
          }
        }

        public var mutationResults: [MutationResult?] {
          get {
            return (resultMap["mutationResults"] as! [ResultMap?]).map { (value: ResultMap?) -> MutationResult? in value.flatMap { (value: ResultMap) -> MutationResult in MutationResult(unsafeResultMap: value) } }
          }
          set {
            resultMap.updateValue(newValue.map { (value: MutationResult?) -> ResultMap? in value.flatMap { (value: MutationResult) -> ResultMap in value.resultMap } }, forKey: "mutationResults")
          }
        }

        public var mutationErrors: [MutationError] {
          get {
            return (resultMap["mutationErrors"] as! [ResultMap]).map { (value: ResultMap) -> MutationError in MutationError(unsafeResultMap: value) }
          }
          set {
            resultMap.updateValue(newValue.map { (value: MutationError) -> ResultMap in value.resultMap }, forKey: "mutationErrors")
          }
        }

        public struct Next: GraphQLSelectionSet {
          public static let possibleTypes: [String] = ["EmbarkLink"]

          public static var selections: [GraphQLSelection] {
            return [
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("name", type: .nonNull(.scalar(String.self))),
              GraphQLField("label", type: .nonNull(.scalar(String.self))),
            ]
          }

          public private(set) var resultMap: ResultMap

          public init(unsafeResultMap: ResultMap) {
            self.resultMap = unsafeResultMap
          }

          public init(name: String, label: String) {
            self.init(unsafeResultMap: ["__typename": "EmbarkLink", "name": name, "label": label])
          }

          public var __typename: String {
            get {
              return resultMap["__typename"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "__typename")
            }
          }

          public var name: String {
            get {
              return resultMap["name"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "name")
            }
          }

          public var label: String {
            get {
              return resultMap["label"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "label")
            }
          }

          public var fragments: Fragments {
            get {
              return Fragments(unsafeResultMap: resultMap)
            }
            set {
              resultMap += newValue.resultMap
            }
          }

          public struct Fragments {
            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public var embarkLinkFragment: EmbarkLinkFragment {
              get {
                return EmbarkLinkFragment(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }
          }
        }

        public struct Variable: GraphQLSelectionSet {
          public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable", "EmbarkAPIGraphQLGeneratedVariable", "EmbarkAPIGraphQLMultiActionVariable", "EmbarkAPIGraphQLConstantVariable"]

          public static var selections: [GraphQLSelection] {
            return [
              GraphQLTypeCase(
                variants: ["EmbarkAPIGraphQLSingleVariable": AsEmbarkApiGraphQlSingleVariable.selections, "EmbarkAPIGraphQLGeneratedVariable": AsEmbarkApiGraphQlGeneratedVariable.selections, "EmbarkAPIGraphQLMultiActionVariable": AsEmbarkApiGraphQlMultiActionVariable.selections],
                default: [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                ]
              )
            ]
          }

          public private(set) var resultMap: ResultMap

          public init(unsafeResultMap: ResultMap) {
            self.resultMap = unsafeResultMap
          }

          public static func makeEmbarkAPIGraphQLConstantVariable() -> Variable {
            return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLConstantVariable"])
          }

          public static func makeEmbarkAPIGraphQLSingleVariable(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) -> Variable {
            return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
          }

          public static func makeEmbarkAPIGraphQLGeneratedVariable(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) -> Variable {
            return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
          }

          public static func makeEmbarkAPIGraphQLMultiActionVariable(key: String, variables: [AsEmbarkApiGraphQlMultiActionVariable.Variable]) -> Variable {
            return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: AsEmbarkApiGraphQlMultiActionVariable.Variable) -> ResultMap in value.resultMap }])
          }

          public var __typename: String {
            get {
              return resultMap["__typename"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "__typename")
            }
          }

          public var fragments: Fragments {
            get {
              return Fragments(unsafeResultMap: resultMap)
            }
            set {
              resultMap += newValue.resultMap
            }
          }

          public struct Fragments {
            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public var apiVariablesFragment: ApiVariablesFragment {
              get {
                return ApiVariablesFragment(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }

            public var apiSingleVariableFragment: ApiSingleVariableFragment? {
              get {
                if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                return ApiSingleVariableFragment(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap += newValue.resultMap
              }
            }

            public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
              get {
                if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap += newValue.resultMap
              }
            }

            public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment? {
              get {
                if !ApiMultiActionVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap += newValue.resultMap
              }
            }
          }

          public var asEmbarkApiGraphQlSingleVariable: AsEmbarkApiGraphQlSingleVariable? {
            get {
              if !AsEmbarkApiGraphQlSingleVariable.possibleTypes.contains(__typename) { return nil }
              return AsEmbarkApiGraphQlSingleVariable(unsafeResultMap: resultMap)
            }
            set {
              guard let newValue = newValue else { return }
              resultMap = newValue.resultMap
            }
          }

          public struct AsEmbarkApiGraphQlSingleVariable: GraphQLSelectionSet {
            public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

            public static var selections: [GraphQLSelection] {
              return [
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("key", type: .nonNull(.scalar(String.self))),
                GraphQLField("from", type: .nonNull(.scalar(String.self))),
                GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
              ]
            }

            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
              self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
            }

            public var __typename: String {
              get {
                return resultMap["__typename"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "__typename")
              }
            }

            public var key: String {
              get {
                return resultMap["key"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "key")
              }
            }

            public var from: String {
              get {
                return resultMap["from"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "from")
              }
            }

            public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
              get {
                return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
              }
              set {
                resultMap.updateValue(newValue, forKey: "as")
              }
            }

            public var fragments: Fragments {
              get {
                return Fragments(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }

            public struct Fragments {
              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public var apiVariablesFragment: ApiVariablesFragment {
                get {
                  return ApiVariablesFragment(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public var apiSingleVariableFragment: ApiSingleVariableFragment {
                get {
                  return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                get {
                  if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                  return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                }
                set {
                  guard let newValue = newValue else { return }
                  resultMap += newValue.resultMap
                }
              }

              public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment? {
                get {
                  if !ApiMultiActionVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                  return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                }
                set {
                  guard let newValue = newValue else { return }
                  resultMap += newValue.resultMap
                }
              }
            }
          }

          public var asEmbarkApiGraphQlGeneratedVariable: AsEmbarkApiGraphQlGeneratedVariable? {
            get {
              if !AsEmbarkApiGraphQlGeneratedVariable.possibleTypes.contains(__typename) { return nil }
              return AsEmbarkApiGraphQlGeneratedVariable(unsafeResultMap: resultMap)
            }
            set {
              guard let newValue = newValue else { return }
              resultMap = newValue.resultMap
            }
          }

          public struct AsEmbarkApiGraphQlGeneratedVariable: GraphQLSelectionSet {
            public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

            public static var selections: [GraphQLSelection] {
              return [
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("key", type: .nonNull(.scalar(String.self))),
                GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
                GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
              ]
            }

            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
              self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
            }

            public var __typename: String {
              get {
                return resultMap["__typename"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "__typename")
              }
            }

            public var key: String {
              get {
                return resultMap["key"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "key")
              }
            }

            public var storeAs: String {
              get {
                return resultMap["storeAs"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "storeAs")
              }
            }

            public var type: EmbarkAPIGraphQLVariableGeneratedType {
              get {
                return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
              }
              set {
                resultMap.updateValue(newValue, forKey: "type")
              }
            }

            public var fragments: Fragments {
              get {
                return Fragments(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }

            public struct Fragments {
              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public var apiVariablesFragment: ApiVariablesFragment {
                get {
                  return ApiVariablesFragment(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                get {
                  if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                  return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                }
                set {
                  guard let newValue = newValue else { return }
                  resultMap += newValue.resultMap
                }
              }

              public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment {
                get {
                  return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment? {
                get {
                  if !ApiMultiActionVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                  return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                }
                set {
                  guard let newValue = newValue else { return }
                  resultMap += newValue.resultMap
                }
              }
            }
          }

          public var asEmbarkApiGraphQlMultiActionVariable: AsEmbarkApiGraphQlMultiActionVariable? {
            get {
              if !AsEmbarkApiGraphQlMultiActionVariable.possibleTypes.contains(__typename) { return nil }
              return AsEmbarkApiGraphQlMultiActionVariable(unsafeResultMap: resultMap)
            }
            set {
              guard let newValue = newValue else { return }
              resultMap = newValue.resultMap
            }
          }

          public struct AsEmbarkApiGraphQlMultiActionVariable: GraphQLSelectionSet {
            public static let possibleTypes: [String] = ["EmbarkAPIGraphQLMultiActionVariable"]

            public static var selections: [GraphQLSelection] {
              return [
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("key", type: .nonNull(.scalar(String.self))),
                GraphQLField("variables", type: .nonNull(.list(.nonNull(.object(Variable.selections))))),
              ]
            }

            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public init(key: String, variables: [Variable]) {
              self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: Variable) -> ResultMap in value.resultMap }])
            }

            public var __typename: String {
              get {
                return resultMap["__typename"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "__typename")
              }
            }

            public var key: String {
              get {
                return resultMap["key"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "key")
              }
            }

            public var variables: [Variable] {
              get {
                return (resultMap["variables"] as! [ResultMap]).map { (value: ResultMap) -> Variable in Variable(unsafeResultMap: value) }
              }
              set {
                resultMap.updateValue(newValue.map { (value: Variable) -> ResultMap in value.resultMap }, forKey: "variables")
              }
            }

            public var fragments: Fragments {
              get {
                return Fragments(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }

            public struct Fragments {
              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public var apiVariablesFragment: ApiVariablesFragment {
                get {
                  return ApiVariablesFragment(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                get {
                  if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                  return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                }
                set {
                  guard let newValue = newValue else { return }
                  resultMap += newValue.resultMap
                }
              }

              public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                get {
                  if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                  return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                }
                set {
                  guard let newValue = newValue else { return }
                  resultMap += newValue.resultMap
                }
              }

              public var apiMultiActionVariableFragment: ApiMultiActionVariableFragment {
                get {
                  return ApiMultiActionVariableFragment(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }
            }

            public struct Variable: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable", "EmbarkAPIGraphQLGeneratedVariable", "EmbarkAPIGraphQLMultiActionVariable", "EmbarkAPIGraphQLConstantVariable"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLTypeCase(
                    variants: ["EmbarkAPIGraphQLSingleVariable": AsEmbarkApiGraphQlSingleVariable.selections, "EmbarkAPIGraphQLGeneratedVariable": AsEmbarkApiGraphQlGeneratedVariable.selections, "EmbarkAPIGraphQLMultiActionVariable": AsEmbarkApiGraphQlMultiActionVariable.selections],
                    default: [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    ]
                  )
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public static func makeEmbarkAPIGraphQLConstantVariable() -> Variable {
                return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLConstantVariable"])
              }

              public static func makeEmbarkAPIGraphQLSingleVariable(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) -> Variable {
                return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
              }

              public static func makeEmbarkAPIGraphQLGeneratedVariable(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) -> Variable {
                return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
              }

              public static func makeEmbarkAPIGraphQLMultiActionVariable(key: String, variables: [AsEmbarkApiGraphQlMultiActionVariable.Variable]) -> Variable {
                return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: AsEmbarkApiGraphQlMultiActionVariable.Variable) -> ResultMap in value.resultMap }])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var fragments: Fragments {
                get {
                  return Fragments(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public struct Fragments {
                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                  get {
                    if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                    return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                  }
                  set {
                    guard let newValue = newValue else { return }
                    resultMap += newValue.resultMap
                  }
                }

                public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                  get {
                    if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                    return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                  }
                  set {
                    guard let newValue = newValue else { return }
                    resultMap += newValue.resultMap
                  }
                }
              }

              public var asEmbarkApiGraphQlSingleVariable: AsEmbarkApiGraphQlSingleVariable? {
                get {
                  if !AsEmbarkApiGraphQlSingleVariable.possibleTypes.contains(__typename) { return nil }
                  return AsEmbarkApiGraphQlSingleVariable(unsafeResultMap: resultMap)
                }
                set {
                  guard let newValue = newValue else { return }
                  resultMap = newValue.resultMap
                }
              }

              public struct AsEmbarkApiGraphQlSingleVariable: GraphQLSelectionSet {
                public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

                public static var selections: [GraphQLSelection] {
                  return [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("key", type: .nonNull(.scalar(String.self))),
                    GraphQLField("from", type: .nonNull(.scalar(String.self))),
                    GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
                  ]
                }

                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
                  self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                }

                public var __typename: String {
                  get {
                    return resultMap["__typename"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "__typename")
                  }
                }

                public var key: String {
                  get {
                    return resultMap["key"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "key")
                  }
                }

                public var from: String {
                  get {
                    return resultMap["from"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "from")
                  }
                }

                public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
                  get {
                    return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "as")
                  }
                }

                public var fragments: Fragments {
                  get {
                    return Fragments(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }

                public struct Fragments {
                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public var apiSingleVariableFragment: ApiSingleVariableFragment {
                    get {
                      return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                    get {
                      if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                      return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                    }
                    set {
                      guard let newValue = newValue else { return }
                      resultMap += newValue.resultMap
                    }
                  }
                }
              }

              public var asEmbarkApiGraphQlGeneratedVariable: AsEmbarkApiGraphQlGeneratedVariable? {
                get {
                  if !AsEmbarkApiGraphQlGeneratedVariable.possibleTypes.contains(__typename) { return nil }
                  return AsEmbarkApiGraphQlGeneratedVariable(unsafeResultMap: resultMap)
                }
                set {
                  guard let newValue = newValue else { return }
                  resultMap = newValue.resultMap
                }
              }

              public struct AsEmbarkApiGraphQlGeneratedVariable: GraphQLSelectionSet {
                public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

                public static var selections: [GraphQLSelection] {
                  return [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("key", type: .nonNull(.scalar(String.self))),
                    GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
                    GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
                  ]
                }

                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
                  self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                }

                public var __typename: String {
                  get {
                    return resultMap["__typename"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "__typename")
                  }
                }

                public var key: String {
                  get {
                    return resultMap["key"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "key")
                  }
                }

                public var storeAs: String {
                  get {
                    return resultMap["storeAs"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "storeAs")
                  }
                }

                public var type: EmbarkAPIGraphQLVariableGeneratedType {
                  get {
                    return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "type")
                  }
                }

                public var fragments: Fragments {
                  get {
                    return Fragments(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }

                public struct Fragments {
                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                    get {
                      if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                      return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                    }
                    set {
                      guard let newValue = newValue else { return }
                      resultMap += newValue.resultMap
                    }
                  }

                  public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment {
                    get {
                      return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }
                }
              }

              public var asEmbarkApiGraphQlMultiActionVariable: AsEmbarkApiGraphQlMultiActionVariable? {
                get {
                  if !AsEmbarkApiGraphQlMultiActionVariable.possibleTypes.contains(__typename) { return nil }
                  return AsEmbarkApiGraphQlMultiActionVariable(unsafeResultMap: resultMap)
                }
                set {
                  guard let newValue = newValue else { return }
                  resultMap = newValue.resultMap
                }
              }

              public struct AsEmbarkApiGraphQlMultiActionVariable: GraphQLSelectionSet {
                public static let possibleTypes: [String] = ["EmbarkAPIGraphQLMultiActionVariable"]

                public static var selections: [GraphQLSelection] {
                  return [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("key", type: .nonNull(.scalar(String.self))),
                    GraphQLField("variables", type: .nonNull(.list(.nonNull(.object(Variable.selections))))),
                  ]
                }

                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public init(key: String, variables: [Variable]) {
                  self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable", "key": key, "variables": variables.map { (value: Variable) -> ResultMap in value.resultMap }])
                }

                public var __typename: String {
                  get {
                    return resultMap["__typename"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "__typename")
                  }
                }

                public var key: String {
                  get {
                    return resultMap["key"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "key")
                  }
                }

                public var variables: [Variable] {
                  get {
                    return (resultMap["variables"] as! [ResultMap]).map { (value: ResultMap) -> Variable in Variable(unsafeResultMap: value) }
                  }
                  set {
                    resultMap.updateValue(newValue.map { (value: Variable) -> ResultMap in value.resultMap }, forKey: "variables")
                  }
                }

                public var fragments: Fragments {
                  get {
                    return Fragments(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }

                public struct Fragments {
                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                    get {
                      if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                      return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                    }
                    set {
                      guard let newValue = newValue else { return }
                      resultMap += newValue.resultMap
                    }
                  }

                  public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                    get {
                      if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                      return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                    }
                    set {
                      guard let newValue = newValue else { return }
                      resultMap += newValue.resultMap
                    }
                  }
                }

                public struct Variable: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable", "EmbarkAPIGraphQLGeneratedVariable", "EmbarkAPIGraphQLMultiActionVariable", "EmbarkAPIGraphQLConstantVariable"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLTypeCase(
                        variants: ["EmbarkAPIGraphQLSingleVariable": AsEmbarkApiGraphQlSingleVariable.selections, "EmbarkAPIGraphQLGeneratedVariable": AsEmbarkApiGraphQlGeneratedVariable.selections],
                        default: [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        ]
                      )
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public static func makeEmbarkAPIGraphQLMultiActionVariable() -> Variable {
                    return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLMultiActionVariable"])
                  }

                  public static func makeEmbarkAPIGraphQLConstantVariable() -> Variable {
                    return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLConstantVariable"])
                  }

                  public static func makeEmbarkAPIGraphQLSingleVariable(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) -> Variable {
                    return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                  }

                  public static func makeEmbarkAPIGraphQLGeneratedVariable(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) -> Variable {
                    return Variable(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                      get {
                        if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                        return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        guard let newValue = newValue else { return }
                        resultMap += newValue.resultMap
                      }
                    }

                    public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                      get {
                        if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                        return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        guard let newValue = newValue else { return }
                        resultMap += newValue.resultMap
                      }
                    }
                  }

                  public var asEmbarkApiGraphQlSingleVariable: AsEmbarkApiGraphQlSingleVariable? {
                    get {
                      if !AsEmbarkApiGraphQlSingleVariable.possibleTypes.contains(__typename) { return nil }
                      return AsEmbarkApiGraphQlSingleVariable(unsafeResultMap: resultMap)
                    }
                    set {
                      guard let newValue = newValue else { return }
                      resultMap = newValue.resultMap
                    }
                  }

                  public struct AsEmbarkApiGraphQlSingleVariable: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkAPIGraphQLSingleVariable"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("key", type: .nonNull(.scalar(String.self))),
                        GraphQLField("from", type: .nonNull(.scalar(String.self))),
                        GraphQLField("as", type: .nonNull(.scalar(EmbarkAPIGraphQLSingleVariableCasting.self))),
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public init(key: String, from: String, `as`: EmbarkAPIGraphQLSingleVariableCasting) {
                      self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLSingleVariable", "key": key, "from": from, "as": `as`])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var key: String {
                      get {
                        return resultMap["key"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "key")
                      }
                    }

                    public var from: String {
                      get {
                        return resultMap["from"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "from")
                      }
                    }

                    public var `as`: EmbarkAPIGraphQLSingleVariableCasting {
                      get {
                        return resultMap["as"]! as! EmbarkAPIGraphQLSingleVariableCasting
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "as")
                      }
                    }

                    public var fragments: Fragments {
                      get {
                        return Fragments(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public struct Fragments {
                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public var apiSingleVariableFragment: ApiSingleVariableFragment {
                        get {
                          return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment? {
                        get {
                          if !ApiGeneratedVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                          return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          guard let newValue = newValue else { return }
                          resultMap += newValue.resultMap
                        }
                      }
                    }
                  }

                  public var asEmbarkApiGraphQlGeneratedVariable: AsEmbarkApiGraphQlGeneratedVariable? {
                    get {
                      if !AsEmbarkApiGraphQlGeneratedVariable.possibleTypes.contains(__typename) { return nil }
                      return AsEmbarkApiGraphQlGeneratedVariable(unsafeResultMap: resultMap)
                    }
                    set {
                      guard let newValue = newValue else { return }
                      resultMap = newValue.resultMap
                    }
                  }

                  public struct AsEmbarkApiGraphQlGeneratedVariable: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkAPIGraphQLGeneratedVariable"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("key", type: .nonNull(.scalar(String.self))),
                        GraphQLField("storeAs", type: .nonNull(.scalar(String.self))),
                        GraphQLField("type", type: .nonNull(.scalar(EmbarkAPIGraphQLVariableGeneratedType.self))),
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public init(key: String, storeAs: String, type: EmbarkAPIGraphQLVariableGeneratedType) {
                      self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLGeneratedVariable", "key": key, "storeAs": storeAs, "type": type])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var key: String {
                      get {
                        return resultMap["key"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "key")
                      }
                    }

                    public var storeAs: String {
                      get {
                        return resultMap["storeAs"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "storeAs")
                      }
                    }

                    public var type: EmbarkAPIGraphQLVariableGeneratedType {
                      get {
                        return resultMap["type"]! as! EmbarkAPIGraphQLVariableGeneratedType
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "type")
                      }
                    }

                    public var fragments: Fragments {
                      get {
                        return Fragments(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public struct Fragments {
                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public var apiSingleVariableFragment: ApiSingleVariableFragment? {
                        get {
                          if !ApiSingleVariableFragment.possibleTypes.contains(resultMap["__typename"]! as! String) { return nil }
                          return ApiSingleVariableFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          guard let newValue = newValue else { return }
                          resultMap += newValue.resultMap
                        }
                      }

                      public var apiGeneratedVariableFragment: ApiGeneratedVariableFragment {
                        get {
                          return ApiGeneratedVariableFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }

        public struct MutationResult: GraphQLSelectionSet {
          public static let possibleTypes: [String] = ["EmbarkAPIGraphQLResult"]

          public static var selections: [GraphQLSelection] {
            return [
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("key", type: .nonNull(.scalar(String.self))),
              GraphQLField("as", type: .nonNull(.scalar(String.self))),
            ]
          }

          public private(set) var resultMap: ResultMap

          public init(unsafeResultMap: ResultMap) {
            self.resultMap = unsafeResultMap
          }

          public init(key: String, `as`: String) {
            self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLResult", "key": key, "as": `as`])
          }

          public var __typename: String {
            get {
              return resultMap["__typename"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "__typename")
            }
          }

          public var key: String {
            get {
              return resultMap["key"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "key")
            }
          }

          public var `as`: String {
            get {
              return resultMap["as"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "as")
            }
          }
        }

        public struct MutationError: GraphQLSelectionSet {
          public static let possibleTypes: [String] = ["EmbarkAPIGraphQLError"]

          public static var selections: [GraphQLSelection] {
            return [
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("contains", type: .scalar(String.self)),
              GraphQLField("next", type: .nonNull(.object(Next.selections))),
            ]
          }

          public private(set) var resultMap: ResultMap

          public init(unsafeResultMap: ResultMap) {
            self.resultMap = unsafeResultMap
          }

          public init(contains: String? = nil, next: Next) {
            self.init(unsafeResultMap: ["__typename": "EmbarkAPIGraphQLError", "contains": contains, "next": next.resultMap])
          }

          public var __typename: String {
            get {
              return resultMap["__typename"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "__typename")
            }
          }

          public var contains: String? {
            get {
              return resultMap["contains"] as? String
            }
            set {
              resultMap.updateValue(newValue, forKey: "contains")
            }
          }

          public var next: Next {
            get {
              return Next(unsafeResultMap: resultMap["next"]! as! ResultMap)
            }
            set {
              resultMap.updateValue(newValue.resultMap, forKey: "next")
            }
          }

          public struct Next: GraphQLSelectionSet {
            public static let possibleTypes: [String] = ["EmbarkLink"]

            public static var selections: [GraphQLSelection] {
              return [
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("name", type: .nonNull(.scalar(String.self))),
                GraphQLField("label", type: .nonNull(.scalar(String.self))),
              ]
            }

            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public init(name: String, label: String) {
              self.init(unsafeResultMap: ["__typename": "EmbarkLink", "name": name, "label": label])
            }

            public var __typename: String {
              get {
                return resultMap["__typename"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "__typename")
              }
            }

            public var name: String {
              get {
                return resultMap["name"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "name")
              }
            }

            public var label: String {
              get {
                return resultMap["label"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "label")
              }
            }

            public var fragments: Fragments {
              get {
                return Fragments(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }

            public struct Fragments {
              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public var embarkLinkFragment: EmbarkLinkFragment {
                get {
                  return EmbarkLinkFragment(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }
            }
          }
        }
      }
    }
  }

  struct EmbarkRedirectSingle: GraphQLFragment {
    /// The raw GraphQL definition of this fragment.
    public static let fragmentDefinition: String =
      """
      fragment EmbarkRedirectSingle on EmbarkRedirect {
        __typename
        ... on EmbarkRedirectUnaryExpression {
          unaryType: type
          to
          passedExpressionKey
          passedExpressionValue
        }
        ... on EmbarkRedirectBinaryExpression {
          binaryType: type
          to
          key
          value
          passedExpressionKey
          passedExpressionValue
        }
      }
      """

    public static let possibleTypes: [String] = ["EmbarkRedirectUnaryExpression", "EmbarkRedirectBinaryExpression", "EmbarkRedirectMultipleExpressions"]

    public static var selections: [GraphQLSelection] {
      return [
        GraphQLTypeCase(
          variants: ["EmbarkRedirectUnaryExpression": AsEmbarkRedirectUnaryExpression.selections, "EmbarkRedirectBinaryExpression": AsEmbarkRedirectBinaryExpression.selections],
          default: [
            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
          ]
        )
      ]
    }

    public private(set) var resultMap: ResultMap

    public init(unsafeResultMap: ResultMap) {
      self.resultMap = unsafeResultMap
    }

    public static func makeEmbarkRedirectMultipleExpressions() -> EmbarkRedirectSingle {
      return EmbarkRedirectSingle(unsafeResultMap: ["__typename": "EmbarkRedirectMultipleExpressions"])
    }

    public static func makeEmbarkRedirectUnaryExpression(unaryType: EmbarkExpressionTypeUnary, to: String, passedExpressionKey: String? = nil, passedExpressionValue: String? = nil) -> EmbarkRedirectSingle {
      return EmbarkRedirectSingle(unsafeResultMap: ["__typename": "EmbarkRedirectUnaryExpression", "unaryType": unaryType, "to": to, "passedExpressionKey": passedExpressionKey, "passedExpressionValue": passedExpressionValue])
    }

    public static func makeEmbarkRedirectBinaryExpression(binaryType: EmbarkExpressionTypeBinary, to: String, key: String, value: String, passedExpressionKey: String? = nil, passedExpressionValue: String? = nil) -> EmbarkRedirectSingle {
      return EmbarkRedirectSingle(unsafeResultMap: ["__typename": "EmbarkRedirectBinaryExpression", "binaryType": binaryType, "to": to, "key": key, "value": value, "passedExpressionKey": passedExpressionKey, "passedExpressionValue": passedExpressionValue])
    }

    public var __typename: String {
      get {
        return resultMap["__typename"]! as! String
      }
      set {
        resultMap.updateValue(newValue, forKey: "__typename")
      }
    }

    public var asEmbarkRedirectUnaryExpression: AsEmbarkRedirectUnaryExpression? {
      get {
        if !AsEmbarkRedirectUnaryExpression.possibleTypes.contains(__typename) { return nil }
        return AsEmbarkRedirectUnaryExpression(unsafeResultMap: resultMap)
      }
      set {
        guard let newValue = newValue else { return }
        resultMap = newValue.resultMap
      }
    }

    public struct AsEmbarkRedirectUnaryExpression: GraphQLSelectionSet {
      public static let possibleTypes: [String] = ["EmbarkRedirectUnaryExpression"]

      public static var selections: [GraphQLSelection] {
        return [
          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
          GraphQLField("type", alias: "unaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
          GraphQLField("to", type: .nonNull(.scalar(String.self))),
          GraphQLField("passedExpressionKey", type: .scalar(String.self)),
          GraphQLField("passedExpressionValue", type: .scalar(String.self)),
        ]
      }

      public private(set) var resultMap: ResultMap

      public init(unsafeResultMap: ResultMap) {
        self.resultMap = unsafeResultMap
      }

      public init(unaryType: EmbarkExpressionTypeUnary, to: String, passedExpressionKey: String? = nil, passedExpressionValue: String? = nil) {
        self.init(unsafeResultMap: ["__typename": "EmbarkRedirectUnaryExpression", "unaryType": unaryType, "to": to, "passedExpressionKey": passedExpressionKey, "passedExpressionValue": passedExpressionValue])
      }

      public var __typename: String {
        get {
          return resultMap["__typename"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "__typename")
        }
      }

      public var unaryType: EmbarkExpressionTypeUnary {
        get {
          return resultMap["unaryType"]! as! EmbarkExpressionTypeUnary
        }
        set {
          resultMap.updateValue(newValue, forKey: "unaryType")
        }
      }

      public var to: String {
        get {
          return resultMap["to"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "to")
        }
      }

      public var passedExpressionKey: String? {
        get {
          return resultMap["passedExpressionKey"] as? String
        }
        set {
          resultMap.updateValue(newValue, forKey: "passedExpressionKey")
        }
      }

      public var passedExpressionValue: String? {
        get {
          return resultMap["passedExpressionValue"] as? String
        }
        set {
          resultMap.updateValue(newValue, forKey: "passedExpressionValue")
        }
      }
    }

    public var asEmbarkRedirectBinaryExpression: AsEmbarkRedirectBinaryExpression? {
      get {
        if !AsEmbarkRedirectBinaryExpression.possibleTypes.contains(__typename) { return nil }
        return AsEmbarkRedirectBinaryExpression(unsafeResultMap: resultMap)
      }
      set {
        guard let newValue = newValue else { return }
        resultMap = newValue.resultMap
      }
    }

    public struct AsEmbarkRedirectBinaryExpression: GraphQLSelectionSet {
      public static let possibleTypes: [String] = ["EmbarkRedirectBinaryExpression"]

      public static var selections: [GraphQLSelection] {
        return [
          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
          GraphQLField("type", alias: "binaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
          GraphQLField("to", type: .nonNull(.scalar(String.self))),
          GraphQLField("key", type: .nonNull(.scalar(String.self))),
          GraphQLField("value", type: .nonNull(.scalar(String.self))),
          GraphQLField("passedExpressionKey", type: .scalar(String.self)),
          GraphQLField("passedExpressionValue", type: .scalar(String.self)),
        ]
      }

      public private(set) var resultMap: ResultMap

      public init(unsafeResultMap: ResultMap) {
        self.resultMap = unsafeResultMap
      }

      public init(binaryType: EmbarkExpressionTypeBinary, to: String, key: String, value: String, passedExpressionKey: String? = nil, passedExpressionValue: String? = nil) {
        self.init(unsafeResultMap: ["__typename": "EmbarkRedirectBinaryExpression", "binaryType": binaryType, "to": to, "key": key, "value": value, "passedExpressionKey": passedExpressionKey, "passedExpressionValue": passedExpressionValue])
      }

      public var __typename: String {
        get {
          return resultMap["__typename"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "__typename")
        }
      }

      public var binaryType: EmbarkExpressionTypeBinary {
        get {
          return resultMap["binaryType"]! as! EmbarkExpressionTypeBinary
        }
        set {
          resultMap.updateValue(newValue, forKey: "binaryType")
        }
      }

      public var to: String {
        get {
          return resultMap["to"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "to")
        }
      }

      public var key: String {
        get {
          return resultMap["key"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "key")
        }
      }

      public var value: String {
        get {
          return resultMap["value"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "value")
        }
      }

      public var passedExpressionKey: String? {
        get {
          return resultMap["passedExpressionKey"] as? String
        }
        set {
          resultMap.updateValue(newValue, forKey: "passedExpressionKey")
        }
      }

      public var passedExpressionValue: String? {
        get {
          return resultMap["passedExpressionValue"] as? String
        }
        set {
          resultMap.updateValue(newValue, forKey: "passedExpressionValue")
        }
      }
    }
  }

  struct EmbarkRedirectFragment: GraphQLFragment {
    /// The raw GraphQL definition of this fragment.
    public static let fragmentDefinition: String =
      """
      fragment EmbarkRedirectFragment on EmbarkRedirect {
        __typename
        ...EmbarkRedirectSingle
        ... on EmbarkRedirectMultipleExpressions {
          multipleType: type
          to
          passedExpressionKey
          passedExpressionValue
          subExpressions {
            __typename
            ...ExpressionFragment
          }
        }
      }
      """

    public static let possibleTypes: [String] = ["EmbarkRedirectUnaryExpression", "EmbarkRedirectBinaryExpression", "EmbarkRedirectMultipleExpressions"]

    public static var selections: [GraphQLSelection] {
      return [
        GraphQLTypeCase(
          variants: ["EmbarkRedirectUnaryExpression": AsEmbarkRedirectUnaryExpression.selections, "EmbarkRedirectBinaryExpression": AsEmbarkRedirectBinaryExpression.selections, "EmbarkRedirectMultipleExpressions": AsEmbarkRedirectMultipleExpressions.selections],
          default: [
            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
          ]
        )
      ]
    }

    public private(set) var resultMap: ResultMap

    public init(unsafeResultMap: ResultMap) {
      self.resultMap = unsafeResultMap
    }

    public static func makeEmbarkRedirectUnaryExpression(unaryType: EmbarkExpressionTypeUnary, to: String, passedExpressionKey: String? = nil, passedExpressionValue: String? = nil) -> EmbarkRedirectFragment {
      return EmbarkRedirectFragment(unsafeResultMap: ["__typename": "EmbarkRedirectUnaryExpression", "unaryType": unaryType, "to": to, "passedExpressionKey": passedExpressionKey, "passedExpressionValue": passedExpressionValue])
    }

    public static func makeEmbarkRedirectBinaryExpression(binaryType: EmbarkExpressionTypeBinary, to: String, key: String, value: String, passedExpressionKey: String? = nil, passedExpressionValue: String? = nil) -> EmbarkRedirectFragment {
      return EmbarkRedirectFragment(unsafeResultMap: ["__typename": "EmbarkRedirectBinaryExpression", "binaryType": binaryType, "to": to, "key": key, "value": value, "passedExpressionKey": passedExpressionKey, "passedExpressionValue": passedExpressionValue])
    }

    public static func makeEmbarkRedirectMultipleExpressions(multipleType: EmbarkExpressionTypeMultiple, to: String, passedExpressionKey: String? = nil, passedExpressionValue: String? = nil, subExpressions: [AsEmbarkRedirectMultipleExpressions.SubExpression]) -> EmbarkRedirectFragment {
      return EmbarkRedirectFragment(unsafeResultMap: ["__typename": "EmbarkRedirectMultipleExpressions", "multipleType": multipleType, "to": to, "passedExpressionKey": passedExpressionKey, "passedExpressionValue": passedExpressionValue, "subExpressions": subExpressions.map { (value: AsEmbarkRedirectMultipleExpressions.SubExpression) -> ResultMap in value.resultMap }])
    }

    public var __typename: String {
      get {
        return resultMap["__typename"]! as! String
      }
      set {
        resultMap.updateValue(newValue, forKey: "__typename")
      }
    }

    public var fragments: Fragments {
      get {
        return Fragments(unsafeResultMap: resultMap)
      }
      set {
        resultMap += newValue.resultMap
      }
    }

    public struct Fragments {
      public private(set) var resultMap: ResultMap

      public init(unsafeResultMap: ResultMap) {
        self.resultMap = unsafeResultMap
      }

      public var embarkRedirectSingle: EmbarkRedirectSingle {
        get {
          return EmbarkRedirectSingle(unsafeResultMap: resultMap)
        }
        set {
          resultMap += newValue.resultMap
        }
      }
    }

    public var asEmbarkRedirectUnaryExpression: AsEmbarkRedirectUnaryExpression? {
      get {
        if !AsEmbarkRedirectUnaryExpression.possibleTypes.contains(__typename) { return nil }
        return AsEmbarkRedirectUnaryExpression(unsafeResultMap: resultMap)
      }
      set {
        guard let newValue = newValue else { return }
        resultMap = newValue.resultMap
      }
    }

    public struct AsEmbarkRedirectUnaryExpression: GraphQLSelectionSet {
      public static let possibleTypes: [String] = ["EmbarkRedirectUnaryExpression"]

      public static var selections: [GraphQLSelection] {
        return [
          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
          GraphQLField("type", alias: "unaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
          GraphQLField("to", type: .nonNull(.scalar(String.self))),
          GraphQLField("passedExpressionKey", type: .scalar(String.self)),
          GraphQLField("passedExpressionValue", type: .scalar(String.self)),
        ]
      }

      public private(set) var resultMap: ResultMap

      public init(unsafeResultMap: ResultMap) {
        self.resultMap = unsafeResultMap
      }

      public init(unaryType: EmbarkExpressionTypeUnary, to: String, passedExpressionKey: String? = nil, passedExpressionValue: String? = nil) {
        self.init(unsafeResultMap: ["__typename": "EmbarkRedirectUnaryExpression", "unaryType": unaryType, "to": to, "passedExpressionKey": passedExpressionKey, "passedExpressionValue": passedExpressionValue])
      }

      public var __typename: String {
        get {
          return resultMap["__typename"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "__typename")
        }
      }

      public var unaryType: EmbarkExpressionTypeUnary {
        get {
          return resultMap["unaryType"]! as! EmbarkExpressionTypeUnary
        }
        set {
          resultMap.updateValue(newValue, forKey: "unaryType")
        }
      }

      public var to: String {
        get {
          return resultMap["to"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "to")
        }
      }

      public var passedExpressionKey: String? {
        get {
          return resultMap["passedExpressionKey"] as? String
        }
        set {
          resultMap.updateValue(newValue, forKey: "passedExpressionKey")
        }
      }

      public var passedExpressionValue: String? {
        get {
          return resultMap["passedExpressionValue"] as? String
        }
        set {
          resultMap.updateValue(newValue, forKey: "passedExpressionValue")
        }
      }

      public var fragments: Fragments {
        get {
          return Fragments(unsafeResultMap: resultMap)
        }
        set {
          resultMap += newValue.resultMap
        }
      }

      public struct Fragments {
        public private(set) var resultMap: ResultMap

        public init(unsafeResultMap: ResultMap) {
          self.resultMap = unsafeResultMap
        }

        public var embarkRedirectSingle: EmbarkRedirectSingle {
          get {
            return EmbarkRedirectSingle(unsafeResultMap: resultMap)
          }
          set {
            resultMap += newValue.resultMap
          }
        }
      }
    }

    public var asEmbarkRedirectBinaryExpression: AsEmbarkRedirectBinaryExpression? {
      get {
        if !AsEmbarkRedirectBinaryExpression.possibleTypes.contains(__typename) { return nil }
        return AsEmbarkRedirectBinaryExpression(unsafeResultMap: resultMap)
      }
      set {
        guard let newValue = newValue else { return }
        resultMap = newValue.resultMap
      }
    }

    public struct AsEmbarkRedirectBinaryExpression: GraphQLSelectionSet {
      public static let possibleTypes: [String] = ["EmbarkRedirectBinaryExpression"]

      public static var selections: [GraphQLSelection] {
        return [
          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
          GraphQLField("type", alias: "binaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
          GraphQLField("to", type: .nonNull(.scalar(String.self))),
          GraphQLField("key", type: .nonNull(.scalar(String.self))),
          GraphQLField("value", type: .nonNull(.scalar(String.self))),
          GraphQLField("passedExpressionKey", type: .scalar(String.self)),
          GraphQLField("passedExpressionValue", type: .scalar(String.self)),
        ]
      }

      public private(set) var resultMap: ResultMap

      public init(unsafeResultMap: ResultMap) {
        self.resultMap = unsafeResultMap
      }

      public init(binaryType: EmbarkExpressionTypeBinary, to: String, key: String, value: String, passedExpressionKey: String? = nil, passedExpressionValue: String? = nil) {
        self.init(unsafeResultMap: ["__typename": "EmbarkRedirectBinaryExpression", "binaryType": binaryType, "to": to, "key": key, "value": value, "passedExpressionKey": passedExpressionKey, "passedExpressionValue": passedExpressionValue])
      }

      public var __typename: String {
        get {
          return resultMap["__typename"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "__typename")
        }
      }

      public var binaryType: EmbarkExpressionTypeBinary {
        get {
          return resultMap["binaryType"]! as! EmbarkExpressionTypeBinary
        }
        set {
          resultMap.updateValue(newValue, forKey: "binaryType")
        }
      }

      public var to: String {
        get {
          return resultMap["to"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "to")
        }
      }

      public var key: String {
        get {
          return resultMap["key"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "key")
        }
      }

      public var value: String {
        get {
          return resultMap["value"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "value")
        }
      }

      public var passedExpressionKey: String? {
        get {
          return resultMap["passedExpressionKey"] as? String
        }
        set {
          resultMap.updateValue(newValue, forKey: "passedExpressionKey")
        }
      }

      public var passedExpressionValue: String? {
        get {
          return resultMap["passedExpressionValue"] as? String
        }
        set {
          resultMap.updateValue(newValue, forKey: "passedExpressionValue")
        }
      }

      public var fragments: Fragments {
        get {
          return Fragments(unsafeResultMap: resultMap)
        }
        set {
          resultMap += newValue.resultMap
        }
      }

      public struct Fragments {
        public private(set) var resultMap: ResultMap

        public init(unsafeResultMap: ResultMap) {
          self.resultMap = unsafeResultMap
        }

        public var embarkRedirectSingle: EmbarkRedirectSingle {
          get {
            return EmbarkRedirectSingle(unsafeResultMap: resultMap)
          }
          set {
            resultMap += newValue.resultMap
          }
        }
      }
    }

    public var asEmbarkRedirectMultipleExpressions: AsEmbarkRedirectMultipleExpressions? {
      get {
        if !AsEmbarkRedirectMultipleExpressions.possibleTypes.contains(__typename) { return nil }
        return AsEmbarkRedirectMultipleExpressions(unsafeResultMap: resultMap)
      }
      set {
        guard let newValue = newValue else { return }
        resultMap = newValue.resultMap
      }
    }

    public struct AsEmbarkRedirectMultipleExpressions: GraphQLSelectionSet {
      public static let possibleTypes: [String] = ["EmbarkRedirectMultipleExpressions"]

      public static var selections: [GraphQLSelection] {
        return [
          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
          GraphQLField("type", alias: "multipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
          GraphQLField("to", type: .nonNull(.scalar(String.self))),
          GraphQLField("passedExpressionKey", type: .scalar(String.self)),
          GraphQLField("passedExpressionValue", type: .scalar(String.self)),
          GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
        ]
      }

      public private(set) var resultMap: ResultMap

      public init(unsafeResultMap: ResultMap) {
        self.resultMap = unsafeResultMap
      }

      public init(multipleType: EmbarkExpressionTypeMultiple, to: String, passedExpressionKey: String? = nil, passedExpressionValue: String? = nil, subExpressions: [SubExpression]) {
        self.init(unsafeResultMap: ["__typename": "EmbarkRedirectMultipleExpressions", "multipleType": multipleType, "to": to, "passedExpressionKey": passedExpressionKey, "passedExpressionValue": passedExpressionValue, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
      }

      public var __typename: String {
        get {
          return resultMap["__typename"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "__typename")
        }
      }

      public var multipleType: EmbarkExpressionTypeMultiple {
        get {
          return resultMap["multipleType"]! as! EmbarkExpressionTypeMultiple
        }
        set {
          resultMap.updateValue(newValue, forKey: "multipleType")
        }
      }

      public var to: String {
        get {
          return resultMap["to"]! as! String
        }
        set {
          resultMap.updateValue(newValue, forKey: "to")
        }
      }

      public var passedExpressionKey: String? {
        get {
          return resultMap["passedExpressionKey"] as? String
        }
        set {
          resultMap.updateValue(newValue, forKey: "passedExpressionKey")
        }
      }

      public var passedExpressionValue: String? {
        get {
          return resultMap["passedExpressionValue"] as? String
        }
        set {
          resultMap.updateValue(newValue, forKey: "passedExpressionValue")
        }
      }

      public var subExpressions: [SubExpression] {
        get {
          return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
        }
        set {
          resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
        }
      }

      public var fragments: Fragments {
        get {
          return Fragments(unsafeResultMap: resultMap)
        }
        set {
          resultMap += newValue.resultMap
        }
      }

      public struct Fragments {
        public private(set) var resultMap: ResultMap

        public init(unsafeResultMap: ResultMap) {
          self.resultMap = unsafeResultMap
        }

        public var embarkRedirectSingle: EmbarkRedirectSingle {
          get {
            return EmbarkRedirectSingle(unsafeResultMap: resultMap)
          }
          set {
            resultMap += newValue.resultMap
          }
        }
      }

      public struct SubExpression: GraphQLSelectionSet {
        public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

        public static var selections: [GraphQLSelection] {
          return [
            GraphQLTypeCase(
              variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
              default: [
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              ]
            )
          ]
        }

        public private(set) var resultMap: ResultMap

        public init(unsafeResultMap: ResultMap) {
          self.resultMap = unsafeResultMap
        }

        public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
          return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
        }

        public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
          return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
        }

        public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> SubExpression {
          return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
        }

        public var __typename: String {
          get {
            return resultMap["__typename"]! as! String
          }
          set {
            resultMap.updateValue(newValue, forKey: "__typename")
          }
        }

        public var fragments: Fragments {
          get {
            return Fragments(unsafeResultMap: resultMap)
          }
          set {
            resultMap += newValue.resultMap
          }
        }

        public struct Fragments {
          public private(set) var resultMap: ResultMap

          public init(unsafeResultMap: ResultMap) {
            self.resultMap = unsafeResultMap
          }

          public var expressionFragment: ExpressionFragment {
            get {
              return ExpressionFragment(unsafeResultMap: resultMap)
            }
            set {
              resultMap += newValue.resultMap
            }
          }

          public var basicExpressionFragment: BasicExpressionFragment {
            get {
              return BasicExpressionFragment(unsafeResultMap: resultMap)
            }
            set {
              resultMap += newValue.resultMap
            }
          }
        }

        public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
          get {
            if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
            return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
          }
          set {
            guard let newValue = newValue else { return }
            resultMap = newValue.resultMap
          }
        }

        public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
          public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

          public static var selections: [GraphQLSelection] {
            return [
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
              GraphQLField("text", type: .scalar(String.self)),
            ]
          }

          public private(set) var resultMap: ResultMap

          public init(unsafeResultMap: ResultMap) {
            self.resultMap = unsafeResultMap
          }

          public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
            self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
          }

          public var __typename: String {
            get {
              return resultMap["__typename"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "__typename")
            }
          }

          public var expressionUnaryType: EmbarkExpressionTypeUnary {
            get {
              return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
            }
            set {
              resultMap.updateValue(newValue, forKey: "expressionUnaryType")
            }
          }

          public var text: String? {
            get {
              return resultMap["text"] as? String
            }
            set {
              resultMap.updateValue(newValue, forKey: "text")
            }
          }

          public var fragments: Fragments {
            get {
              return Fragments(unsafeResultMap: resultMap)
            }
            set {
              resultMap += newValue.resultMap
            }
          }

          public struct Fragments {
            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public var expressionFragment: ExpressionFragment {
              get {
                return ExpressionFragment(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }

            public var basicExpressionFragment: BasicExpressionFragment {
              get {
                return BasicExpressionFragment(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }
          }
        }

        public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
          get {
            if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
            return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
          }
          set {
            guard let newValue = newValue else { return }
            resultMap = newValue.resultMap
          }
        }

        public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
          public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

          public static var selections: [GraphQLSelection] {
            return [
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
              GraphQLField("key", type: .nonNull(.scalar(String.self))),
              GraphQLField("value", type: .nonNull(.scalar(String.self))),
              GraphQLField("text", type: .scalar(String.self)),
            ]
          }

          public private(set) var resultMap: ResultMap

          public init(unsafeResultMap: ResultMap) {
            self.resultMap = unsafeResultMap
          }

          public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
            self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
          }

          public var __typename: String {
            get {
              return resultMap["__typename"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "__typename")
            }
          }

          public var expressionBinaryType: EmbarkExpressionTypeBinary {
            get {
              return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
            }
            set {
              resultMap.updateValue(newValue, forKey: "expressionBinaryType")
            }
          }

          public var key: String {
            get {
              return resultMap["key"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "key")
            }
          }

          public var value: String {
            get {
              return resultMap["value"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "value")
            }
          }

          public var text: String? {
            get {
              return resultMap["text"] as? String
            }
            set {
              resultMap.updateValue(newValue, forKey: "text")
            }
          }

          public var fragments: Fragments {
            get {
              return Fragments(unsafeResultMap: resultMap)
            }
            set {
              resultMap += newValue.resultMap
            }
          }

          public struct Fragments {
            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public var expressionFragment: ExpressionFragment {
              get {
                return ExpressionFragment(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }

            public var basicExpressionFragment: BasicExpressionFragment {
              get {
                return BasicExpressionFragment(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }
          }
        }

        public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
          get {
            if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
            return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
          }
          set {
            guard let newValue = newValue else { return }
            resultMap = newValue.resultMap
          }
        }

        public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
          public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

          public static var selections: [GraphQLSelection] {
            return [
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
              GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
              GraphQLField("text", type: .scalar(String.self)),
              GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
            ]
          }

          public private(set) var resultMap: ResultMap

          public init(unsafeResultMap: ResultMap) {
            self.resultMap = unsafeResultMap
          }

          public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
            self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
          }

          public var __typename: String {
            get {
              return resultMap["__typename"]! as! String
            }
            set {
              resultMap.updateValue(newValue, forKey: "__typename")
            }
          }

          public var expressionMultipleType: EmbarkExpressionTypeMultiple {
            get {
              return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
            }
            set {
              resultMap.updateValue(newValue, forKey: "expressionMultipleType")
            }
          }

          public var text: String? {
            get {
              return resultMap["text"] as? String
            }
            set {
              resultMap.updateValue(newValue, forKey: "text")
            }
          }

          public var subExpressions: [SubExpression] {
            get {
              return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
            }
            set {
              resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
            }
          }

          public var fragments: Fragments {
            get {
              return Fragments(unsafeResultMap: resultMap)
            }
            set {
              resultMap += newValue.resultMap
            }
          }

          public struct Fragments {
            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public var expressionFragment: ExpressionFragment {
              get {
                return ExpressionFragment(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }

            public var basicExpressionFragment: BasicExpressionFragment {
              get {
                return BasicExpressionFragment(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }
          }

          public struct SubExpression: GraphQLSelectionSet {
            public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

            public static var selections: [GraphQLSelection] {
              return [
                GraphQLTypeCase(
                  variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
                  default: [
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                    GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  ]
                )
              ]
            }

            public private(set) var resultMap: ResultMap

            public init(unsafeResultMap: ResultMap) {
              self.resultMap = unsafeResultMap
            }

            public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
              return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
            }

            public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
              return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
            }

            public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> SubExpression {
              return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
            }

            public var __typename: String {
              get {
                return resultMap["__typename"]! as! String
              }
              set {
                resultMap.updateValue(newValue, forKey: "__typename")
              }
            }

            public var fragments: Fragments {
              get {
                return Fragments(unsafeResultMap: resultMap)
              }
              set {
                resultMap += newValue.resultMap
              }
            }

            public struct Fragments {
              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public var basicExpressionFragment: BasicExpressionFragment {
                get {
                  return BasicExpressionFragment(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }
            }

            public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
              get {
                if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap = newValue.resultMap
              }
            }

            public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                  GraphQLField("text", type: .scalar(String.self)),
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var expressionUnaryType: EmbarkExpressionTypeUnary {
                get {
                  return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                }
                set {
                  resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                }
              }

              public var text: String? {
                get {
                  return resultMap["text"] as? String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "text")
                }
              }

              public var fragments: Fragments {
                get {
                  return Fragments(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public struct Fragments {
                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public var basicExpressionFragment: BasicExpressionFragment {
                  get {
                    return BasicExpressionFragment(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }
              }
            }

            public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
              get {
                if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap = newValue.resultMap
              }
            }

            public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                  GraphQLField("key", type: .nonNull(.scalar(String.self))),
                  GraphQLField("value", type: .nonNull(.scalar(String.self))),
                  GraphQLField("text", type: .scalar(String.self)),
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var expressionBinaryType: EmbarkExpressionTypeBinary {
                get {
                  return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                }
                set {
                  resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                }
              }

              public var key: String {
                get {
                  return resultMap["key"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "key")
                }
              }

              public var value: String {
                get {
                  return resultMap["value"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "value")
                }
              }

              public var text: String? {
                get {
                  return resultMap["text"] as? String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "text")
                }
              }

              public var fragments: Fragments {
                get {
                  return Fragments(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public struct Fragments {
                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public var basicExpressionFragment: BasicExpressionFragment {
                  get {
                    return BasicExpressionFragment(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }
              }
            }

            public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
              get {
                if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
                return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
              }
              set {
                guard let newValue = newValue else { return }
                resultMap = newValue.resultMap
              }
            }

            public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
              public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

              public static var selections: [GraphQLSelection] {
                return [
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                  GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
                  GraphQLField("text", type: .scalar(String.self)),
                  GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
                ]
              }

              public private(set) var resultMap: ResultMap

              public init(unsafeResultMap: ResultMap) {
                self.resultMap = unsafeResultMap
              }

              public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
                self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
              }

              public var __typename: String {
                get {
                  return resultMap["__typename"]! as! String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "__typename")
                }
              }

              public var expressionMultipleType: EmbarkExpressionTypeMultiple {
                get {
                  return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
                }
                set {
                  resultMap.updateValue(newValue, forKey: "expressionMultipleType")
                }
              }

              public var text: String? {
                get {
                  return resultMap["text"] as? String
                }
                set {
                  resultMap.updateValue(newValue, forKey: "text")
                }
              }

              public var subExpressions: [SubExpression] {
                get {
                  return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
                }
                set {
                  resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
                }
              }

              public var fragments: Fragments {
                get {
                  return Fragments(unsafeResultMap: resultMap)
                }
                set {
                  resultMap += newValue.resultMap
                }
              }

              public struct Fragments {
                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public var basicExpressionFragment: BasicExpressionFragment {
                  get {
                    return BasicExpressionFragment(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }
              }

              public struct SubExpression: GraphQLSelectionSet {
                public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

                public static var selections: [GraphQLSelection] {
                  return [
                    GraphQLTypeCase(
                      variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections, "EmbarkExpressionMultiple": AsEmbarkExpressionMultiple.selections],
                      default: [
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                        GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      ]
                    )
                  ]
                }

                public private(set) var resultMap: ResultMap

                public init(unsafeResultMap: ResultMap) {
                  self.resultMap = unsafeResultMap
                }

                public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
                  return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                }

                public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
                  return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                }

                public static func makeEmbarkExpressionMultiple(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [AsEmbarkExpressionMultiple.SubExpression]) -> SubExpression {
                  return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: AsEmbarkExpressionMultiple.SubExpression) -> ResultMap in value.resultMap }])
                }

                public var __typename: String {
                  get {
                    return resultMap["__typename"]! as! String
                  }
                  set {
                    resultMap.updateValue(newValue, forKey: "__typename")
                  }
                }

                public var fragments: Fragments {
                  get {
                    return Fragments(unsafeResultMap: resultMap)
                  }
                  set {
                    resultMap += newValue.resultMap
                  }
                }

                public struct Fragments {
                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public var basicExpressionFragment: BasicExpressionFragment {
                    get {
                      return BasicExpressionFragment(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }
                }

                public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                  get {
                    if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                    return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                  }
                  set {
                    guard let newValue = newValue else { return }
                    resultMap = newValue.resultMap
                  }
                }

                public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                      GraphQLField("text", type: .scalar(String.self)),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var expressionUnaryType: EmbarkExpressionTypeUnary {
                    get {
                      return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                    }
                  }

                  public var text: String? {
                    get {
                      return resultMap["text"] as? String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "text")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var basicExpressionFragment: BasicExpressionFragment {
                      get {
                        return BasicExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }
                }

                public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                  get {
                    if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                    return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                  }
                  set {
                    guard let newValue = newValue else { return }
                    resultMap = newValue.resultMap
                  }
                }

                public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                      GraphQLField("key", type: .nonNull(.scalar(String.self))),
                      GraphQLField("value", type: .nonNull(.scalar(String.self))),
                      GraphQLField("text", type: .scalar(String.self)),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var expressionBinaryType: EmbarkExpressionTypeBinary {
                    get {
                      return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                    }
                  }

                  public var key: String {
                    get {
                      return resultMap["key"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "key")
                    }
                  }

                  public var value: String {
                    get {
                      return resultMap["value"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "value")
                    }
                  }

                  public var text: String? {
                    get {
                      return resultMap["text"] as? String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "text")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var basicExpressionFragment: BasicExpressionFragment {
                      get {
                        return BasicExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }
                }

                public var asEmbarkExpressionMultiple: AsEmbarkExpressionMultiple? {
                  get {
                    if !AsEmbarkExpressionMultiple.possibleTypes.contains(__typename) { return nil }
                    return AsEmbarkExpressionMultiple(unsafeResultMap: resultMap)
                  }
                  set {
                    guard let newValue = newValue else { return }
                    resultMap = newValue.resultMap
                  }
                }

                public struct AsEmbarkExpressionMultiple: GraphQLSelectionSet {
                  public static let possibleTypes: [String] = ["EmbarkExpressionMultiple"]

                  public static var selections: [GraphQLSelection] {
                    return [
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                      GraphQLField("type", alias: "expressionMultipleType", type: .nonNull(.scalar(EmbarkExpressionTypeMultiple.self))),
                      GraphQLField("text", type: .scalar(String.self)),
                      GraphQLField("subExpressions", type: .nonNull(.list(.nonNull(.object(SubExpression.selections))))),
                    ]
                  }

                  public private(set) var resultMap: ResultMap

                  public init(unsafeResultMap: ResultMap) {
                    self.resultMap = unsafeResultMap
                  }

                  public init(expressionMultipleType: EmbarkExpressionTypeMultiple, text: String? = nil, subExpressions: [SubExpression]) {
                    self.init(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple", "expressionMultipleType": expressionMultipleType, "text": text, "subExpressions": subExpressions.map { (value: SubExpression) -> ResultMap in value.resultMap }])
                  }

                  public var __typename: String {
                    get {
                      return resultMap["__typename"]! as! String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "__typename")
                    }
                  }

                  public var expressionMultipleType: EmbarkExpressionTypeMultiple {
                    get {
                      return resultMap["expressionMultipleType"]! as! EmbarkExpressionTypeMultiple
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "expressionMultipleType")
                    }
                  }

                  public var text: String? {
                    get {
                      return resultMap["text"] as? String
                    }
                    set {
                      resultMap.updateValue(newValue, forKey: "text")
                    }
                  }

                  public var subExpressions: [SubExpression] {
                    get {
                      return (resultMap["subExpressions"] as! [ResultMap]).map { (value: ResultMap) -> SubExpression in SubExpression(unsafeResultMap: value) }
                    }
                    set {
                      resultMap.updateValue(newValue.map { (value: SubExpression) -> ResultMap in value.resultMap }, forKey: "subExpressions")
                    }
                  }

                  public var fragments: Fragments {
                    get {
                      return Fragments(unsafeResultMap: resultMap)
                    }
                    set {
                      resultMap += newValue.resultMap
                    }
                  }

                  public struct Fragments {
                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public var basicExpressionFragment: BasicExpressionFragment {
                      get {
                        return BasicExpressionFragment(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }
                  }

                  public struct SubExpression: GraphQLSelectionSet {
                    public static let possibleTypes: [String] = ["EmbarkExpressionUnary", "EmbarkExpressionBinary", "EmbarkExpressionMultiple"]

                    public static var selections: [GraphQLSelection] {
                      return [
                        GraphQLTypeCase(
                          variants: ["EmbarkExpressionUnary": AsEmbarkExpressionUnary.selections, "EmbarkExpressionBinary": AsEmbarkExpressionBinary.selections],
                          default: [
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                            GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          ]
                        )
                      ]
                    }

                    public private(set) var resultMap: ResultMap

                    public init(unsafeResultMap: ResultMap) {
                      self.resultMap = unsafeResultMap
                    }

                    public static func makeEmbarkExpressionMultiple() -> SubExpression {
                      return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionMultiple"])
                    }

                    public static func makeEmbarkExpressionUnary(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) -> SubExpression {
                      return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                    }

                    public static func makeEmbarkExpressionBinary(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) -> SubExpression {
                      return SubExpression(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                    }

                    public var __typename: String {
                      get {
                        return resultMap["__typename"]! as! String
                      }
                      set {
                        resultMap.updateValue(newValue, forKey: "__typename")
                      }
                    }

                    public var fragments: Fragments {
                      get {
                        return Fragments(unsafeResultMap: resultMap)
                      }
                      set {
                        resultMap += newValue.resultMap
                      }
                    }

                    public struct Fragments {
                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public var basicExpressionFragment: BasicExpressionFragment {
                        get {
                          return BasicExpressionFragment(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }
                    }

                    public var asEmbarkExpressionUnary: AsEmbarkExpressionUnary? {
                      get {
                        if !AsEmbarkExpressionUnary.possibleTypes.contains(__typename) { return nil }
                        return AsEmbarkExpressionUnary(unsafeResultMap: resultMap)
                      }
                      set {
                        guard let newValue = newValue else { return }
                        resultMap = newValue.resultMap
                      }
                    }

                    public struct AsEmbarkExpressionUnary: GraphQLSelectionSet {
                      public static let possibleTypes: [String] = ["EmbarkExpressionUnary"]

                      public static var selections: [GraphQLSelection] {
                        return [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("type", alias: "expressionUnaryType", type: .nonNull(.scalar(EmbarkExpressionTypeUnary.self))),
                          GraphQLField("text", type: .scalar(String.self)),
                        ]
                      }

                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public init(expressionUnaryType: EmbarkExpressionTypeUnary, text: String? = nil) {
                        self.init(unsafeResultMap: ["__typename": "EmbarkExpressionUnary", "expressionUnaryType": expressionUnaryType, "text": text])
                      }

                      public var __typename: String {
                        get {
                          return resultMap["__typename"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "__typename")
                        }
                      }

                      public var expressionUnaryType: EmbarkExpressionTypeUnary {
                        get {
                          return resultMap["expressionUnaryType"]! as! EmbarkExpressionTypeUnary
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "expressionUnaryType")
                        }
                      }

                      public var text: String? {
                        get {
                          return resultMap["text"] as? String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "text")
                        }
                      }

                      public var fragments: Fragments {
                        get {
                          return Fragments(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public struct Fragments {
                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public var basicExpressionFragment: BasicExpressionFragment {
                          get {
                            return BasicExpressionFragment(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }
                      }
                    }

                    public var asEmbarkExpressionBinary: AsEmbarkExpressionBinary? {
                      get {
                        if !AsEmbarkExpressionBinary.possibleTypes.contains(__typename) { return nil }
                        return AsEmbarkExpressionBinary(unsafeResultMap: resultMap)
                      }
                      set {
                        guard let newValue = newValue else { return }
                        resultMap = newValue.resultMap
                      }
                    }

                    public struct AsEmbarkExpressionBinary: GraphQLSelectionSet {
                      public static let possibleTypes: [String] = ["EmbarkExpressionBinary"]

                      public static var selections: [GraphQLSelection] {
                        return [
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("__typename", type: .nonNull(.scalar(String.self))),
                          GraphQLField("type", alias: "expressionBinaryType", type: .nonNull(.scalar(EmbarkExpressionTypeBinary.self))),
                          GraphQLField("key", type: .nonNull(.scalar(String.self))),
                          GraphQLField("value", type: .nonNull(.scalar(String.self))),
                          GraphQLField("text", type: .scalar(String.self)),
                        ]
                      }

                      public private(set) var resultMap: ResultMap

                      public init(unsafeResultMap: ResultMap) {
                        self.resultMap = unsafeResultMap
                      }

                      public init(expressionBinaryType: EmbarkExpressionTypeBinary, key: String, value: String, text: String? = nil) {
                        self.init(unsafeResultMap: ["__typename": "EmbarkExpressionBinary", "expressionBinaryType": expressionBinaryType, "key": key, "value": value, "text": text])
                      }

                      public var __typename: String {
                        get {
                          return resultMap["__typename"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "__typename")
                        }
                      }

                      public var expressionBinaryType: EmbarkExpressionTypeBinary {
                        get {
                          return resultMap["expressionBinaryType"]! as! EmbarkExpressionTypeBinary
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "expressionBinaryType")
                        }
                      }

                      public var key: String {
                        get {
                          return resultMap["key"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "key")
                        }
                      }

                      public var value: String {
                        get {
                          return resultMap["value"]! as! String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "value")
                        }
                      }

                      public var text: String? {
                        get {
                          return resultMap["text"] as? String
                        }
                        set {
                          resultMap.updateValue(newValue, forKey: "text")
                        }
                      }

                      public var fragments: Fragments {
                        get {
                          return Fragments(unsafeResultMap: resultMap)
                        }
                        set {
                          resultMap += newValue.resultMap
                        }
                      }

                      public struct Fragments {
                        public private(set) var resultMap: ResultMap

                        public init(unsafeResultMap: ResultMap) {
                          self.resultMap = unsafeResultMap
                        }

                        public var basicExpressionFragment: BasicExpressionFragment {
                          get {
                            return BasicExpressionFragment(unsafeResultMap: resultMap)
                          }
                          set {
                            resultMap += newValue.resultMap
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
